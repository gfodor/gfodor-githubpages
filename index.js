"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node-modules-polyfills:buffer
  var buffer_exports = {};
  __export(buffer_exports, {
    Buffer: () => Buffer2,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    SlowBuffer: () => SlowBuffer,
    isBuffer: () => isBuffer,
    kMaxLength: () => _kMaxLength
  });
  function init() {
    inited = true;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
  }
  function toByteArray(b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    if (len % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 255;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 255;
      arr[L++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = "";
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 63];
      output += lookup[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
  }
  function kMaxLength() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer2.prototype;
    } else {
      if (that === null) {
        that = new Buffer2(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
      return new Buffer2(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error("If encoding is specified then the first argument must be a string");
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }
  function from(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size, fill2, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
    }
    return createBuffer(that, size);
  }
  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that;
  }
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array = new Uint8Array(array);
    } else if (length === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer2.prototype;
    } else {
      that = fromArrayLike(that, array);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }
  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (internalIsBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read2(arr, i + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
    }
  }
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex(n) {
    if (n < 16)
      return "0" + n.toString(16);
    return n.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isnan(val) {
    return val !== val;
  }
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }
  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  }
  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
  }
  var lookup, revLookup, Arr, inited, toString, isArray, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
  var init_buffer = __esm({
    "node-modules-polyfills:buffer"() {
      init_esbuild_inject();
      lookup = [];
      revLookup = [];
      Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      inited = false;
      toString = {}.toString;
      isArray = Array.isArray || function(arr) {
        return toString.call(arr) == "[object Array]";
      };
      INSPECT_MAX_BYTES = 50;
      Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
      _kMaxLength = kMaxLength();
      Buffer2.poolSize = 8192;
      Buffer2._augment = function(arr) {
        arr.__proto__ = Buffer2.prototype;
        return arr;
      };
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(null, value, encodingOrOffset, length);
      };
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        Buffer2.prototype.__proto__ = Uint8Array.prototype;
        Buffer2.__proto__ = Uint8Array;
      }
      Buffer2.alloc = function(size, fill2, encoding) {
        return alloc(null, size, fill2, encoding);
      };
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(null, size);
      };
      Buffer2.isBuffer = isBuffer;
      Buffer2.compare = function compare(a, b) {
        if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (a === b)
          return 0;
        var x = a.length;
        var y = b.length;
        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        var i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        var buffer = Buffer2.allocUnsafe(length);
        var pos = 0;
        for (i = 0; i < list.length; ++i) {
          var buf = list[i];
          if (!internalIsBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          buf.copy(buffer, pos);
          pos += buf.length;
        }
        return buffer;
      };
      Buffer2.byteLength = byteLength;
      Buffer2.prototype._isBuffer = true;
      Buffer2.prototype.swap16 = function swap16() {
        var len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        var len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        var len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString2() {
        var length = this.length | 0;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.equals = function equals(b) {
        if (!internalIsBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        var str = "";
        var max = INSPECT_MAX_BYTES;
        if (this.length > 0) {
          str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
          if (this.length > max)
            str += " ... ";
        }
        return "<Buffer " + str + ">";
      };
      Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
        if (!internalIsBuffer(target)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        var x = thisEnd - thisStart;
        var y = end - start;
        var len = Math.min(x, y);
        var thisCopy = this.slice(thisStart, thisEnd);
        var targetCopy = target.slice(start, end);
        for (var i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      Buffer2.prototype.write = function write2(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset | 0;
          if (isFinite(length)) {
            length = length | 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        var remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        var loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
              return asciiWrite(this, string, offset, length);
            case "latin1":
            case "binary":
              return latin1Write(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      MAX_ARGUMENTS_LENGTH = 4096;
      Buffer2.prototype.slice = function slice(start, end) {
        var len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        var newBuf;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer2.prototype;
        } else {
          var sliceLen = end - start;
          newBuf = new Buffer2(sliceLen, void 0);
          for (var i = 0; i < sliceLen; ++i) {
            newBuf[i] = this[i + start];
          }
        }
        return newBuf;
      };
      Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        var val = this[offset + --byteLength2];
        var mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        var i = byteLength2;
        var mul = 1;
        var val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        var val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return read(this, offset, false, 52, 8);
      };
      Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        byteLength2 = byteLength2 | 0;
        if (!noAssert) {
          var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = 0;
        var mul = 1;
        var sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert) {
          var limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        var i = byteLength2 - 1;
        var mul = 1;
        var sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (!Buffer2.TYPED_ARRAY_SUPPORT)
          value = Math.floor(value);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
        } else {
          objectWriteUInt16(this, value, offset, true);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
        } else {
          objectWriteUInt16(this, value, offset, false);
        }
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
        } else {
          objectWriteUInt32(this, value, offset, true);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset | 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        if (Buffer2.TYPED_ARRAY_SUPPORT) {
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
        } else {
          objectWriteUInt32(this, value, offset, false);
        }
        return offset + 4;
      };
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        var len = end - start;
        var i;
        if (this === target && start < targetStart && targetStart < end) {
          for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
          }
        } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
          for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
          }
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
              val = code;
            }
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
        } else if (typeof val === "number") {
          val = val & 255;
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        var i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
          var len = bytes.length;
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    }
  });

  // node-modules-polyfills-commonjs:buffer
  var require_buffer = __commonJS({
    "node-modules-polyfills-commonjs:buffer"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_buffer(), __toCommonJS(buffer_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/process/browser.js"(exports, module) {
      init_esbuild_inject();
      var process2 = module.exports = {};
      var cachedSetTimeout2;
      var cachedClearTimeout2;
      function defaultSetTimout2() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout2() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout2 = setTimeout;
          } else {
            cachedSetTimeout2 = defaultSetTimout2;
          }
        } catch (e) {
          cachedSetTimeout2 = defaultSetTimout2;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout2 = clearTimeout;
          } else {
            cachedClearTimeout2 = defaultClearTimeout2;
          }
        } catch (e) {
          cachedClearTimeout2 = defaultClearTimeout2;
        }
      })();
      function runTimeout2(fun) {
        if (cachedSetTimeout2 === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout2 === defaultSetTimout2 || !cachedSetTimeout2) && setTimeout) {
          cachedSetTimeout2 = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout2(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout2.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout2.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout2(marker) {
        if (cachedClearTimeout2 === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout2 === defaultClearTimeout2 || !cachedClearTimeout2) && clearTimeout) {
          cachedClearTimeout2 = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout2(marker);
        } catch (e) {
          try {
            return cachedClearTimeout2.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout2.call(this, marker);
          }
        }
      }
      var queue2 = [];
      var draining2 = false;
      var currentQueue2;
      var queueIndex2 = -1;
      function cleanUpNextTick2() {
        if (!draining2 || !currentQueue2) {
          return;
        }
        draining2 = false;
        if (currentQueue2.length) {
          queue2 = currentQueue2.concat(queue2);
        } else {
          queueIndex2 = -1;
        }
        if (queue2.length) {
          drainQueue2();
        }
      }
      function drainQueue2() {
        if (draining2) {
          return;
        }
        var timeout = runTimeout2(cleanUpNextTick2);
        draining2 = true;
        var len = queue2.length;
        while (len) {
          currentQueue2 = queue2;
          queue2 = [];
          while (++queueIndex2 < len) {
            if (currentQueue2) {
              currentQueue2[queueIndex2].run();
            }
          }
          queueIndex2 = -1;
          len = queue2.length;
        }
        currentQueue2 = null;
        draining2 = false;
        runClearTimeout2(timeout);
      }
      process2.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue2.push(new Item2(fun, args));
        if (queue2.length === 1 && !draining2) {
          runTimeout2(drainQueue2);
        }
      };
      function Item2(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process2.title = "browser";
      process2.browser = true;
      process2.env = {};
      process2.argv = [];
      process2.version = "";
      process2.versions = {};
      function noop2() {
      }
      process2.on = noop2;
      process2.addListener = noop2;
      process2.once = noop2;
      process2.off = noop2;
      process2.removeListener = noop2;
      process2.removeAllListeners = noop2;
      process2.emit = noop2;
      process2.prependListener = noop2;
      process2.prependOnceListener = noop2;
      process2.listeners = function(name) {
        return [];
      };
      process2.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process2.cwd = function() {
        return "/";
      };
      process2.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process2.umask = function() {
        return 0;
      };
    }
  });

  // scripts/esbuild.inject.js
  var Buffer3, process;
  var init_esbuild_inject = __esm({
    "scripts/esbuild.inject.js"() {
      "use strict";
      Buffer3 = require_buffer().Buffer;
      process = require_browser();
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports, module) {
      init_esbuild_inject();
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type2 = typeof val;
        if (type2 === "string" && val.length > 0) {
          return parse3(val);
        } else if (type2 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse3(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type2 = (match[2] || "ms").toLowerCase();
        switch (type2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/bugout/node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/bugout/node_modules/debug/src/common.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function setup(env2) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        Object.keys(env2).forEach(function(key) {
          createDebug[key] = env2[key];
        });
        createDebug.instances = [];
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          var hash = 0;
          for (var i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          var prevTime;
          function debug2() {
            if (!debug2.enabled) {
              return;
            }
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var self2 = debug2;
            var curr = Number(new Date());
            var ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format3) {
              if (match === "%%") {
                return match;
              }
              index++;
              var formatter = createDebug.formatters[format3];
              if (typeof formatter === "function") {
                var val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            var logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug2.namespace = namespace;
          debug2.enabled = createDebug.enabled(namespace);
          debug2.useColors = createDebug.useColors();
          debug2.color = selectColor(namespace);
          debug2.destroy = destroy;
          debug2.extend = extend;
          if (typeof createDebug.init === "function") {
            createDebug.init(debug2);
          }
          createDebug.instances.push(debug2);
          return debug2;
        }
        function destroy() {
          var index = createDebug.instances.indexOf(this);
          if (index !== -1) {
            createDebug.instances.splice(index, 1);
            return true;
          }
          return false;
        }
        function extend(namespace, delimiter3) {
          return createDebug(this.namespace + (typeof delimiter3 === "undefined" ? ":" : delimiter3) + namespace);
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.names = [];
          createDebug.skips = [];
          var i;
          var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          var len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
          for (i = 0; i < createDebug.instances.length; i++) {
            var instance = createDebug.instances[i];
            instance.enabled = createDebug.enabled(instance.namespace);
          }
        }
        function disable() {
          createDebug.enable("");
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          var i;
          var len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/bugout/node_modules/debug/src/browser.js
  var require_browser2 = __commonJS({
    "node_modules/bugout/node_modules/debug/src/browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      exports.log = log2;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        var c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match) {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      function log2() {
        var _console;
        return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
      }
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load() {
        var r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module.exports = require_common()(exports);
      var formatters = module.exports.formatters;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    }
  });

  // node-modules-polyfills:events
  var events_exports = {};
  __export(events_exports, {
    EventEmitter: () => EventEmitter,
    default: () => events_default
  });
  function EventHandlers() {
  }
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  function $getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  function emitNone(handler, isFn, self2) {
    if (isFn)
      handler.call(self2);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].call(self2);
    }
  }
  function emitOne(handler, isFn, self2, arg1) {
    if (isFn)
      handler.call(self2, arg1);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].call(self2, arg1);
    }
  }
  function emitTwo(handler, isFn, self2, arg1, arg2) {
    if (isFn)
      handler.call(self2, arg1, arg2);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].call(self2, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self2, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].call(self2, arg1, arg2, arg3);
    }
  }
  function emitMany(handler, isFn, self2, args) {
    if (isFn)
      handler.apply(self2, args);
    else {
      var len = handler.length;
      var listeners2 = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners2[i].apply(self2, args);
    }
  }
  function _addListener(target, type2, listener, prepend) {
    var m;
    var events;
    var existing;
    if (typeof listener !== "function")
      throw new TypeError('"listener" argument must be a function');
    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      if (events.newListener) {
        target.emit("newListener", type2, listener.listener ? listener.listener : listener);
        events = target._events;
      }
      existing = events[type2];
    }
    if (!existing) {
      existing = events[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
      } else {
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type2;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }
    return target;
  }
  function emitWarning(e) {
    typeof console.warn === "function" ? console.warn(e) : console.log(e);
  }
  function _onceWrap(target, type2, listener) {
    var fired = false;
    function g() {
      target.removeListener(type2, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }
  function listenerCount(type2) {
    var events = this._events;
    if (events) {
      var evlistener = events[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
    return 0;
  }
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }
  function arrayClone(arr, i) {
    var copy2 = new Array(i);
    while (i--)
      copy2[i] = arr[i];
    return copy2;
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  var domain, events_default;
  var init_events = __esm({
    "node-modules-polyfills:events"() {
      "use strict";
      init_esbuild_inject();
      EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
      events_default = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.usingDomains = false;
      EventEmitter.prototype.domain = void 0;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      EventEmitter.defaultMaxListeners = 10;
      EventEmitter.init = function() {
        this.domain = null;
        if (EventEmitter.usingDomains) {
          if (domain.active && !(this instanceof domain.Domain)) {
            this.domain = domain.active;
          }
        }
        if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      };
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type2) {
        var er, handler, len, args, i, events, domain2;
        var needDomainExit = false;
        var doError = type2 === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        domain2 = this.domain;
        if (doError) {
          er = arguments[1];
          if (domain2) {
            if (!er)
              er = new Error('Uncaught, unspecified "error" event');
            er.domainEmitter = this;
            er.domain = domain2;
            er.domainThrown = false;
            domain2.emit("error", er);
          } else if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
          return false;
        }
        handler = events[type2];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++)
              args[i - 1] = arguments[i];
            emitMany(handler, isFn, this, args);
        }
        if (needDomainExit)
          domain2.exit();
        return true;
      };
      EventEmitter.prototype.addListener = function addListener(type2, listener) {
        return _addListener(this, type2, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
        return _addListener(this, type2, listener, true);
      };
      EventEmitter.prototype.once = function once(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type2, _onceWrap(this, type2, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type2];
        if (!list)
          return this;
        if (list === listener || list.listener && list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type2];
            if (events.removeListener)
              this.emit("removeListener", type2, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length; i-- > 0; ) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (list.length === 1) {
            list[0] = void 0;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type2];
            }
          } else {
            spliceOne(list, position);
          }
          if (events.removeListener)
            this.emit("removeListener", type2, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
        var listeners2, events;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type2]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type2];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys2 = Object.keys(events);
          for (var i = 0, key; i < keys2.length; ++i) {
            key = keys2[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }
        listeners2 = events[type2];
        if (typeof listeners2 === "function") {
          this.removeListener(type2, listeners2);
        } else if (listeners2) {
          do {
            this.removeListener(type2, listeners2[listeners2.length - 1]);
          } while (listeners2[0]);
        }
        return this;
      };
      EventEmitter.prototype.listeners = function listeners(type2) {
        var evlistener;
        var ret;
        var events = this._events;
        if (!events)
          ret = [];
        else {
          evlistener = events[type2];
          if (!evlistener)
            ret = [];
          else if (typeof evlistener === "function")
            ret = [evlistener.listener || evlistener];
          else
            ret = unwrapListeners(evlistener);
        }
        return ret;
      };
      EventEmitter.listenerCount = function(emitter, type2) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type2);
        } else {
          return listenerCount.call(emitter, type2);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
    }
  });

  // node-modules-polyfills-commonjs:events
  var require_events = __commonJS({
    "node-modules-polyfills-commonjs:events"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_events(), __toCommonJS(events_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills:path
  var path_exports = {};
  __export(path_exports, {
    basename: () => basename,
    default: () => path_default,
    delimiter: () => delimiter,
    dirname: () => dirname,
    extname: () => extname,
    isAbsolute: () => isAbsolute,
    join: () => join,
    normalize: () => normalize,
    relative: () => relative,
    resolve: () => resolve,
    sep: () => sep
  });
  function normalizeArray(parts, allowAboveRoot) {
    var up = 0;
    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];
      if (last === ".") {
        parts.splice(i, 1);
      } else if (last === "..") {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }
    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift("..");
      }
    }
    return parts;
  }
  function resolve() {
    var resolvedPath = "", resolvedAbsolute = false;
    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = i >= 0 ? arguments[i] : "/";
      if (typeof path !== "string") {
        throw new TypeError("Arguments to path.resolve must be strings");
      } else if (!path) {
        continue;
      }
      resolvedPath = path + "/" + resolvedPath;
      resolvedAbsolute = path.charAt(0) === "/";
    }
    resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
      return !!p;
    }), !resolvedAbsolute).join("/");
    return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
  }
  function normalize(path) {
    var isPathAbsolute = isAbsolute(path), trailingSlash = substr(path, -1) === "/";
    path = normalizeArray(filter(path.split("/"), function(p) {
      return !!p;
    }), !isPathAbsolute).join("/");
    if (!path && !isPathAbsolute) {
      path = ".";
    }
    if (path && trailingSlash) {
      path += "/";
    }
    return (isPathAbsolute ? "/" : "") + path;
  }
  function isAbsolute(path) {
    return path.charAt(0) === "/";
  }
  function join() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return normalize(filter(paths, function(p, index) {
      if (typeof p !== "string") {
        throw new TypeError("Arguments to path.join must be strings");
      }
      return p;
    }).join("/"));
  }
  function relative(from2, to) {
    from2 = resolve(from2).substr(1);
    to = resolve(to).substr(1);
    function trim(arr) {
      var start = 0;
      for (; start < arr.length; start++) {
        if (arr[start] !== "")
          break;
      }
      var end = arr.length - 1;
      for (; end >= 0; end--) {
        if (arr[end] !== "")
          break;
      }
      if (start > end)
        return [];
      return arr.slice(start, end - start + 1);
    }
    var fromParts = trim(from2.split("/"));
    var toParts = trim(to.split("/"));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }
    var outputParts = [];
    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push("..");
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join("/");
  }
  function dirname(path) {
    var result = splitPath(path), root = result[0], dir = result[1];
    if (!root && !dir) {
      return ".";
    }
    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
  }
  function basename(path, ext) {
    var f = splitPath(path)[2];
    if (ext && f.substr(-1 * ext.length) === ext) {
      f = f.substr(0, f.length - ext.length);
    }
    return f;
  }
  function extname(path) {
    return splitPath(path)[3];
  }
  function filter(xs, f) {
    if (xs.filter)
      return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      if (f(xs[i], i, xs))
        res.push(xs[i]);
    }
    return res;
  }
  var splitPathRe, splitPath, sep, delimiter, path_default, substr;
  var init_path = __esm({
    "node-modules-polyfills:path"() {
      init_esbuild_inject();
      splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      splitPath = function(filename) {
        return splitPathRe.exec(filename).slice(1);
      };
      sep = "/";
      delimiter = ":";
      path_default = {
        extname,
        basename,
        dirname,
        sep,
        delimiter,
        relative,
        join,
        isAbsolute,
        normalize,
        resolve
      };
      substr = "ab".substr(-1) === "b" ? function(str, start, len) {
        return str.substr(start, len);
      } : function(str, start, len) {
        if (start < 0)
          start = str.length + start;
        return str.substr(start, len);
      };
    }
  });

  // node-modules-polyfills-commonjs:path
  var require_path = __commonJS({
    "node-modules-polyfills-commonjs:path"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_path(), __toCommonJS(path_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node_modules/simple-concat/index.js
  var require_simple_concat = __commonJS({
    "node_modules/simple-concat/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function(stream, cb) {
        var chunks = [];
        stream.on("data", function(chunk) {
          chunks.push(chunk);
        });
        stream.once("end", function() {
          if (cb)
            cb(null, Buffer3.concat(chunks));
          cb = null;
        });
        stream.once("error", function(err) {
          if (cb)
            cb(err);
          cb = null;
        });
      };
    }
  });

  // node_modules/bencode/lib/util.js
  var require_util = __commonJS({
    "node_modules/bencode/lib/util.js"(exports, module) {
      init_esbuild_inject();
      var util = module.exports;
      util.digitCount = function digitCount(value) {
        const sign = value < 0 ? 1 : 0;
        value = Math.abs(Number(value || 1));
        return Math.floor(Math.log10(value)) + 1 + sign;
      };
      util.getType = function getType(value) {
        if (Buffer3.isBuffer(value))
          return "buffer";
        if (ArrayBuffer.isView(value))
          return "arraybufferview";
        if (Array.isArray(value))
          return "array";
        if (value instanceof Number)
          return "number";
        if (value instanceof Boolean)
          return "boolean";
        if (value instanceof Set)
          return "set";
        if (value instanceof Map)
          return "map";
        if (value instanceof String)
          return "string";
        if (value instanceof ArrayBuffer)
          return "arraybuffer";
        return typeof value;
      };
    }
  });

  // node_modules/bencode/lib/encode.js
  var require_encode = __commonJS({
    "node_modules/bencode/lib/encode.js"(exports, module) {
      init_esbuild_inject();
      var { getType } = require_util();
      function encode3(data, buffer, offset) {
        const buffers = [];
        let result = null;
        encode3._encode(buffers, data);
        result = Buffer3.concat(buffers);
        encode3.bytes = result.length;
        if (Buffer3.isBuffer(buffer)) {
          result.copy(buffer, offset);
          return buffer;
        }
        return result;
      }
      encode3.bytes = -1;
      encode3._floatConversionDetected = false;
      encode3._encode = function(buffers, data) {
        if (data == null) {
          return;
        }
        switch (getType(data)) {
          case "buffer":
            encode3.buffer(buffers, data);
            break;
          case "object":
            encode3.dict(buffers, data);
            break;
          case "map":
            encode3.dictMap(buffers, data);
            break;
          case "array":
            encode3.list(buffers, data);
            break;
          case "set":
            encode3.listSet(buffers, data);
            break;
          case "string":
            encode3.string(buffers, data);
            break;
          case "number":
            encode3.number(buffers, data);
            break;
          case "boolean":
            encode3.number(buffers, data);
            break;
          case "arraybufferview":
            encode3.buffer(buffers, Buffer3.from(data.buffer, data.byteOffset, data.byteLength));
            break;
          case "arraybuffer":
            encode3.buffer(buffers, Buffer3.from(data));
            break;
        }
      };
      var buffE = Buffer3.from("e");
      var buffD = Buffer3.from("d");
      var buffL = Buffer3.from("l");
      encode3.buffer = function(buffers, data) {
        buffers.push(Buffer3.from(data.length + ":"), data);
      };
      encode3.string = function(buffers, data) {
        buffers.push(Buffer3.from(Buffer3.byteLength(data) + ":" + data));
      };
      encode3.number = function(buffers, data) {
        const maxLo = 2147483648;
        const hi = data / maxLo << 0;
        const lo = data % maxLo << 0;
        const val = hi * maxLo + lo;
        buffers.push(Buffer3.from("i" + val + "e"));
        if (val !== data && !encode3._floatConversionDetected) {
          encode3._floatConversionDetected = true;
          console.warn('WARNING: Possible data corruption detected with value "' + data + '":', 'Bencoding only defines support for integers, value was converted to "' + val + '"');
          console.trace();
        }
      };
      encode3.dict = function(buffers, data) {
        buffers.push(buffD);
        let j = 0;
        let k;
        const keys2 = Object.keys(data).sort();
        const kl = keys2.length;
        for (; j < kl; j++) {
          k = keys2[j];
          if (data[k] == null)
            continue;
          encode3.string(buffers, k);
          encode3._encode(buffers, data[k]);
        }
        buffers.push(buffE);
      };
      encode3.dictMap = function(buffers, data) {
        buffers.push(buffD);
        const keys2 = Array.from(data.keys()).sort();
        for (const key of keys2) {
          if (data.get(key) == null)
            continue;
          Buffer3.isBuffer(key) ? encode3._encode(buffers, key) : encode3.string(buffers, String(key));
          encode3._encode(buffers, data.get(key));
        }
        buffers.push(buffE);
      };
      encode3.list = function(buffers, data) {
        let i = 0;
        const c = data.length;
        buffers.push(buffL);
        for (; i < c; i++) {
          if (data[i] == null)
            continue;
          encode3._encode(buffers, data[i]);
        }
        buffers.push(buffE);
      };
      encode3.listSet = function(buffers, data) {
        buffers.push(buffL);
        for (const item of data) {
          if (item == null)
            continue;
          encode3._encode(buffers, item);
        }
        buffers.push(buffE);
      };
      module.exports = encode3;
    }
  });

  // node_modules/bencode/lib/decode.js
  var require_decode = __commonJS({
    "node_modules/bencode/lib/decode.js"(exports, module) {
      init_esbuild_inject();
      var INTEGER_START = 105;
      var STRING_DELIM = 58;
      var DICTIONARY_START = 100;
      var LIST_START = 108;
      var END_OF_TYPE = 101;
      function getIntFromBuffer(buffer, start, end) {
        let sum = 0;
        let sign = 1;
        for (let i = start; i < end; i++) {
          const num = buffer[i];
          if (num < 58 && num >= 48) {
            sum = sum * 10 + (num - 48);
            continue;
          }
          if (i === start && num === 43) {
            continue;
          }
          if (i === start && num === 45) {
            sign = -1;
            continue;
          }
          if (num === 46) {
            break;
          }
          throw new Error("not a number: buffer[" + i + "] = " + num);
        }
        return sum * sign;
      }
      function decode2(data, start, end, encoding) {
        if (data == null || data.length === 0) {
          return null;
        }
        if (typeof start !== "number" && encoding == null) {
          encoding = start;
          start = void 0;
        }
        if (typeof end !== "number" && encoding == null) {
          encoding = end;
          end = void 0;
        }
        decode2.position = 0;
        decode2.encoding = encoding || null;
        decode2.data = !Buffer3.isBuffer(data) ? Buffer3.from(data) : data.slice(start, end);
        decode2.bytes = decode2.data.length;
        return decode2.next();
      }
      decode2.bytes = 0;
      decode2.position = 0;
      decode2.data = null;
      decode2.encoding = null;
      decode2.next = function() {
        switch (decode2.data[decode2.position]) {
          case DICTIONARY_START:
            return decode2.dictionary();
          case LIST_START:
            return decode2.list();
          case INTEGER_START:
            return decode2.integer();
          default:
            return decode2.buffer();
        }
      };
      decode2.find = function(chr) {
        let i = decode2.position;
        const c = decode2.data.length;
        const d = decode2.data;
        while (i < c) {
          if (d[i] === chr)
            return i;
          i++;
        }
        throw new Error('Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]");
      };
      decode2.dictionary = function() {
        decode2.position++;
        const dict = {};
        while (decode2.data[decode2.position] !== END_OF_TYPE) {
          dict[decode2.buffer()] = decode2.next();
        }
        decode2.position++;
        return dict;
      };
      decode2.list = function() {
        decode2.position++;
        const lst = [];
        while (decode2.data[decode2.position] !== END_OF_TYPE) {
          lst.push(decode2.next());
        }
        decode2.position++;
        return lst;
      };
      decode2.integer = function() {
        const end = decode2.find(END_OF_TYPE);
        const number = getIntFromBuffer(decode2.data, decode2.position + 1, end);
        decode2.position += end + 1 - decode2.position;
        return number;
      };
      decode2.buffer = function() {
        let sep2 = decode2.find(STRING_DELIM);
        const length = getIntFromBuffer(decode2.data, decode2.position, sep2);
        const end = ++sep2 + length;
        decode2.position = end;
        return decode2.encoding ? decode2.data.toString(decode2.encoding, sep2, end) : decode2.data.slice(sep2, end);
      };
      module.exports = decode2;
    }
  });

  // node_modules/bencode/lib/encoding-length.js
  var require_encoding_length = __commonJS({
    "node_modules/bencode/lib/encoding-length.js"(exports, module) {
      init_esbuild_inject();
      var { digitCount, getType } = require_util();
      function listLength(list) {
        let length = 1 + 1;
        for (const value of list) {
          length += encodingLength(value);
        }
        return length;
      }
      function mapLength(map3) {
        let length = 1 + 1;
        for (const [key, value] of map3) {
          const keyLength = Buffer3.byteLength(key);
          length += digitCount(keyLength) + 1 + keyLength;
          length += encodingLength(value);
        }
        return length;
      }
      function objectLength(value) {
        let length = 1 + 1;
        const keys2 = Object.keys(value);
        for (let i = 0; i < keys2.length; i++) {
          const keyLength = Buffer3.byteLength(keys2[i]);
          length += digitCount(keyLength) + 1 + keyLength;
          length += encodingLength(value[keys2[i]]);
        }
        return length;
      }
      function stringLength(value) {
        const length = Buffer3.byteLength(value);
        return digitCount(length) + 1 + length;
      }
      function arrayBufferLength(value) {
        const length = value.byteLength - value.byteOffset;
        return digitCount(length) + 1 + length;
      }
      function encodingLength(value) {
        const length = 0;
        if (value == null)
          return length;
        const type2 = getType(value);
        switch (type2) {
          case "buffer":
            return digitCount(value.length) + 1 + value.length;
          case "arraybufferview":
            return arrayBufferLength(value);
          case "string":
            return stringLength(value);
          case "array":
          case "set":
            return listLength(value);
          case "number":
            return 1 + digitCount(Math.floor(value)) + 1;
          case "bigint":
            return 1 + value.toString().length + 1;
          case "object":
            return objectLength(value);
          case "map":
            return mapLength(value);
          default:
            throw new TypeError(`Unsupported value of type "${type2}"`);
        }
      }
      module.exports = encodingLength;
    }
  });

  // node_modules/bencode/lib/index.js
  var require_lib = __commonJS({
    "node_modules/bencode/lib/index.js"(exports, module) {
      init_esbuild_inject();
      var bencode = module.exports;
      bencode.encode = require_encode();
      bencode.decode = require_decode();
      bencode.byteLength = bencode.encodingLength = require_encoding_length();
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node-modules-polyfills:process
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function binding(name) {
    throw new Error("process.binding is not supported");
  }
  function cwd() {
    return "/";
  }
  function chdir(dir) {
    throw new Error("process.chdir is not supported");
  }
  function umask() {
    return 0;
  }
  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds, nanoseconds];
  }
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1e3;
  }
  var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance, performanceNow, startTime, browser$1, process_default;
  var init_process = __esm({
    "node-modules-polyfills:process"() {
      init_esbuild_inject();
      cachedSetTimeout = defaultSetTimout;
      cachedClearTimeout = defaultClearTimeout;
      if (typeof globalThis.setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      }
      if (typeof globalThis.clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      }
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      platform = "browser";
      browser = true;
      env = {};
      argv = [];
      version = "";
      versions = {};
      release = {};
      config = {};
      on = noop;
      addListener2 = noop;
      once2 = noop;
      off = noop;
      removeListener2 = noop;
      removeAllListeners2 = noop;
      emit2 = noop;
      performance = globalThis.performance || {};
      performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
        return new Date().getTime();
      };
      startTime = new Date();
      browser$1 = {
        nextTick,
        title,
        browser,
        env,
        argv,
        version,
        versions,
        on,
        addListener: addListener2,
        once: once2,
        off,
        removeListener: removeListener2,
        removeAllListeners: removeAllListeners2,
        emit: emit2,
        binding,
        cwd,
        chdir,
        umask,
        hrtime,
        platform,
        release,
        config,
        uptime
      };
      process_default = browser$1;
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
  var inherits, inherits_default;
  var init_inherits = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
      init_esbuild_inject();
      if (typeof Object.create === "function") {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        inherits = function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
      inherits_default = inherits;
    }
  });

  // node-modules-polyfills:util
  var util_exports = {};
  __export(util_exports, {
    _extend: () => _extend,
    debuglog: () => debuglog,
    default: () => util_default,
    deprecate: () => deprecate,
    format: () => format,
    inherits: () => inherits_default,
    inspect: () => inspect2,
    isArray: () => isArray2,
    isBoolean: () => isBoolean,
    isBuffer: () => isBuffer2,
    isDate: () => isDate,
    isError: () => isError,
    isFunction: () => isFunction,
    isNull: () => isNull,
    isNullOrUndefined: () => isNullOrUndefined,
    isNumber: () => isNumber,
    isObject: () => isObject,
    isPrimitive: () => isPrimitive,
    isRegExp: () => isRegExp,
    isString: () => isString,
    isSymbol: () => isSymbol,
    isUndefined: () => isUndefined,
    log: () => log
  });
  function format(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect2(arguments[i]));
      }
      return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%")
        return "%";
      if (i >= len)
        return x2;
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += " " + x;
      } else {
        str += " " + inspect2(x);
      }
    }
    return str;
  }
  function deprecate(fn, msg) {
    if (isUndefined(globalThis.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }
    if (process_default.noDeprecation === true) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process_default.throwDeprecation) {
          throw new Error(msg);
        } else if (process_default.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function debuglog(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = process_default.env.NODE_DEBUG || "";
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format.apply(null, arguments);
          console.error("%s %d: %s", set, pid, msg);
        };
      } else {
        debugs[set] = function() {
        };
      }
    }
    return debugs[set];
  }
  function inspect2(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      _extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  function stylizeWithColor(str, styleType) {
    var style = inspect2.styles[styleType];
    if (style) {
      return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys2 = Object.keys(value);
    var visibleKeys = arrayToHash(keys2);
    if (ctx.showHidden) {
      keys2 = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys2.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base2 = "", array = false, braces = ["{", "}"];
    if (isArray2(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction(value)) {
      var n = value.name ? ": " + value.name : "";
      base2 = " [Function" + n + "]";
    }
    if (isRegExp(value)) {
      base2 = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
      base2 = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base2 = " " + formatError(value);
    }
    if (keys2.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base2 + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
    } else {
      output = keys2.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base2, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push("");
      }
    }
    keys2.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output, base2, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf("\n") >= 0)
        numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
  }
  function isArray2(ar) {
    return Array.isArray(ar);
  }
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  function isNumber(arg) {
    return typeof arg === "number";
  }
  function isString(arg) {
    return typeof arg === "string";
  }
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  function isUndefined(arg) {
    return arg === void 0;
  }
  function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
  }
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function isDate(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
  }
  function isError(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
  }
  function isFunction(arg) {
    return typeof arg === "function";
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  function isBuffer2(maybeBuf) {
    return Buffer3.isBuffer(maybeBuf);
  }
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  function timestamp() {
    var d = new Date();
    var time = [
      pad(d.getHours()),
      pad(d.getMinutes()),
      pad(d.getSeconds())
    ].join(":");
    return [d.getDate(), months[d.getMonth()], time].join(" ");
  }
  function log() {
    console.log("%s - %s", timestamp(), format.apply(null, arguments));
  }
  function _extend(origin, add) {
    if (!add || !isObject(add))
      return origin;
    var keys2 = Object.keys(add);
    var i = keys2.length;
    while (i--) {
      origin[keys2[i]] = add[keys2[i]];
    }
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var formatRegExp, debugs, debugEnviron, months, util_default;
  var init_util = __esm({
    "node-modules-polyfills:util"() {
      init_esbuild_inject();
      init_process();
      init_inherits();
      formatRegExp = /%[sdj%]/g;
      debugs = {};
      inspect2.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect2.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      util_default = {
        inherits: inherits_default,
        _extend,
        log,
        isBuffer: isBuffer2,
        isPrimitive,
        isFunction,
        isError,
        isDate,
        isObject,
        isRegExp,
        isUndefined,
        isSymbol,
        isString,
        isNumber,
        isNullOrUndefined,
        isNull,
        isBoolean,
        isArray: isArray2,
        inspect: inspect2,
        deprecate,
        format,
        debuglog
      };
    }
  });

  // node-modules-polyfills-commonjs:util
  var require_util2 = __commonJS({
    "node-modules-polyfills-commonjs:util"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_util(), __toCommonJS(util_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/errors-browser.js
  var require_errors_browser = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      init_esbuild_inject();
      if (typeof Object.create === "function") {
        module.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util-deprecate/browser.js
  var require_browser3 = __commonJS({
    "node_modules/util-deprecate/browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = deprecate2;
      function deprecate2(fn, msg) {
        if (config2("noDeprecation")) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (config2("throwDeprecation")) {
              throw new Error(msg);
            } else if (config2("traceDeprecation")) {
              console.trace(msg);
            } else {
              console.warn(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      }
      function config2(name) {
        try {
          if (!globalThis.localStorage)
            return false;
        } catch (_) {
          return false;
        }
        var val = globalThis.localStorage[name];
        if (val == null)
          return false;
        return String(val).toLowerCase() === "true";
      }
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable();
      var Writable2 = require_stream_writable();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/safe-buffer/index.js
  var require_safe_buffer = __commonJS({
    "node_modules/safe-buffer/index.js"(exports, module) {
      init_esbuild_inject();
      var buffer = require_buffer();
      var Buffer4 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
        module.exports = buffer;
      } else {
        copyProps(buffer, exports);
        exports.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer4(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer4.prototype);
      copyProps(Buffer4, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer4(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill2, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer4(size);
        if (fill2 !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill2, encoding);
          } else {
            buf.fill(fill2);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer4(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }
  });

  // node_modules/string_decoder/lib/string_decoder.js
  var require_string_decoder = __commonJS({
    "node_modules/string_decoder/lib/string_decoder.js"(exports) {
      "use strict";
      init_esbuild_inject();
      var Buffer4 = require_safe_buffer().Buffer;
      var isEncoding2 = Buffer4.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer4.isEncoding === isEncoding2 || !isEncoding2(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports.StringDecoder = StringDecoder2;
      function StringDecoder2(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer4.allocUnsafe(nb);
      }
      StringDecoder2.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0)
            return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length)
          return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder2.prototype.end = utf8End;
      StringDecoder2.prototype.text = utf8Text;
      StringDecoder2.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i)
          return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "\uFFFD";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "\uFFFD";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "\uFFFD";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf, p);
        if (r !== void 0)
          return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed)
          return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + "\uFFFD";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0)
          return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list();
      var destroyImpl = require_destroy();
      var _require = require_state();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/block-stream2/node_modules/readable-stream/readable-browser.js
  var require_readable_browser = __commonJS({
    "node_modules/block-stream2/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
      exports.finished = require_end_of_stream();
      exports.pipeline = require_pipeline();
    }
  });

  // node_modules/block-stream2/index.js
  var require_block_stream2 = __commonJS({
    "node_modules/block-stream2/index.js"(exports, module) {
      init_esbuild_inject();
      var { Transform: Transform2 } = require_readable_browser();
      var Block = class extends Transform2 {
        constructor(size, opts = {}) {
          super(opts);
          if (typeof size === "object") {
            opts = size;
            size = opts.size;
          }
          this.size = size || 512;
          const { nopad, zeroPadding = true } = opts;
          if (nopad)
            this._zeroPadding = false;
          else
            this._zeroPadding = !!zeroPadding;
          this._buffered = [];
          this._bufferedBytes = 0;
        }
        _transform(buf, enc, next) {
          this._bufferedBytes += buf.length;
          this._buffered.push(buf);
          while (this._bufferedBytes >= this.size) {
            this._bufferedBytes -= this.size;
            const blockBufs = [];
            let blockBufsBytes = 0;
            while (blockBufsBytes < this.size) {
              const b = this._buffered.shift();
              if (blockBufsBytes + b.length <= this.size) {
                blockBufs.push(b);
                blockBufsBytes += b.length;
              } else {
                const neededSize = this.size - blockBufsBytes;
                blockBufs.push(b.slice(0, neededSize));
                blockBufsBytes += neededSize;
                this._buffered.unshift(b.slice(neededSize));
              }
            }
            this.push(Buffer3.concat(blockBufs, this.size));
          }
          next();
        }
        _flush() {
          if (this._bufferedBytes && this._zeroPadding) {
            const zeroes = Buffer3.alloc(this.size - this._bufferedBytes);
            this._buffered.push(zeroes);
            this.push(Buffer3.concat(this._buffered));
            this._buffered = null;
          } else if (this._bufferedBytes) {
            this.push(Buffer3.concat(this._buffered));
            this._buffered = null;
          }
          this.push(null);
        }
      };
      module.exports = Block;
    }
  });

  // node_modules/piece-length/index.js
  var require_piece_length = __commonJS({
    "node_modules/piece-length/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = length;
      function length(bytes) {
        return Math.max(16384, 1 << Math.log2(bytes < 1024 ? 1 : bytes / 1024) + 0.5 | 0);
      }
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/filestream/node_modules/readable-stream/errors-browser.js
  var require_errors_browser2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser2().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser2();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy2();
      var _require = require_state2();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser2().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex2();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex2();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable2();
      var Writable2 = require_stream_writable2();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser2().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream2();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser2();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list2();
      var destroyImpl = require_destroy2();
      var _require = require_state2();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser2().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex2();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex2();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator2();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser2();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser2().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex2();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform2();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/filestream/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser2().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream2();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/filestream/node_modules/readable-stream/readable-browser.js
  var require_readable_browser2 = __commonJS({
    "node_modules/filestream/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable2();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable2();
      exports.Duplex = require_stream_duplex2();
      exports.Transform = require_stream_transform2();
      exports.PassThrough = require_stream_passthrough2();
      exports.finished = require_end_of_stream2();
      exports.pipeline = require_pipeline2();
    }
  });

  // node_modules/is-typedarray/index.js
  var require_is_typedarray = __commonJS({
    "node_modules/is-typedarray/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = isTypedArray;
      isTypedArray.strict = isStrictTypedArray;
      isTypedArray.loose = isLooseTypedArray;
      var toString3 = Object.prototype.toString;
      var names = {
        "[object Int8Array]": true,
        "[object Int16Array]": true,
        "[object Int32Array]": true,
        "[object Uint8Array]": true,
        "[object Uint8ClampedArray]": true,
        "[object Uint16Array]": true,
        "[object Uint32Array]": true,
        "[object Float32Array]": true,
        "[object Float64Array]": true
      };
      function isTypedArray(arr) {
        return isStrictTypedArray(arr) || isLooseTypedArray(arr);
      }
      function isStrictTypedArray(arr) {
        return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
      }
      function isLooseTypedArray(arr) {
        return names[toString3.call(arr)];
      }
    }
  });

  // node_modules/typedarray-to-buffer/index.js
  var require_typedarray_to_buffer = __commonJS({
    "node_modules/typedarray-to-buffer/index.js"(exports, module) {
      init_esbuild_inject();
      var isTypedArray = require_is_typedarray().strict;
      module.exports = function typedarrayToBuffer(arr) {
        if (isTypedArray(arr)) {
          var buf = Buffer3.from(arr.buffer);
          if (arr.byteLength !== arr.buffer.byteLength) {
            buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
          }
          return buf;
        } else {
          return Buffer3.from(arr);
        }
      };
    }
  });

  // node_modules/filestream/read.js
  var require_read = __commonJS({
    "node_modules/filestream/read.js"(exports, module) {
      init_esbuild_inject();
      var { Readable: Readable2 } = require_readable_browser2();
      var toBuffer = require_typedarray_to_buffer();
      var FileReadStream = class extends Readable2 {
        constructor(file, opts = {}) {
          super(opts);
          this._offset = 0;
          this._ready = false;
          this._file = file;
          this._size = file.size;
          this._chunkSize = opts.chunkSize || Math.max(this._size / 1e3, 200 * 1024);
          const reader = new FileReader();
          reader.onload = () => {
            this.push(toBuffer(reader.result));
          };
          reader.onerror = () => {
            this.emit("error", reader.error);
          };
          this.reader = reader;
          this._generateHeaderBlocks(file, opts, (err, blocks) => {
            if (err) {
              return this.emit("error", err);
            }
            if (Array.isArray(blocks)) {
              blocks.forEach((block) => this.push(block));
            }
            this._ready = true;
            this.emit("_ready");
          });
        }
        _generateHeaderBlocks(file, opts, callback) {
          callback(null, []);
        }
        _read() {
          if (!this._ready) {
            this.once("_ready", this._read.bind(this));
            return;
          }
          const startOffset = this._offset;
          let endOffset = this._offset + this._chunkSize;
          if (endOffset > this._size)
            endOffset = this._size;
          if (startOffset === this._size) {
            this.destroy();
            this.push(null);
            return;
          }
          this.reader.readAsArrayBuffer(this._file.slice(startOffset, endOffset));
          this._offset = endOffset;
        }
        destroy() {
          this._file = null;
          if (this.reader) {
            this.reader.onload = null;
            this.reader.onerror = null;
            try {
              this.reader.abort();
            } catch (e) {
            }
            ;
          }
          this.reader = null;
        }
      };
      module.exports = FileReadStream;
    }
  });

  // (disabled):node_modules/is-file/index.js
  var require_is_file = __commonJS({
    "(disabled):node_modules/is-file/index.js"() {
      init_esbuild_inject();
    }
  });

  // node_modules/junk/index.js
  var require_junk = __commonJS({
    "node_modules/junk/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var blacklist = [
        "^npm-debug\\.log$",
        "^\\..*\\.swp$",
        "^\\.DS_Store$",
        "^\\.AppleDouble$",
        "^\\.LSOverride$",
        "^Icon\\r$",
        "^\\._.*",
        "^\\.Spotlight-V100(?:$|\\/)",
        "\\.Trashes",
        "^__MACOSX$",
        "~$",
        "^Thumbs\\.db$",
        "^ehthumbs\\.db$",
        "^Desktop\\.ini$",
        "@eaDir$"
      ];
      exports.re = () => {
        throw new Error("`junk.re` was renamed to `junk.regex`");
      };
      exports.regex = new RegExp(blacklist.join("|"));
      exports.is = (filename) => exports.regex.test(filename);
      exports.not = (filename) => !exports.is(filename);
      exports.default = module.exports;
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/multistream/node_modules/readable-stream/errors-browser.js
  var require_errors_browser3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser3().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser3();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy3();
      var _require = require_state3();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser3().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex3();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex3();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable3();
      var Writable2 = require_stream_writable3();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser3().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream3();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser3();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list3();
      var destroyImpl = require_destroy3();
      var _require = require_state3();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser3().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex3();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex3();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator3();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser3();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser3().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex3();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform3();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/multistream/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser3().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream3();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/multistream/node_modules/readable-stream/readable-browser.js
  var require_readable_browser3 = __commonJS({
    "node_modules/multistream/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable3();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable3();
      exports.Duplex = require_stream_duplex3();
      exports.Transform = require_stream_transform3();
      exports.PassThrough = require_stream_passthrough3();
      exports.finished = require_end_of_stream3();
      exports.pipeline = require_pipeline3();
    }
  });

  // node_modules/wrappy/wrappy.js
  var require_wrappy = __commonJS({
    "node_modules/wrappy/wrappy.js"(exports, module) {
      init_esbuild_inject();
      module.exports = wrappy;
      function wrappy(fn, cb) {
        if (fn && cb)
          return wrappy(fn)(cb);
        if (typeof fn !== "function")
          throw new TypeError("need wrapper function");
        Object.keys(fn).forEach(function(k) {
          wrapper[k] = fn[k];
        });
        return wrapper;
        function wrapper() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          var ret = fn.apply(this, args);
          var cb2 = args[args.length - 1];
          if (typeof ret === "function" && ret !== cb2) {
            Object.keys(cb2).forEach(function(k) {
              ret[k] = cb2[k];
            });
          }
          return ret;
        }
      }
    }
  });

  // node_modules/once/once.js
  var require_once = __commonJS({
    "node_modules/once/once.js"(exports, module) {
      init_esbuild_inject();
      var wrappy = require_wrappy();
      module.exports = wrappy(once3);
      module.exports.strict = wrappy(onceStrict);
      once3.proto = once3(function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return once3(this);
          },
          configurable: true
        });
        Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return onceStrict(this);
          },
          configurable: true
        });
      });
      function once3(fn) {
        var f = function() {
          if (f.called)
            return f.value;
          f.called = true;
          return f.value = fn.apply(this, arguments);
        };
        f.called = false;
        return f;
      }
      function onceStrict(fn) {
        var f = function() {
          if (f.called)
            throw new Error(f.onceError);
          f.called = true;
          return f.value = fn.apply(this, arguments);
        };
        var name = fn.name || "Function wrapped with `once`";
        f.onceError = name + " shouldn't be called more than once";
        f.called = false;
        return f;
      }
    }
  });

  // node_modules/multistream/index.js
  var require_multistream = __commonJS({
    "node_modules/multistream/index.js"(exports, module) {
      init_esbuild_inject();
      var stream = require_readable_browser3();
      var once3 = require_once();
      function toStreams2Obj(s) {
        return toStreams2(s, { objectMode: true, highWaterMark: 16 });
      }
      function toStreams2Buf(s) {
        return toStreams2(s);
      }
      function toStreams2(s, opts) {
        if (!s || typeof s === "function" || s._readableState)
          return s;
        const wrap = new stream.Readable(opts).wrap(s);
        if (s.destroy) {
          wrap.destroy = s.destroy.bind(s);
        }
        return wrap;
      }
      var MultiStream = class extends stream.Readable {
        constructor(streams, opts) {
          super({ ...opts, autoDestroy: true });
          this._drained = false;
          this._forwarding = false;
          this._current = null;
          this._toStreams2 = opts && opts.objectMode ? toStreams2Obj : toStreams2Buf;
          if (typeof streams === "function") {
            this._queue = streams;
          } else {
            this._queue = streams.map(this._toStreams2);
            this._queue.forEach((stream2) => {
              if (typeof stream2 !== "function")
                this._attachErrorListener(stream2);
            });
          }
          this._next();
        }
        _read() {
          this._drained = true;
          this._forward();
        }
        _forward() {
          if (this._forwarding || !this._drained || !this._current)
            return;
          this._forwarding = true;
          let chunk;
          while (this._drained && (chunk = this._current.read()) !== null) {
            this._drained = this.push(chunk);
          }
          this._forwarding = false;
        }
        _destroy(err, cb) {
          let streams = [];
          if (this._current)
            streams.push(this._current);
          if (typeof this._queue !== "function")
            streams = streams.concat(this._queue);
          if (streams.length === 0) {
            cb(err);
          } else {
            let counter = streams.length;
            let er = err;
            streams.forEach((stream2) => {
              destroy(stream2, err, (err2) => {
                er = er || err2;
                if (--counter === 0) {
                  cb(er);
                }
              });
            });
          }
        }
        _next() {
          this._current = null;
          if (typeof this._queue === "function") {
            this._queue((err, stream2) => {
              if (err)
                return this.destroy(err);
              stream2 = this._toStreams2(stream2);
              this._attachErrorListener(stream2);
              this._gotNextStream(stream2);
            });
          } else {
            let stream2 = this._queue.shift();
            if (typeof stream2 === "function") {
              stream2 = this._toStreams2(stream2());
              this._attachErrorListener(stream2);
            }
            this._gotNextStream(stream2);
          }
        }
        _gotNextStream(stream2) {
          if (!stream2) {
            this.push(null);
            return;
          }
          this._current = stream2;
          this._forward();
          const onReadable = () => {
            this._forward();
          };
          const onClose = () => {
            if (!stream2._readableState.ended && !stream2.destroyed) {
              const err = new Error("ERR_STREAM_PREMATURE_CLOSE");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              this.destroy(err);
            }
          };
          const onEnd = () => {
            this._current = null;
            stream2.removeListener("readable", onReadable);
            stream2.removeListener("end", onEnd);
            stream2.removeListener("close", onClose);
            stream2.destroy();
            this._next();
          };
          stream2.on("readable", onReadable);
          stream2.once("end", onEnd);
          stream2.once("close", onClose);
        }
        _attachErrorListener(stream2) {
          if (!stream2)
            return;
          const onError = (err) => {
            stream2.removeListener("error", onError);
            this.destroy(err);
          };
          stream2.once("error", onError);
        }
      };
      MultiStream.obj = (streams) => new MultiStream(streams, { objectMode: true, highWaterMark: 16 });
      module.exports = MultiStream;
      function destroy(stream2, err, cb) {
        if (!stream2.destroy || stream2.destroyed) {
          cb(err);
        } else {
          const callback = once3((er) => cb(er || err));
          stream2.on("error", callback).on("close", () => callback()).destroy(err, callback);
        }
      }
    }
  });

  // node_modules/queue-microtask/index.js
  var require_queue_microtask = __commonJS({
    "node_modules/queue-microtask/index.js"(exports, module) {
      init_esbuild_inject();
      var promise;
      module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0));
    }
  });

  // node_modules/run-parallel/index.js
  var require_run_parallel = __commonJS({
    "node_modules/run-parallel/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = runParallel;
      var queueMicrotask2 = require_queue_microtask();
      function runParallel(tasks, cb) {
        let results, pending, keys2;
        let isSync = true;
        if (Array.isArray(tasks)) {
          results = [];
          pending = tasks.length;
        } else {
          keys2 = Object.keys(tasks);
          results = {};
          pending = keys2.length;
        }
        function done2(err) {
          function end() {
            if (cb)
              cb(err, results);
            cb = null;
          }
          if (isSync)
            queueMicrotask2(end);
          else
            end();
        }
        function each(i, err, result) {
          results[i] = result;
          if (--pending === 0 || err) {
            done2(err);
          }
        }
        if (!pending) {
          done2(null);
        } else if (keys2) {
          keys2.forEach(function(key) {
            tasks[key](function(err, result) {
              each(key, err, result);
            });
          });
        } else {
          tasks.forEach(function(task, i) {
            task(function(err, result) {
              each(i, err, result);
            });
          });
        }
        isSync = false;
      }
    }
  });

  // node_modules/rusha/dist/rusha.js
  var require_rusha = __commonJS({
    "node_modules/rusha/dist/rusha.js"(exports, module) {
      init_esbuild_inject();
      (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["Rusha"] = factory();
        else
          root["Rusha"] = factory();
      })(typeof self !== "undefined" ? self : exports, function() {
        return function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              i: moduleId,
              l: false,
              exports: {}
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                configurable: false,
                enumerable: true,
                get: getter
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? function getDefault() {
              return module2["default"];
            } : function getModuleExports() {
              return module2;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 3);
        }([
          function(module2, exports2, __webpack_require__) {
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var RushaCore = __webpack_require__(5);
            var _require = __webpack_require__(1), toHex2 = _require.toHex, ceilHeapSize = _require.ceilHeapSize;
            var conv = __webpack_require__(6);
            var padlen = function(len) {
              for (len += 9; len % 64 > 0; len += 1) {
              }
              return len;
            };
            var padZeroes = function(bin, len) {
              var h8 = new Uint8Array(bin.buffer);
              var om = len % 4, align = len - om;
              switch (om) {
                case 0:
                  h8[align + 3] = 0;
                case 1:
                  h8[align + 2] = 0;
                case 2:
                  h8[align + 1] = 0;
                case 3:
                  h8[align + 0] = 0;
              }
              for (var i = (len >> 2) + 1; i < bin.length; i++) {
                bin[i] = 0;
              }
            };
            var padData = function(bin, chunkLen, msgLen) {
              bin[chunkLen >> 2] |= 128 << 24 - (chunkLen % 4 << 3);
              bin[((chunkLen >> 2) + 2 & ~15) + 14] = msgLen / (1 << 29) | 0;
              bin[((chunkLen >> 2) + 2 & ~15) + 15] = msgLen << 3;
            };
            var getRawDigest = function(heap, padMaxChunkLen) {
              var io = new Int32Array(heap, padMaxChunkLen + 320, 5);
              var out = new Int32Array(5);
              var arr = new DataView(out.buffer);
              arr.setInt32(0, io[0], false);
              arr.setInt32(4, io[1], false);
              arr.setInt32(8, io[2], false);
              arr.setInt32(12, io[3], false);
              arr.setInt32(16, io[4], false);
              return out;
            };
            var Rusha = function() {
              function Rusha2(chunkSize) {
                _classCallCheck(this, Rusha2);
                chunkSize = chunkSize || 64 * 1024;
                if (chunkSize % 64 > 0) {
                  throw new Error("Chunk size must be a multiple of 128 bit");
                }
                this._offset = 0;
                this._maxChunkLen = chunkSize;
                this._padMaxChunkLen = padlen(chunkSize);
                this._heap = new ArrayBuffer(ceilHeapSize(this._padMaxChunkLen + 320 + 20));
                this._h32 = new Int32Array(this._heap);
                this._h8 = new Int8Array(this._heap);
                this._core = new RushaCore({ Int32Array }, {}, this._heap);
              }
              Rusha2.prototype._initState = function _initState(heap, padMsgLen) {
                this._offset = 0;
                var io = new Int32Array(heap, padMsgLen + 320, 5);
                io[0] = 1732584193;
                io[1] = -271733879;
                io[2] = -1732584194;
                io[3] = 271733878;
                io[4] = -1009589776;
              };
              Rusha2.prototype._padChunk = function _padChunk(chunkLen, msgLen) {
                var padChunkLen = padlen(chunkLen);
                var view = new Int32Array(this._heap, 0, padChunkLen >> 2);
                padZeroes(view, chunkLen);
                padData(view, chunkLen, msgLen);
                return padChunkLen;
              };
              Rusha2.prototype._write = function _write(data, chunkOffset, chunkLen, off2) {
                conv(data, this._h8, this._h32, chunkOffset, chunkLen, off2 || 0);
              };
              Rusha2.prototype._coreCall = function _coreCall(data, chunkOffset, chunkLen, msgLen, finalize) {
                var padChunkLen = chunkLen;
                this._write(data, chunkOffset, chunkLen);
                if (finalize) {
                  padChunkLen = this._padChunk(chunkLen, msgLen);
                }
                this._core.hash(padChunkLen, this._padMaxChunkLen);
              };
              Rusha2.prototype.rawDigest = function rawDigest(str) {
                var msgLen = str.byteLength || str.length || str.size || 0;
                this._initState(this._heap, this._padMaxChunkLen);
                var chunkOffset = 0, chunkLen = this._maxChunkLen;
                for (chunkOffset = 0; msgLen > chunkOffset + chunkLen; chunkOffset += chunkLen) {
                  this._coreCall(str, chunkOffset, chunkLen, msgLen, false);
                }
                this._coreCall(str, chunkOffset, msgLen - chunkOffset, msgLen, true);
                return getRawDigest(this._heap, this._padMaxChunkLen);
              };
              Rusha2.prototype.digest = function digest(str) {
                return toHex2(this.rawDigest(str).buffer);
              };
              Rusha2.prototype.digestFromString = function digestFromString(str) {
                return this.digest(str);
              };
              Rusha2.prototype.digestFromBuffer = function digestFromBuffer(str) {
                return this.digest(str);
              };
              Rusha2.prototype.digestFromArrayBuffer = function digestFromArrayBuffer(str) {
                return this.digest(str);
              };
              Rusha2.prototype.resetState = function resetState() {
                this._initState(this._heap, this._padMaxChunkLen);
                return this;
              };
              Rusha2.prototype.append = function append(chunk) {
                var chunkOffset = 0;
                var chunkLen = chunk.byteLength || chunk.length || chunk.size || 0;
                var turnOffset = this._offset % this._maxChunkLen;
                var inputLen = void 0;
                this._offset += chunkLen;
                while (chunkOffset < chunkLen) {
                  inputLen = Math.min(chunkLen - chunkOffset, this._maxChunkLen - turnOffset);
                  this._write(chunk, chunkOffset, inputLen, turnOffset);
                  turnOffset += inputLen;
                  chunkOffset += inputLen;
                  if (turnOffset === this._maxChunkLen) {
                    this._core.hash(this._maxChunkLen, this._padMaxChunkLen);
                    turnOffset = 0;
                  }
                }
                return this;
              };
              Rusha2.prototype.getState = function getState() {
                var turnOffset = this._offset % this._maxChunkLen;
                var heap = void 0;
                if (!turnOffset) {
                  var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                  heap = io.buffer.slice(io.byteOffset, io.byteOffset + io.byteLength);
                } else {
                  heap = this._heap.slice(0);
                }
                return {
                  offset: this._offset,
                  heap
                };
              };
              Rusha2.prototype.setState = function setState(state) {
                this._offset = state.offset;
                if (state.heap.byteLength === 20) {
                  var io = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                  io.set(new Int32Array(state.heap));
                } else {
                  this._h32.set(new Int32Array(state.heap));
                }
                return this;
              };
              Rusha2.prototype.rawEnd = function rawEnd() {
                var msgLen = this._offset;
                var chunkLen = msgLen % this._maxChunkLen;
                var padChunkLen = this._padChunk(chunkLen, msgLen);
                this._core.hash(padChunkLen, this._padMaxChunkLen);
                var result = getRawDigest(this._heap, this._padMaxChunkLen);
                this._initState(this._heap, this._padMaxChunkLen);
                return result;
              };
              Rusha2.prototype.end = function end() {
                return toHex2(this.rawEnd().buffer);
              };
              return Rusha2;
            }();
            module2.exports = Rusha;
            module2.exports._core = RushaCore;
          },
          function(module2, exports2) {
            var precomputedHex = new Array(256);
            for (var i = 0; i < 256; i++) {
              precomputedHex[i] = (i < 16 ? "0" : "") + i.toString(16);
            }
            module2.exports.toHex = function(arrayBuffer) {
              var binarray = new Uint8Array(arrayBuffer);
              var res = new Array(arrayBuffer.byteLength);
              for (var _i = 0; _i < res.length; _i++) {
                res[_i] = precomputedHex[binarray[_i]];
              }
              return res.join("");
            };
            module2.exports.ceilHeapSize = function(v) {
              var p = 0;
              if (v <= 65536)
                return 65536;
              if (v < 16777216) {
                for (p = 1; p < v; p = p << 1) {
                }
              } else {
                for (p = 16777216; p < v; p += 16777216) {
                }
              }
              return p;
            };
            module2.exports.isDedicatedWorkerScope = function(self2) {
              var isRunningInWorker = "WorkerGlobalScope" in self2 && self2 instanceof self2.WorkerGlobalScope;
              var isRunningInSharedWorker = "SharedWorkerGlobalScope" in self2 && self2 instanceof self2.SharedWorkerGlobalScope;
              var isRunningInServiceWorker = "ServiceWorkerGlobalScope" in self2 && self2 instanceof self2.ServiceWorkerGlobalScope;
              return isRunningInWorker && !isRunningInSharedWorker && !isRunningInServiceWorker;
            };
          },
          function(module2, exports2, __webpack_require__) {
            module2.exports = function() {
              var Rusha = __webpack_require__(0);
              var hashData = function(hasher, data, cb) {
                try {
                  return cb(null, hasher.digest(data));
                } catch (e) {
                  return cb(e);
                }
              };
              var hashFile = function(hasher, readTotal, blockSize, file, cb) {
                var reader = new self.FileReader();
                reader.onloadend = function onloadend() {
                  if (reader.error) {
                    return cb(reader.error);
                  }
                  var buffer = reader.result;
                  readTotal += reader.result.byteLength;
                  try {
                    hasher.append(buffer);
                  } catch (e) {
                    cb(e);
                    return;
                  }
                  if (readTotal < file.size) {
                    hashFile(hasher, readTotal, blockSize, file, cb);
                  } else {
                    cb(null, hasher.end());
                  }
                };
                reader.readAsArrayBuffer(file.slice(readTotal, readTotal + blockSize));
              };
              var workerBehaviourEnabled = true;
              self.onmessage = function(event) {
                if (!workerBehaviourEnabled) {
                  return;
                }
                var data = event.data.data, file = event.data.file, id = event.data.id;
                if (typeof id === "undefined")
                  return;
                if (!file && !data)
                  return;
                var blockSize = event.data.blockSize || 4 * 1024 * 1024;
                var hasher = new Rusha(blockSize);
                hasher.resetState();
                var done2 = function(err, hash) {
                  if (!err) {
                    self.postMessage({ id, hash });
                  } else {
                    self.postMessage({ id, error: err.name });
                  }
                };
                if (data)
                  hashData(hasher, data, done2);
                if (file)
                  hashFile(hasher, 0, blockSize, file, done2);
              };
              return function() {
                workerBehaviourEnabled = false;
              };
            };
          },
          function(module2, exports2, __webpack_require__) {
            var work = __webpack_require__(4);
            var Rusha = __webpack_require__(0);
            var createHash = __webpack_require__(7);
            var runWorker = __webpack_require__(2);
            var _require = __webpack_require__(1), isDedicatedWorkerScope = _require.isDedicatedWorkerScope;
            var isRunningInDedicatedWorker = typeof self !== "undefined" && isDedicatedWorkerScope(self);
            Rusha.disableWorkerBehaviour = isRunningInDedicatedWorker ? runWorker() : function() {
            };
            Rusha.createWorker = function() {
              var worker = work(2);
              var terminate = worker.terminate;
              worker.terminate = function() {
                URL.revokeObjectURL(worker.objectURL);
                terminate.call(worker);
              };
              return worker;
            };
            Rusha.createHash = createHash;
            module2.exports = Rusha;
          },
          function(module2, exports2, __webpack_require__) {
            function webpackBootstrapFunc(modules) {
              var installedModules = {};
              function __webpack_require__2(moduleId) {
                if (installedModules[moduleId])
                  return installedModules[moduleId].exports;
                var module3 = installedModules[moduleId] = {
                  i: moduleId,
                  l: false,
                  exports: {}
                };
                modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__2);
                module3.l = true;
                return module3.exports;
              }
              __webpack_require__2.m = modules;
              __webpack_require__2.c = installedModules;
              __webpack_require__2.i = function(value) {
                return value;
              };
              __webpack_require__2.d = function(exports3, name, getter) {
                if (!__webpack_require__2.o(exports3, name)) {
                  Object.defineProperty(exports3, name, {
                    configurable: false,
                    enumerable: true,
                    get: getter
                  });
                }
              };
              __webpack_require__2.r = function(exports3) {
                Object.defineProperty(exports3, "__esModule", { value: true });
              };
              __webpack_require__2.n = function(module3) {
                var getter = module3 && module3.__esModule ? function getDefault() {
                  return module3["default"];
                } : function getModuleExports() {
                  return module3;
                };
                __webpack_require__2.d(getter, "a", getter);
                return getter;
              };
              __webpack_require__2.o = function(object, property) {
                return Object.prototype.hasOwnProperty.call(object, property);
              };
              __webpack_require__2.p = "/";
              __webpack_require__2.oe = function(err) {
                console.error(err);
                throw err;
              };
              var f = __webpack_require__2(__webpack_require__2.s = ENTRY_MODULE);
              return f.default || f;
            }
            var moduleNameReqExp = "[\\.|\\-|\\+|\\w|/|@]+";
            var dependencyRegExp = "\\((/\\*.*?\\*/)?s?.*?(" + moduleNameReqExp + ").*?\\)";
            function quoteRegExp(str) {
              return (str + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
            }
            function getModuleDependencies(sources, module3, queueName) {
              var retval = {};
              retval[queueName] = [];
              var fnString = module3.toString();
              var wrapperSignature = fnString.match(/^function\s?\(\w+,\s*\w+,\s*(\w+)\)/);
              if (!wrapperSignature)
                return retval;
              var webpackRequireName = wrapperSignature[1];
              var re = new RegExp("(\\\\n|\\W)" + quoteRegExp(webpackRequireName) + dependencyRegExp, "g");
              var match;
              while (match = re.exec(fnString)) {
                if (match[3] === "dll-reference")
                  continue;
                retval[queueName].push(match[3]);
              }
              re = new RegExp("\\(" + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, "g");
              while (match = re.exec(fnString)) {
                if (!sources[match[2]]) {
                  retval[queueName].push(match[1]);
                  sources[match[2]] = __webpack_require__(match[1]).m;
                }
                retval[match[2]] = retval[match[2]] || [];
                retval[match[2]].push(match[4]);
              }
              return retval;
            }
            function hasValuesInQueues(queues) {
              var keys2 = Object.keys(queues);
              return keys2.reduce(function(hasValues, key) {
                return hasValues || queues[key].length > 0;
              }, false);
            }
            function getRequiredModules(sources, moduleId) {
              var modulesQueue = {
                main: [moduleId]
              };
              var requiredModules = {
                main: []
              };
              var seenModules = {
                main: {}
              };
              while (hasValuesInQueues(modulesQueue)) {
                var queues = Object.keys(modulesQueue);
                for (var i = 0; i < queues.length; i++) {
                  var queueName = queues[i];
                  var queue2 = modulesQueue[queueName];
                  var moduleToCheck = queue2.pop();
                  seenModules[queueName] = seenModules[queueName] || {};
                  if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck])
                    continue;
                  seenModules[queueName][moduleToCheck] = true;
                  requiredModules[queueName] = requiredModules[queueName] || [];
                  requiredModules[queueName].push(moduleToCheck);
                  var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName);
                  var newModulesKeys = Object.keys(newModules);
                  for (var j = 0; j < newModulesKeys.length; j++) {
                    modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                    modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
                  }
                }
              }
              return requiredModules;
            }
            module2.exports = function(moduleId, options) {
              options = options || {};
              var sources = {
                main: __webpack_require__.m
              };
              var requiredModules = options.all ? { main: Object.keys(sources) } : getRequiredModules(sources, moduleId);
              var src = "";
              Object.keys(requiredModules).filter(function(m) {
                return m !== "main";
              }).forEach(function(module3) {
                var entryModule = 0;
                while (requiredModules[module3][entryModule]) {
                  entryModule++;
                }
                requiredModules[module3].push(entryModule);
                sources[module3][entryModule] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })";
                src = src + "var " + module3 + " = (" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(entryModule)) + ")({" + requiredModules[module3].map(function(id) {
                  return "" + JSON.stringify(id) + ": " + sources[module3][id].toString();
                }).join(",") + "});\n";
              });
              src = src + "(" + webpackBootstrapFunc.toString().replace("ENTRY_MODULE", JSON.stringify(moduleId)) + ")({" + requiredModules.main.map(function(id) {
                return "" + JSON.stringify(id) + ": " + sources.main[id].toString();
              }).join(",") + "})(self);";
              var blob = new window.Blob([src], { type: "text/javascript" });
              if (options.bare) {
                return blob;
              }
              var URL2 = window.URL || window.webkitURL || window.mozURL || window.msURL;
              var workerUrl = URL2.createObjectURL(blob);
              var worker = new window.Worker(workerUrl);
              worker.objectURL = workerUrl;
              return worker;
            };
          },
          function(module2, exports2) {
            module2.exports = function RushaCore(stdlib$840, foreign$841, heap$842) {
              ;
              var H$843 = new stdlib$840.Int32Array(heap$842);
              function hash$844(k$845, x$846) {
                k$845 = k$845 | 0;
                x$846 = x$846 | 0;
                var i$847 = 0, j$848 = 0, y0$849 = 0, z0$850 = 0, y1$851 = 0, z1$852 = 0, y2$853 = 0, z2$854 = 0, y3$855 = 0, z3$856 = 0, y4$857 = 0, z4$858 = 0, t0$859 = 0, t1$860 = 0;
                y0$849 = H$843[x$846 + 320 >> 2] | 0;
                y1$851 = H$843[x$846 + 324 >> 2] | 0;
                y2$853 = H$843[x$846 + 328 >> 2] | 0;
                y3$855 = H$843[x$846 + 332 >> 2] | 0;
                y4$857 = H$843[x$846 + 336 >> 2] | 0;
                for (i$847 = 0; (i$847 | 0) < (k$845 | 0); i$847 = i$847 + 64 | 0) {
                  z0$850 = y0$849;
                  z1$852 = y1$851;
                  z2$854 = y2$853;
                  z3$856 = y3$855;
                  z4$858 = y4$857;
                  for (j$848 = 0; (j$848 | 0) < 64; j$848 = j$848 + 4 | 0) {
                    t1$860 = H$843[i$847 + j$848 >> 2] | 0;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[k$845 + j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 64 | 0; (j$848 | 0) < (k$845 + 80 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | ~y1$851 & y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1518500249 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 80 | 0; (j$848 | 0) < (k$845 + 160 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) + 1859775393 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 160 | 0; (j$848 | 0) < (k$845 + 240 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 & y2$853 | y1$851 & y3$855 | y2$853 & y3$855) | 0) + ((t1$860 + y4$857 | 0) - 1894007588 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  for (j$848 = k$845 + 240 | 0; (j$848 | 0) < (k$845 + 320 | 0); j$848 = j$848 + 4 | 0) {
                    t1$860 = (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) << 1 | (H$843[j$848 - 12 >> 2] ^ H$843[j$848 - 32 >> 2] ^ H$843[j$848 - 56 >> 2] ^ H$843[j$848 - 64 >> 2]) >>> 31;
                    t0$859 = ((y0$849 << 5 | y0$849 >>> 27) + (y1$851 ^ y2$853 ^ y3$855) | 0) + ((t1$860 + y4$857 | 0) - 899497514 | 0) | 0;
                    y4$857 = y3$855;
                    y3$855 = y2$853;
                    y2$853 = y1$851 << 30 | y1$851 >>> 2;
                    y1$851 = y0$849;
                    y0$849 = t0$859;
                    H$843[j$848 >> 2] = t1$860;
                  }
                  y0$849 = y0$849 + z0$850 | 0;
                  y1$851 = y1$851 + z1$852 | 0;
                  y2$853 = y2$853 + z2$854 | 0;
                  y3$855 = y3$855 + z3$856 | 0;
                  y4$857 = y4$857 + z4$858 | 0;
                }
                H$843[x$846 + 320 >> 2] = y0$849;
                H$843[x$846 + 324 >> 2] = y1$851;
                H$843[x$846 + 328 >> 2] = y2$853;
                H$843[x$846 + 332 >> 2] = y3$855;
                H$843[x$846 + 336 >> 2] = y4$857;
              }
              return { hash: hash$844 };
            };
          },
          function(module2, exports2) {
            var _this = this;
            var reader = void 0;
            if (typeof self !== "undefined" && typeof self.FileReaderSync !== "undefined") {
              reader = new self.FileReaderSync();
            }
            var convStr = function(str, H8, H32, start, len, off2) {
              var i = void 0, om = off2 % 4, lm = (len + om) % 4, j = len - lm;
              switch (om) {
                case 0:
                  H8[off2] = str.charCodeAt(start + 3);
                case 1:
                  H8[off2 + 1 - (om << 1) | 0] = str.charCodeAt(start + 2);
                case 2:
                  H8[off2 + 2 - (om << 1) | 0] = str.charCodeAt(start + 1);
                case 3:
                  H8[off2 + 3 - (om << 1) | 0] = str.charCodeAt(start);
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i = 4 - om; i < j; i = i + 4 | 0) {
                H32[off2 + i >> 2] = str.charCodeAt(start + i) << 24 | str.charCodeAt(start + i + 1) << 16 | str.charCodeAt(start + i + 2) << 8 | str.charCodeAt(start + i + 3);
              }
              switch (lm) {
                case 3:
                  H8[off2 + j + 1 | 0] = str.charCodeAt(start + j + 2);
                case 2:
                  H8[off2 + j + 2 | 0] = str.charCodeAt(start + j + 1);
                case 1:
                  H8[off2 + j + 3 | 0] = str.charCodeAt(start + j);
              }
            };
            var convBuf = function(buf, H8, H32, start, len, off2) {
              var i = void 0, om = off2 % 4, lm = (len + om) % 4, j = len - lm;
              switch (om) {
                case 0:
                  H8[off2] = buf[start + 3];
                case 1:
                  H8[off2 + 1 - (om << 1) | 0] = buf[start + 2];
                case 2:
                  H8[off2 + 2 - (om << 1) | 0] = buf[start + 1];
                case 3:
                  H8[off2 + 3 - (om << 1) | 0] = buf[start];
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i = 4 - om; i < j; i = i + 4 | 0) {
                H32[off2 + i >> 2 | 0] = buf[start + i] << 24 | buf[start + i + 1] << 16 | buf[start + i + 2] << 8 | buf[start + i + 3];
              }
              switch (lm) {
                case 3:
                  H8[off2 + j + 1 | 0] = buf[start + j + 2];
                case 2:
                  H8[off2 + j + 2 | 0] = buf[start + j + 1];
                case 1:
                  H8[off2 + j + 3 | 0] = buf[start + j];
              }
            };
            var convBlob = function(blob, H8, H32, start, len, off2) {
              var i = void 0, om = off2 % 4, lm = (len + om) % 4, j = len - lm;
              var buf = new Uint8Array(reader.readAsArrayBuffer(blob.slice(start, start + len)));
              switch (om) {
                case 0:
                  H8[off2] = buf[3];
                case 1:
                  H8[off2 + 1 - (om << 1) | 0] = buf[2];
                case 2:
                  H8[off2 + 2 - (om << 1) | 0] = buf[1];
                case 3:
                  H8[off2 + 3 - (om << 1) | 0] = buf[0];
              }
              if (len < lm + (4 - om)) {
                return;
              }
              for (i = 4 - om; i < j; i = i + 4 | 0) {
                H32[off2 + i >> 2 | 0] = buf[i] << 24 | buf[i + 1] << 16 | buf[i + 2] << 8 | buf[i + 3];
              }
              switch (lm) {
                case 3:
                  H8[off2 + j + 1 | 0] = buf[j + 2];
                case 2:
                  H8[off2 + j + 2 | 0] = buf[j + 1];
                case 1:
                  H8[off2 + j + 3 | 0] = buf[j];
              }
            };
            module2.exports = function(data, H8, H32, start, len, off2) {
              if (typeof data === "string") {
                return convStr(data, H8, H32, start, len, off2);
              }
              if (data instanceof Array) {
                return convBuf(data, H8, H32, start, len, off2);
              }
              if (_this && _this.Buffer && _this.Buffer.isBuffer(data)) {
                return convBuf(data, H8, H32, start, len, off2);
              }
              if (data instanceof ArrayBuffer) {
                return convBuf(new Uint8Array(data), H8, H32, start, len, off2);
              }
              if (data.buffer instanceof ArrayBuffer) {
                return convBuf(new Uint8Array(data.buffer, data.byteOffset, data.byteLength), H8, H32, start, len, off2);
              }
              if (data instanceof Blob) {
                return convBlob(data, H8, H32, start, len, off2);
              }
              throw new Error("Unsupported data type.");
            };
          },
          function(module2, exports2, __webpack_require__) {
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Rusha = __webpack_require__(0);
            var _require = __webpack_require__(1), toHex2 = _require.toHex;
            var Hash = function() {
              function Hash2() {
                _classCallCheck(this, Hash2);
                this._rusha = new Rusha();
                this._rusha.resetState();
              }
              Hash2.prototype.update = function update(data) {
                this._rusha.append(data);
                return this;
              };
              Hash2.prototype.digest = function digest(encoding) {
                var digest2 = this._rusha.rawEnd().buffer;
                if (!encoding) {
                  return digest2;
                }
                if (encoding === "hex") {
                  return toHex2(digest2);
                }
                throw new Error("unsupported digest encoding");
              };
              _createClass(Hash2, [{
                key: "state",
                get: function() {
                  return this._rusha.getState();
                },
                set: function(state) {
                  this._rusha.setState(state);
                }
              }]);
              return Hash2;
            }();
            module2.exports = function() {
              return new Hash();
            };
          }
        ]);
      });
    }
  });

  // node_modules/simple-sha1/rusha-worker-sha1.js
  var require_rusha_worker_sha1 = __commonJS({
    "node_modules/simple-sha1/rusha-worker-sha1.js"(exports, module) {
      init_esbuild_inject();
      var Rusha = require_rusha();
      var worker;
      var nextTaskId;
      var cbs;
      function init2() {
        worker = Rusha.createWorker();
        nextTaskId = 1;
        cbs = {};
        worker.onmessage = function onRushaMessage(e) {
          const taskId = e.data.id;
          const cb = cbs[taskId];
          delete cbs[taskId];
          if (e.data.error != null) {
            cb(new Error("Rusha worker error: " + e.data.error));
          } else {
            cb(null, e.data.hash);
          }
        };
      }
      function sha1(buf, cb) {
        if (!worker)
          init2();
        cbs[nextTaskId] = cb;
        worker.postMessage({ id: nextTaskId, data: buf });
        nextTaskId += 1;
      }
      module.exports = sha1;
    }
  });

  // node_modules/simple-sha1/browser.js
  var require_browser4 = __commonJS({
    "node_modules/simple-sha1/browser.js"(exports, module) {
      init_esbuild_inject();
      var Rusha = require_rusha();
      var rushaWorkerSha1 = require_rusha_worker_sha1();
      var rusha = new Rusha();
      var scope = typeof window !== "undefined" ? window : self;
      var crypto = scope.crypto || scope.msCrypto || {};
      var subtle = crypto.subtle || crypto.webkitSubtle;
      function sha1sync(buf) {
        return rusha.digest(buf);
      }
      try {
        subtle.digest({ name: "sha-1" }, new Uint8Array()).catch(function() {
          subtle = false;
        });
      } catch (err) {
        subtle = false;
      }
      function sha1(buf, cb) {
        if (!subtle) {
          if (typeof window !== "undefined") {
            rushaWorkerSha1(buf, function onRushaWorkerSha1(err, hash) {
              if (err) {
                cb(sha1sync(buf));
                return;
              }
              cb(hash);
            });
          } else {
            queueMicrotask(() => cb(sha1sync(buf)));
          }
          return;
        }
        if (typeof buf === "string") {
          buf = uint8array(buf);
        }
        subtle.digest({ name: "sha-1" }, buf).then(function succeed(result) {
          cb(hex(new Uint8Array(result)));
        }, function fail() {
          cb(sha1sync(buf));
        });
      }
      function uint8array(s) {
        const l = s.length;
        const array = new Uint8Array(l);
        for (let i = 0; i < l; i++) {
          array[i] = s.charCodeAt(i);
        }
        return array;
      }
      function hex(buf) {
        const l = buf.length;
        const chars = [];
        for (let i = 0; i < l; i++) {
          const bite = buf[i];
          chars.push((bite >>> 4).toString(16));
          chars.push((bite & 15).toString(16));
        }
        return chars.join("");
      }
      module.exports = sha1;
      module.exports.sync = sha1sync;
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/errors-browser.js
  var require_errors_browser4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser4().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser4();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy4();
      var _require = require_state4();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser4().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex4();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex4();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable4();
      var Writable2 = require_stream_writable4();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser4().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream4();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser4();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list4();
      var destroyImpl = require_destroy4();
      var _require = require_state4();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser4().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex4();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex4();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator4();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser4();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser4().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex4();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform4();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser4().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream4();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/create-torrent/node_modules/readable-stream/readable-browser.js
  var require_readable_browser4 = __commonJS({
    "node_modules/create-torrent/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable4();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable4();
      exports.Duplex = require_stream_duplex4();
      exports.Transform = require_stream_transform4();
      exports.PassThrough = require_stream_passthrough4();
      exports.finished = require_end_of_stream4();
      exports.pipeline = require_pipeline4();
    }
  });

  // (disabled):node_modules/create-torrent/get-files
  var require_get_files = __commonJS({
    "(disabled):node_modules/create-torrent/get-files"() {
      init_esbuild_inject();
    }
  });

  // node_modules/create-torrent/index.js
  var require_create_torrent = __commonJS({
    "node_modules/create-torrent/index.js"(exports, module) {
      init_esbuild_inject();
      var bencode = require_lib();
      var BlockStream = require_block_stream2();
      var calcPieceLength = require_piece_length();
      var corePath = require_path();
      var FileReadStream = require_read();
      var isFile = require_is_file();
      var junk = require_junk();
      var MultiStream = require_multistream();
      var once3 = require_once();
      var parallel = require_run_parallel();
      var queueMicrotask2 = require_queue_microtask();
      var sha1 = require_browser4();
      var stream = require_readable_browser4();
      var getFiles = require_get_files();
      var announceList = [
        ["udp://tracker.leechers-paradise.org:6969"],
        ["udp://tracker.coppersurfer.tk:6969"],
        ["udp://tracker.opentrackr.org:1337"],
        ["udp://explodie.org:6969"],
        ["udp://tracker.empire-js.us:1337"],
        ["wss://tracker.btorrent.xyz"],
        ["wss://tracker.openwebtorrent.com"]
      ];
      function createTorrent(input, opts, cb) {
        if (typeof opts === "function")
          [opts, cb] = [cb, opts];
        opts = opts ? Object.assign({}, opts) : {};
        _parseInput(input, opts, (err, files, singleFileTorrent) => {
          if (err)
            return cb(err);
          opts.singleFileTorrent = singleFileTorrent;
          onFiles(files, opts, cb);
        });
      }
      function parseInput(input, opts, cb) {
        if (typeof opts === "function")
          [opts, cb] = [cb, opts];
        opts = opts ? Object.assign({}, opts) : {};
        _parseInput(input, opts, cb);
      }
      function _parseInput(input, opts, cb) {
        if (isFileList(input))
          input = Array.from(input);
        if (!Array.isArray(input))
          input = [input];
        if (input.length === 0)
          throw new Error("invalid input type");
        input.forEach((item) => {
          if (item == null)
            throw new Error(`invalid input type: ${item}`);
        });
        input = input.map((item) => {
          if (isBlob(item) && typeof item.path === "string" && typeof getFiles === "function")
            return item.path;
          return item;
        });
        if (input.length === 1 && typeof input[0] !== "string" && !input[0].name)
          input[0].name = opts.name;
        let commonPrefix = null;
        input.forEach((item, i) => {
          if (typeof item === "string") {
            return;
          }
          let path = item.fullPath || item.name;
          if (!path) {
            path = `Unknown File ${i + 1}`;
            item.unknownName = true;
          }
          item.path = path.split("/");
          if (!item.path[0]) {
            item.path.shift();
          }
          if (item.path.length < 2) {
            commonPrefix = null;
          } else if (i === 0 && input.length > 1) {
            commonPrefix = item.path[0];
          } else if (item.path[0] !== commonPrefix) {
            commonPrefix = null;
          }
        });
        const filterJunkFiles = opts.filterJunkFiles === void 0 ? true : opts.filterJunkFiles;
        if (filterJunkFiles) {
          input = input.filter((item) => {
            if (typeof item === "string") {
              return true;
            }
            return !isJunkPath(item.path);
          });
        }
        if (commonPrefix) {
          input.forEach((item) => {
            const pathless = (Buffer3.isBuffer(item) || isReadable(item)) && !item.path;
            if (typeof item === "string" || pathless)
              return;
            item.path.shift();
          });
        }
        if (!opts.name && commonPrefix) {
          opts.name = commonPrefix;
        }
        if (!opts.name) {
          input.some((item) => {
            if (typeof item === "string") {
              opts.name = corePath.basename(item);
              return true;
            } else if (!item.unknownName) {
              opts.name = item.path[item.path.length - 1];
              return true;
            }
            return false;
          });
        }
        if (!opts.name) {
          opts.name = `Unnamed Torrent ${Date.now()}`;
        }
        const numPaths = input.reduce((sum, item) => sum + Number(typeof item === "string"), 0);
        let isSingleFileTorrent = input.length === 1;
        if (input.length === 1 && typeof input[0] === "string") {
          if (typeof getFiles !== "function") {
            throw new Error("filesystem paths do not work in the browser");
          }
          isFile(input[0], (err, pathIsFile) => {
            if (err)
              return cb(err);
            isSingleFileTorrent = pathIsFile;
            processInput();
          });
        } else {
          queueMicrotask2(processInput);
        }
        function processInput() {
          parallel(input.map((item) => (cb2) => {
            const file = {};
            if (isBlob(item)) {
              file.getStream = getBlobStream(item);
              file.length = item.size;
            } else if (Buffer3.isBuffer(item)) {
              file.getStream = getBufferStream(item);
              file.length = item.length;
            } else if (isReadable(item)) {
              file.getStream = getStreamStream(item, file);
              file.length = 0;
            } else if (typeof item === "string") {
              if (typeof getFiles !== "function") {
                throw new Error("filesystem paths do not work in the browser");
              }
              const keepRoot = numPaths > 1 || isSingleFileTorrent;
              getFiles(item, keepRoot, cb2);
              return;
            } else {
              throw new Error("invalid input type");
            }
            file.path = item.path;
            cb2(null, file);
          }), (err, files) => {
            if (err)
              return cb(err);
            files = files.flat();
            cb(null, files, isSingleFileTorrent);
          });
        }
      }
      var MAX_OUTSTANDING_HASHES = 5;
      function getPieceList(files, pieceLength, estimatedTorrentLength, opts, cb) {
        cb = once3(cb);
        const pieces = [];
        let length = 0;
        let hashedLength = 0;
        const streams = files.map((file) => file.getStream);
        let remainingHashes = 0;
        let pieceNum = 0;
        let ended = false;
        const multistream = new MultiStream(streams);
        const blockstream = new BlockStream(pieceLength, { zeroPadding: false });
        multistream.on("error", onError);
        multistream.pipe(blockstream).on("data", onData).on("end", onEnd).on("error", onError);
        function onData(chunk) {
          length += chunk.length;
          const i = pieceNum;
          sha1(chunk, (hash) => {
            pieces[i] = hash;
            remainingHashes -= 1;
            if (remainingHashes < MAX_OUTSTANDING_HASHES) {
              blockstream.resume();
            }
            hashedLength += chunk.length;
            if (opts.onProgress)
              opts.onProgress(hashedLength, estimatedTorrentLength);
            maybeDone();
          });
          remainingHashes += 1;
          if (remainingHashes >= MAX_OUTSTANDING_HASHES) {
            blockstream.pause();
          }
          pieceNum += 1;
        }
        function onEnd() {
          ended = true;
          maybeDone();
        }
        function onError(err) {
          cleanup();
          cb(err);
        }
        function cleanup() {
          multistream.removeListener("error", onError);
          blockstream.removeListener("data", onData);
          blockstream.removeListener("end", onEnd);
          blockstream.removeListener("error", onError);
        }
        function maybeDone() {
          if (ended && remainingHashes === 0) {
            cleanup();
            cb(null, Buffer3.from(pieces.join(""), "hex"), length);
          }
        }
      }
      function onFiles(files, opts, cb) {
        let announceList2 = opts.announceList;
        if (!announceList2) {
          if (typeof opts.announce === "string")
            announceList2 = [[opts.announce]];
          else if (Array.isArray(opts.announce)) {
            announceList2 = opts.announce.map((u) => [u]);
          }
        }
        if (!announceList2)
          announceList2 = [];
        if (globalThis.WEBTORRENT_ANNOUNCE) {
          if (typeof globalThis.WEBTORRENT_ANNOUNCE === "string") {
            announceList2.push([[globalThis.WEBTORRENT_ANNOUNCE]]);
          } else if (Array.isArray(globalThis.WEBTORRENT_ANNOUNCE)) {
            announceList2 = announceList2.concat(globalThis.WEBTORRENT_ANNOUNCE.map((u) => [u]));
          }
        }
        if (opts.announce === void 0 && opts.announceList === void 0) {
          announceList2 = announceList2.concat(module.exports.announceList);
        }
        if (typeof opts.urlList === "string")
          opts.urlList = [opts.urlList];
        const torrent = {
          info: {
            name: opts.name
          },
          "creation date": Math.ceil((Number(opts.creationDate) || Date.now()) / 1e3),
          encoding: "UTF-8"
        };
        if (announceList2.length !== 0) {
          torrent.announce = announceList2[0][0];
          torrent["announce-list"] = announceList2;
        }
        if (opts.comment !== void 0)
          torrent.comment = opts.comment;
        if (opts.createdBy !== void 0)
          torrent["created by"] = opts.createdBy;
        if (opts.private !== void 0)
          torrent.info.private = Number(opts.private);
        if (opts.info !== void 0)
          Object.assign(torrent.info, opts.info);
        if (opts.sslCert !== void 0)
          torrent.info["ssl-cert"] = opts.sslCert;
        if (opts.urlList !== void 0)
          torrent["url-list"] = opts.urlList;
        const estimatedTorrentLength = files.reduce(sumLength, 0);
        const pieceLength = opts.pieceLength || calcPieceLength(estimatedTorrentLength);
        torrent.info["piece length"] = pieceLength;
        getPieceList(files, pieceLength, estimatedTorrentLength, opts, (err, pieces, torrentLength) => {
          if (err)
            return cb(err);
          torrent.info.pieces = pieces;
          files.forEach((file) => {
            delete file.getStream;
          });
          if (opts.singleFileTorrent) {
            torrent.info.length = torrentLength;
          } else {
            torrent.info.files = files;
          }
          cb(null, bencode.encode(torrent));
        });
      }
      function isJunkPath(path) {
        const filename = path[path.length - 1];
        return filename[0] === "." && junk.is(filename);
      }
      function sumLength(sum, file) {
        return sum + file.length;
      }
      function isBlob(obj) {
        return typeof Blob !== "undefined" && obj instanceof Blob;
      }
      function isFileList(obj) {
        return typeof FileList !== "undefined" && obj instanceof FileList;
      }
      function isReadable(obj) {
        return typeof obj === "object" && obj != null && typeof obj.pipe === "function";
      }
      function getBlobStream(file) {
        return () => new FileReadStream(file);
      }
      function getBufferStream(buffer) {
        return () => {
          const s = new stream.PassThrough();
          s.end(buffer);
          return s;
        };
      }
      function getStreamStream(readable, file) {
        return () => {
          const counter = new stream.Transform();
          counter._transform = function(buf, enc, done2) {
            file.length += buf.length;
            this.push(buf);
            done2();
          };
          readable.pipe(counter);
          return counter;
        };
      }
      module.exports = createTorrent;
      module.exports.parseInput = parseInput;
      module.exports.announceList = announceList;
      module.exports.isJunkPath = isJunkPath;
    }
  });

  // node_modules/debug/src/common.js
  var require_common2 = __commonJS({
    "node_modules/debug/src/common.js"(exports, module) {
      init_esbuild_inject();
      function setup(env2) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env2).forEach((key) => {
          createDebug[key] = env2[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug2(...args) {
            if (!debug2.enabled) {
              return;
            }
            const self2 = debug2;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format3) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format3];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug2.namespace = namespace;
          debug2.useColors = createDebug.useColors();
          debug2.color = createDebug.selectColor(namespace);
          debug2.extend = extend;
          debug2.destroy = createDebug.destroy;
          Object.defineProperty(debug2, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug2);
          }
          return debug2;
        }
        function extend(namespace, delimiter3) {
          const newDebug = createDebug(this.namespace + (typeof delimiter3 === "undefined" ? ":" : delimiter3) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser5 = __commonJS({
    "node_modules/debug/src/browser.js"(exports, module) {
      init_esbuild_inject();
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module.exports = require_common2()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    }
  });

  // (disabled):node_modules/bittorrent-dht/client.js
  var require_client = __commonJS({
    "(disabled):node_modules/bittorrent-dht/client.js"() {
      init_esbuild_inject();
    }
  });

  // (disabled):node_modules/load-ip-set/index.js
  var require_load_ip_set = __commonJS({
    "(disabled):node_modules/load-ip-set/index.js"() {
      init_esbuild_inject();
    }
  });

  // node_modules/blob-to-buffer/index.js
  var require_blob_to_buffer = __commonJS({
    "node_modules/blob-to-buffer/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function blobToBuffer(blob, cb) {
        if (typeof Blob === "undefined" || !(blob instanceof Blob)) {
          throw new Error("first argument must be a Blob");
        }
        if (typeof cb !== "function") {
          throw new Error("second argument must be a function");
        }
        const reader = new FileReader();
        function onLoadEnd(e) {
          reader.removeEventListener("loadend", onLoadEnd, false);
          if (e.error)
            cb(e.error);
          else
            cb(null, Buffer3.from(reader.result));
        }
        reader.addEventListener("loadend", onLoadEnd, false);
        reader.readAsArrayBuffer(blob);
      };
    }
  });

  // node-modules-polyfills:fs
  var fs_exports = {};
  __export(fs_exports, {
    default: () => fs_default
  });
  var fs_default;
  var init_fs = __esm({
    "node-modules-polyfills:fs"() {
      init_esbuild_inject();
      fs_default = {};
    }
  });

  // node-modules-polyfills-commonjs:fs
  var require_fs = __commonJS({
    "node-modules-polyfills-commonjs:fs"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_fs(), __toCommonJS(fs_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // (disabled):node_modules/parse-torrent/node_modules/decompress-response/index.js
  var require_decompress_response = __commonJS({
    "(disabled):node_modules/parse-torrent/node_modules/decompress-response/index.js"() {
      init_esbuild_inject();
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js
  function blobConstructor() {
    if (typeof _blobConstructor !== "undefined") {
      return _blobConstructor;
    }
    try {
      new globalThis.Blob([new ArrayBuffer(1)]);
      _blobConstructor = true;
    } catch (e) {
      _blobConstructor = false;
    }
    return _blobConstructor;
  }
  function checkTypeSupport(type2) {
    if (!xhr) {
      xhr = new globalThis.XMLHttpRequest();
      xhr.open("GET", globalThis.location.host ? "/" : "https://example.com");
    }
    try {
      xhr.responseType = type2;
      return xhr.responseType === type2;
    } catch (e) {
      return false;
    }
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  var hasFetch, _blobConstructor, xhr, haveArrayBuffer, haveSlice, arraybuffer, msstream, mozchunkedarraybuffer, overrideMimeType, vbArray;
  var init_capability = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/capability.js"() {
      init_esbuild_inject();
      hasFetch = isFunction2(globalThis.fetch) && isFunction2(globalThis.ReadableStream);
      haveArrayBuffer = typeof globalThis.ArrayBuffer !== "undefined";
      haveSlice = haveArrayBuffer && isFunction2(globalThis.ArrayBuffer.prototype.slice);
      arraybuffer = haveArrayBuffer && checkTypeSupport("arraybuffer");
      msstream = !hasFetch && haveSlice && checkTypeSupport("ms-stream");
      mozchunkedarraybuffer = !hasFetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer");
      overrideMimeType = isFunction2(xhr.overrideMimeType);
      vbArray = isFunction2(globalThis.VBArray);
      xhr = null;
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  var buffer_list_default;
  var init_buffer_list = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
      init_esbuild_inject();
      init_buffer();
      buffer_list_default = BufferList;
      BufferList.prototype.push = function(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          p.data.copy(ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
    }
  });

  // node-modules-polyfills:string_decoder
  var string_decoder_exports = {};
  __export(string_decoder_exports, {
    StringDecoder: () => StringDecoder
  });
  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error("Unknown encoding: " + encoding);
    }
  }
  function StringDecoder(encoding) {
    this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
    assertEncoding(encoding);
    switch (this.encoding) {
      case "utf8":
        this.surrogateSize = 3;
        break;
      case "ucs2":
      case "utf16le":
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case "base64":
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }
    this.charBuffer = new Buffer2(6);
    this.charReceived = 0;
    this.charLength = 0;
  }
  function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
  }
  function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }
  function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }
  var isBufferEncoding;
  var init_string_decoder = __esm({
    "node-modules-polyfills:string_decoder"() {
      init_esbuild_inject();
      init_buffer();
      isBufferEncoding = Buffer2.isEncoding || function(encoding) {
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      StringDecoder.prototype.write = function(buffer) {
        var charStr = "";
        while (this.charLength) {
          var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
          buffer.copy(this.charBuffer, this.charReceived, 0, available);
          this.charReceived += available;
          if (this.charReceived < this.charLength) {
            return "";
          }
          buffer = buffer.slice(available, buffer.length);
          charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
          var charCode = charStr.charCodeAt(charStr.length - 1);
          if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = "";
            continue;
          }
          this.charReceived = this.charLength = 0;
          if (buffer.length === 0) {
            return charStr;
          }
          break;
        }
        this.detectIncompleteChar(buffer);
        var end = buffer.length;
        if (this.charLength) {
          buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
          end -= this.charReceived;
        }
        charStr += buffer.toString(this.encoding, 0, end);
        var end = charStr.length - 1;
        var charCode = charStr.charCodeAt(end);
        if (charCode >= 55296 && charCode <= 56319) {
          var size = this.surrogateSize;
          this.charLength += size;
          this.charReceived += size;
          this.charBuffer.copy(this.charBuffer, size, 0, size);
          buffer.copy(this.charBuffer, 0, 0, size);
          return charStr.substring(0, end);
        }
        return charStr;
      };
      StringDecoder.prototype.detectIncompleteChar = function(buffer) {
        var i = buffer.length >= 3 ? 3 : buffer.length;
        for (; i > 0; i--) {
          var c = buffer[buffer.length - i];
          if (i == 1 && c >> 5 == 6) {
            this.charLength = 2;
            break;
          }
          if (i <= 2 && c >> 4 == 14) {
            this.charLength = 3;
            break;
          }
          if (i <= 3 && c >> 3 == 30) {
            this.charLength = 4;
            break;
          }
        }
        this.charReceived = i;
      };
      StringDecoder.prototype.end = function(buffer) {
        var res = "";
        if (buffer && buffer.length)
          res = this.write(buffer);
        if (this.charReceived) {
          var cr = this.charReceived;
          var buf = this.charBuffer;
          var enc = this.encoding;
          res += buf.slice(0, cr).toString(enc);
        }
        return res;
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
  function prependListener2(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") {
      return emitter.prependListener(event, fn);
    } else {
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  }
  function ReadableState(options, stream) {
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.buffer = new buffer_list_default();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.ranOut = false;
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (!(this instanceof Readable))
      return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options && typeof options.read === "function")
      this._read = options.read;
    events_default.call(this);
  }
  function readableAddChunk(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit("error", er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error("stream.push() after EOF");
        stream.emit("error", e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error("stream.unshift() after end event");
        stream.emit("error", _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }
        if (!addToFront)
          state.reading = false;
        if (!skipAdd) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
        }
        maybeReadMore(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }
    return needMoreData(state);
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer3.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      if (state.sync)
        nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
    }
  }
  function emitReadable_(stream) {
    debug("emit readable");
    stream.emit("readable");
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
      else
        len = state.length;
    }
    state.readingMore = false;
  }
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners("data").length) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    if (!state.reading) {
      debug("resume read 0");
      stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer3.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
      state.ended = true;
      nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
    }
  }
  function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i);
    }
  }
  function indexOf2(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
  var debug, MAX_HWM;
  var init_readable = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
      "use strict";
      init_esbuild_inject();
      init_events();
      init_util();
      init_buffer_list();
      init_string_decoder();
      init_duplex();
      init_process();
      Readable.ReadableState = ReadableState;
      debug = debuglog("stream");
      inherits_default(Readable, events_default);
      Readable.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        if (!state.objectMode && typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
        }
        return readableAddChunk(this, state, chunk, encoding, false);
      };
      Readable.prototype.unshift = function(chunk) {
        var state = this._readableState;
        return readableAddChunk(this, state, chunk, "", true);
      };
      Readable.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        this._readableState.decoder = new StringDecoder(enc);
        this._readableState.encoding = enc;
        return this;
      };
      MAX_HWM = 8388608;
      Readable.prototype.read = function(n) {
        debug("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
          debug("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        n = howMuchToRead(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        var doRead = state.needReadable;
        debug("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug("reading or ended", doRead);
        } else if (doRead) {
          debug("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = true;
          n = 0;
        } else {
          state.length -= n;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      Readable.prototype._read = function(n) {
        this.emit("error", new Error("not implemented"));
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = !pipeOpts || pipeOpts.end !== false;
        var endFn = doEnd ? onend2 : cleanup;
        if (state.endEmitted)
          nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable) {
          debug("onunpipe");
          if (readable === src) {
            cleanup();
          }
        }
        function onend2() {
          debug("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", cleanup);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        var increasedAwaitDrain = false;
        src.on("data", ondata);
        function ondata(chunk) {
          debug("ondata");
          increasedAwaitDrain = false;
          var ret = dest.write(chunk);
          if (ret === false && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
              debug("false write response, pause", src._readableState.awaitDrain);
              src._readableState.awaitDrain++;
              increasedAwaitDrain = true;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (listenerCount2(dest, "error") === 0)
            dest.emit("error", er);
        }
        prependListener2(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug("pipe resume");
          src.resume();
        }
        return dest;
      };
      Readable.prototype.unpipe = function(dest) {
        var state = this._readableState;
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var _i = 0; _i < len; _i++) {
            dests[_i].emit("unpipe", this);
          }
          return this;
        }
        var i = indexOf2(state.pipes, dest);
        if (i === -1)
          return this;
        state.pipes.splice(i, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this);
        return this;
      };
      Readable.prototype.on = function(ev, fn) {
        var res = events_default.prototype.on.call(this, ev, fn);
        if (ev === "data") {
          if (this._readableState.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          var state = this._readableState;
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
              nextTick(nReadingNextTick, this);
            } else if (state.length) {
              emitReadable(this, state);
            }
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug("resume");
          state.flowing = true;
          resume(this, state);
        }
        return this;
      };
      Readable.prototype.pause = function() {
        debug("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        return this;
      };
      Readable.prototype.wrap = function(stream) {
        var state = this._readableState;
        var paused = false;
        var self2 = this;
        stream.on("end", function() {
          debug("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              self2.push(chunk);
          }
          self2.push(null);
        });
        stream.on("data", function(chunk) {
          debug("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = self2.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function(method) {
              return function() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        var events = ["error", "close", "destroy", "pause", "resume"];
        forEach(events, function(ev) {
          stream.on(ev, self2.emit.bind(self2, ev));
        });
        self2._read = function(n) {
          debug("wrapped _read", n);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return self2;
      };
      Readable._fromList = fromList;
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
  function nop() {
  }
  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }
  function WritableState(options, stream) {
    Object.defineProperty(this, "buffer", {
      get: deprecate(function() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
    });
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  function Writable(options) {
    if (!(this instanceof Writable) && !(this instanceof Duplex))
      return new Writable(options);
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
    }
    EventEmitter.call(this);
  }
  function writeAfterEnd(stream, cb) {
    var er = new Error("write after end");
    stream.emit("error", er);
    nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream.emit("error", er);
      nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  function writeOrBuffer(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);
    if (Buffer2.isBuffer(chunk))
      encoding = "buffer";
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync)
      nextTick(cb, er);
    else
      cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit("error", er);
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function prefinish(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit("prefinish");
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream, state);
        state.finished = true;
        stream.emit("finish");
      } else {
        prefinish(stream, state);
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function(err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }
  var init_writable = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
      init_esbuild_inject();
      init_util();
      init_buffer();
      init_events();
      init_duplex();
      init_process();
      Writable.WritableState = WritableState;
      inherits_default(Writable, EventEmitter);
      WritableState.prototype.getBuffer = function writableStateGetBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      Writable.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"));
      };
      Writable.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (Buffer2.isBuffer(chunk))
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop;
        if (state.ended)
          writeAfterEnd(this, cb);
        else if (validChunk(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer(this, state, chunk, encoding, cb);
        }
        return ret;
      };
      Writable.prototype.cork = function() {
        var state = this._writableState;
        state.corked++;
      };
      Writable.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new TypeError("Unknown encoding: " + encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Writable.prototype._write = function(chunk, encoding, cb) {
        cb(new Error("not implemented"));
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending && !state.finished)
          endWritable(this, state, cb);
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
      this.readable = false;
    if (options && options.writable === false)
      this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
      this.allowHalfOpen = false;
    this.once("end", onend);
  }
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  var keys, method, v;
  var init_duplex = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
      init_esbuild_inject();
      init_util();
      init_process();
      init_readable();
      init_writable();
      inherits_default(Duplex, Readable);
      keys = Object.keys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
  function TransformState(stream) {
    this.afterTransform = function(er, data) {
      return afterTransform(stream, er, data);
    };
    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }
  function afterTransform(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb)
      return stream.emit("error", new Error("no writecb in Transform class"));
    ts.writechunk = null;
    ts.writecb = null;
    if (data !== null && data !== void 0)
      stream.push(data);
    cb(er);
    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = new TransformState(this);
    var stream = this;
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.once("prefinish", function() {
      if (typeof this._flush === "function")
        this._flush(function(er) {
          done(stream, er);
        });
      else
        done(stream);
    });
  }
  function done(stream, er) {
    if (er)
      return stream.emit("error", er);
    var ws = stream._writableState;
    var ts = stream._transformState;
    if (ws.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (ts.transforming)
      throw new Error("Calling transform done when still transforming");
    return stream.push(null);
  }
  var init_transform = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
      init_esbuild_inject();
      init_duplex();
      init_util();
      inherits_default(Transform, Duplex);
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("Not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  var init_passthrough = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
      init_esbuild_inject();
      init_transform();
      init_util();
      inherits_default(PassThrough, Transform);
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node-modules-polyfills:stream
  var stream_exports = {};
  __export(stream_exports, {
    Duplex: () => Duplex,
    PassThrough: () => PassThrough,
    Readable: () => Readable,
    Stream: () => Stream,
    Transform: () => Transform,
    Writable: () => Writable,
    default: () => stream_default
  });
  function Stream() {
    events_default.call(this);
  }
  var stream_default;
  var init_stream = __esm({
    "node-modules-polyfills:stream"() {
      init_esbuild_inject();
      init_events();
      init_util();
      init_duplex();
      init_readable();
      init_writable();
      init_transform();
      init_passthrough();
      inherits_default(Stream, events_default);
      Stream.Readable = Readable;
      Stream.Writable = Writable;
      Stream.Duplex = Duplex;
      Stream.Transform = Transform;
      Stream.PassThrough = PassThrough;
      Stream.Stream = Stream;
      stream_default = Stream;
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (dest.write(chunk) === false && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend2);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend2() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (events_default.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend2);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js
  function IncomingMessage(xhr2, response, mode) {
    var self2 = this;
    Readable.call(self2);
    self2._mode = mode;
    self2.headers = {};
    self2.rawHeaders = [];
    self2.trailers = {};
    self2.rawTrailers = [];
    self2.on("end", function() {
      process.nextTick(function() {
        self2.emit("close");
      });
    });
    var read2;
    if (mode === "fetch") {
      self2._fetchResponse = response;
      self2.url = response.url;
      self2.statusCode = response.status;
      self2.statusMessage = response.statusText;
      for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done; ) {
        self2.headers[header[0].toLowerCase()] = header[1];
        self2.rawHeaders.push(header[0], header[1]);
      }
      var reader = response.body.getReader();
      read2 = function() {
        reader.read().then(function(result) {
          if (self2._destroyed)
            return;
          if (result.done) {
            self2.push(null);
            return;
          }
          self2.push(new Buffer3(result.value));
          read2();
        });
      };
      read2();
    } else {
      self2._xhr = xhr2;
      self2._pos = 0;
      self2.url = xhr2.responseURL;
      self2.statusCode = xhr2.status;
      self2.statusMessage = xhr2.statusText;
      var headers = xhr2.getAllResponseHeaders().split(/\r?\n/);
      headers.forEach(function(header2) {
        var matches = header2.match(/^([^:]+):\s*(.*)/);
        if (matches) {
          var key = matches[1].toLowerCase();
          if (key === "set-cookie") {
            if (self2.headers[key] === void 0) {
              self2.headers[key] = [];
            }
            self2.headers[key].push(matches[2]);
          } else if (self2.headers[key] !== void 0) {
            self2.headers[key] += ", " + matches[2];
          } else {
            self2.headers[key] = matches[2];
          }
          self2.rawHeaders.push(matches[1], matches[2]);
        }
      });
      self2._charset = "x-user-defined";
      if (!overrideMimeType) {
        var mimeType = self2.rawHeaders["mime-type"];
        if (mimeType) {
          var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
          if (charsetMatch) {
            self2._charset = charsetMatch[1].toLowerCase();
          }
        }
        if (!self2._charset)
          self2._charset = "utf-8";
      }
    }
  }
  var rStates;
  var init_response = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/response.js"() {
      init_esbuild_inject();
      init_capability();
      init_util();
      init_stream();
      rStates = {
        UNSENT: 0,
        OPENED: 1,
        HEADERS_RECEIVED: 2,
        LOADING: 3,
        DONE: 4
      };
      inherits_default(IncomingMessage, Readable);
      IncomingMessage.prototype._read = function() {
      };
      IncomingMessage.prototype._onXHRProgress = function() {
        var self2 = this;
        var xhr2 = self2._xhr;
        var response = null;
        switch (self2._mode) {
          case "text:vbarray":
            if (xhr2.readyState !== rStates.DONE)
              break;
            try {
              response = new globalThis.VBArray(xhr2.responseBody).toArray();
            } catch (e) {
            }
            if (response !== null) {
              self2.push(new Buffer3(response));
              break;
            }
          case "text":
            try {
              response = xhr2.responseText;
            } catch (e) {
              self2._mode = "text:vbarray";
              break;
            }
            if (response.length > self2._pos) {
              var newData = response.substr(self2._pos);
              if (self2._charset === "x-user-defined") {
                var buffer = new Buffer3(newData.length);
                for (var i = 0; i < newData.length; i++)
                  buffer[i] = newData.charCodeAt(i) & 255;
                self2.push(buffer);
              } else {
                self2.push(newData, self2._charset);
              }
              self2._pos = response.length;
            }
            break;
          case "arraybuffer":
            if (xhr2.readyState !== rStates.DONE || !xhr2.response)
              break;
            response = xhr2.response;
            self2.push(new Buffer3(new Uint8Array(response)));
            break;
          case "moz-chunked-arraybuffer":
            response = xhr2.response;
            if (xhr2.readyState !== rStates.LOADING || !response)
              break;
            self2.push(new Buffer3(new Uint8Array(response)));
            break;
          case "ms-stream":
            response = xhr2.response;
            if (xhr2.readyState !== rStates.LOADING)
              break;
            var reader = new globalThis.MSStreamReader();
            reader.onprogress = function() {
              if (reader.result.byteLength > self2._pos) {
                self2.push(new Buffer3(new Uint8Array(reader.result.slice(self2._pos))));
                self2._pos = reader.result.byteLength;
              }
            };
            reader.onload = function() {
              self2.push(null);
            };
            reader.readAsArrayBuffer(response);
            break;
        }
        if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
          self2.push(null);
        }
      };
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js
  function to_arraybuffer_default(buf) {
    if (buf instanceof Uint8Array) {
      if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      } else if (typeof buf.buffer.slice === "function") {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      }
    }
    if (isBuffer(buf)) {
      var arrayCopy = new Uint8Array(buf.length);
      var len = buf.length;
      for (var i = 0; i < len; i++) {
        arrayCopy[i] = buf[i];
      }
      return arrayCopy.buffer;
    } else {
      throw new Error("Argument must be a Buffer");
    }
  }
  var init_to_arraybuffer = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/to-arraybuffer.js"() {
      init_esbuild_inject();
      init_buffer();
    }
  });

  // node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js
  function decideMode(preferBinary, useFetch) {
    if (hasFetch && useFetch) {
      return "fetch";
    } else if (mozchunkedarraybuffer) {
      return "moz-chunked-arraybuffer";
    } else if (msstream) {
      return "ms-stream";
    } else if (arraybuffer && preferBinary) {
      return "arraybuffer";
    } else if (vbArray && preferBinary) {
      return "text:vbarray";
    } else {
      return "text";
    }
  }
  function ClientRequest(opts) {
    var self2 = this;
    Writable.call(self2);
    self2._opts = opts;
    self2._body = [];
    self2._headers = {};
    if (opts.auth)
      self2.setHeader("Authorization", "Basic " + new Buffer3(opts.auth).toString("base64"));
    Object.keys(opts.headers).forEach(function(name) {
      self2.setHeader(name, opts.headers[name]);
    });
    var preferBinary;
    var useFetch = true;
    if (opts.mode === "disable-fetch") {
      useFetch = false;
      preferBinary = true;
    } else if (opts.mode === "prefer-streaming") {
      preferBinary = false;
    } else if (opts.mode === "allow-wrong-content-type") {
      preferBinary = !overrideMimeType;
    } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
      preferBinary = true;
    } else {
      throw new Error("Invalid value for opts.mode");
    }
    self2._mode = decideMode(preferBinary, useFetch);
    self2.on("finish", function() {
      self2._onFinish();
    });
  }
  function statusValid(xhr2) {
    try {
      var status = xhr2.status;
      return status !== null && status !== 0;
    } catch (e) {
      return false;
    }
  }
  var request_default, unsafeHeaders;
  var init_request = __esm({
    "node_modules/rollup-plugin-node-polyfills/polyfills/http-lib/request.js"() {
      init_esbuild_inject();
      init_capability();
      init_util();
      init_response();
      init_stream();
      init_to_arraybuffer();
      request_default = ClientRequest;
      inherits_default(ClientRequest, Writable);
      unsafeHeaders = [
        "accept-charset",
        "accept-encoding",
        "access-control-request-headers",
        "access-control-request-method",
        "connection",
        "content-length",
        "cookie",
        "cookie2",
        "date",
        "dnt",
        "expect",
        "host",
        "keep-alive",
        "origin",
        "referer",
        "te",
        "trailer",
        "transfer-encoding",
        "upgrade",
        "user-agent",
        "via"
      ];
      ClientRequest.prototype.setHeader = function(name, value) {
        var self2 = this;
        var lowerName = name.toLowerCase();
        if (unsafeHeaders.indexOf(lowerName) !== -1)
          return;
        self2._headers[lowerName] = {
          name,
          value
        };
      };
      ClientRequest.prototype.getHeader = function(name) {
        var self2 = this;
        return self2._headers[name.toLowerCase()].value;
      };
      ClientRequest.prototype.removeHeader = function(name) {
        var self2 = this;
        delete self2._headers[name.toLowerCase()];
      };
      ClientRequest.prototype._onFinish = function() {
        var self2 = this;
        if (self2._destroyed)
          return;
        var opts = self2._opts;
        var headersObj = self2._headers;
        var body;
        if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
          if (blobConstructor()) {
            body = new globalThis.Blob(self2._body.map(function(buffer) {
              return to_arraybuffer_default(buffer);
            }), {
              type: (headersObj["content-type"] || {}).value || ""
            });
          } else {
            body = Buffer3.concat(self2._body).toString();
          }
        }
        if (self2._mode === "fetch") {
          var headers = Object.keys(headersObj).map(function(name) {
            return [headersObj[name].name, headersObj[name].value];
          });
          globalThis.fetch(self2._opts.url, {
            method: self2._opts.method,
            headers,
            body,
            mode: "cors",
            credentials: opts.withCredentials ? "include" : "same-origin"
          }).then(function(response) {
            self2._fetchResponse = response;
            self2._connect();
          }, function(reason) {
            self2.emit("error", reason);
          });
        } else {
          var xhr2 = self2._xhr = new globalThis.XMLHttpRequest();
          try {
            xhr2.open(self2._opts.method, self2._opts.url, true);
          } catch (err) {
            process.nextTick(function() {
              self2.emit("error", err);
            });
            return;
          }
          if ("responseType" in xhr2)
            xhr2.responseType = self2._mode.split(":")[0];
          if ("withCredentials" in xhr2)
            xhr2.withCredentials = !!opts.withCredentials;
          if (self2._mode === "text" && "overrideMimeType" in xhr2)
            xhr2.overrideMimeType("text/plain; charset=x-user-defined");
          Object.keys(headersObj).forEach(function(name) {
            xhr2.setRequestHeader(headersObj[name].name, headersObj[name].value);
          });
          self2._response = null;
          xhr2.onreadystatechange = function() {
            switch (xhr2.readyState) {
              case rStates.LOADING:
              case rStates.DONE:
                self2._onXHRProgress();
                break;
            }
          };
          if (self2._mode === "moz-chunked-arraybuffer") {
            xhr2.onprogress = function() {
              self2._onXHRProgress();
            };
          }
          xhr2.onerror = function() {
            if (self2._destroyed)
              return;
            self2.emit("error", new Error("XHR error"));
          };
          try {
            xhr2.send(body);
          } catch (err) {
            process.nextTick(function() {
              self2.emit("error", err);
            });
            return;
          }
        }
      };
      ClientRequest.prototype._onXHRProgress = function() {
        var self2 = this;
        if (!statusValid(self2._xhr) || self2._destroyed)
          return;
        if (!self2._response)
          self2._connect();
        self2._response._onXHRProgress();
      };
      ClientRequest.prototype._connect = function() {
        var self2 = this;
        if (self2._destroyed)
          return;
        self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode);
        self2.emit("response", self2._response);
      };
      ClientRequest.prototype._write = function(chunk, encoding, cb) {
        var self2 = this;
        self2._body.push(chunk);
        cb();
      };
      ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
        var self2 = this;
        self2._destroyed = true;
        if (self2._response)
          self2._response._destroyed = true;
        if (self2._xhr)
          self2._xhr.abort();
      };
      ClientRequest.prototype.end = function(data, encoding, cb) {
        var self2 = this;
        if (typeof data === "function") {
          cb = data;
          data = void 0;
        }
        Writable.prototype.end.call(self2, data, encoding, cb);
      };
      ClientRequest.prototype.flushHeaders = function() {
      };
      ClientRequest.prototype.setTimeout = function() {
      };
      ClientRequest.prototype.setNoDelay = function() {
      };
      ClientRequest.prototype.setSocketKeepAlive = function() {
      };
    }
  });

  // node-modules-polyfills:punycode
  function error(type2) {
    throw new RangeError(errors[type2]);
  }
  function map(array, fn) {
    var length = array.length;
    var result = [];
    while (length--) {
      result[length] = fn(array[length]);
    }
    return result;
  }
  function mapDomain(string, fn) {
    var parts = string.split("@");
    var result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      string = parts[1];
    }
    string = string.replace(regexSeparators, ".");
    var labels = string.split(".");
    var encoded = map(labels, fn).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    var output = [], counter = 0, length = string.length, value, extra;
    while (counter < length) {
      value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  function digitToBasic(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  function encode(input) {
    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
    input = ucs2decode(input);
    inputLength = input.length;
    n = initialN;
    delta = 0;
    bias = initialBias;
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    handledCPCount = basicLength = output.length;
    if (basicLength) {
      output.push(delimiter2);
    }
    while (handledCPCount < inputLength) {
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue == n) {
          for (q = delta, k = base; ; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  }
  function toASCII(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  }
  var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter2, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode;
  var init_punycode = __esm({
    "node-modules-polyfills:punycode"() {
      init_esbuild_inject();
      maxInt = 2147483647;
      base = 36;
      tMin = 1;
      tMax = 26;
      skew = 38;
      damp = 700;
      initialBias = 72;
      initialN = 128;
      delimiter2 = "-";
      regexNonASCII = /[^\x20-\x7E]/;
      regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      baseMinusTMin = base - tMin;
      floor = Math.floor;
      stringFromCharCode = String.fromCharCode;
    }
  });

  // node-modules-polyfills:querystring
  var querystring_exports = {};
  __export(querystring_exports, {
    decode: () => parse,
    default: () => querystring_default,
    encode: () => stringify,
    parse: () => parse,
    stringify: () => stringify
  });
  function hasOwnProperty2(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function stringifyPrimitive(v) {
    switch (typeof v) {
      case "string":
        return v;
      case "boolean":
        return v ? "true" : "false";
      case "number":
        return isFinite(v) ? v : "";
      default:
        return "";
    }
  }
  function stringify(obj, sep2, eq, name) {
    sep2 = sep2 || "&";
    eq = eq || "=";
    if (obj === null) {
      obj = void 0;
    }
    if (typeof obj === "object") {
      return map2(objectKeys(obj), function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (isArray3(obj[k])) {
          return map2(obj[k], function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep2);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep2);
    }
    if (!name)
      return "";
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  }
  function map2(xs, f) {
    if (xs.map)
      return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      res.push(f(xs[i], i));
    }
    return res;
  }
  function parse(qs, sep2, eq, options) {
    sep2 = sep2 || "&";
    eq = eq || "=";
    var obj = {};
    if (typeof qs !== "string" || qs.length === 0) {
      return obj;
    }
    var regexp = /\+/g;
    qs = qs.split(sep2);
    var maxKeys = 1e3;
    if (options && typeof options.maxKeys === "number") {
      maxKeys = options.maxKeys;
    }
    var len = qs.length;
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }
    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = "";
      }
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
      if (!hasOwnProperty2(obj, k)) {
        obj[k] = v;
      } else if (isArray3(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }
    return obj;
  }
  var isArray3, objectKeys, querystring_default;
  var init_querystring = __esm({
    "node-modules-polyfills:querystring"() {
      init_esbuild_inject();
      isArray3 = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
      objectKeys = Object.keys || function(obj) {
        var res = [];
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key))
            res.push(key);
        }
        return res;
      };
      querystring_default = {
        encode: stringify,
        stringify,
        decode: parse,
        parse
      };
    }
  });

  // node-modules-polyfills:url
  var url_exports = {};
  __export(url_exports, {
    Url: () => Url,
    default: () => url_default,
    format: () => urlFormat,
    parse: () => urlParse,
    resolve: () => urlResolve,
    resolveObject: () => urlResolveObject
  });
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && isObject(url) && url instanceof Url)
      return url;
    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }
  function parse2(self2, url, parseQueryString, slashesDenoteHost) {
    if (!isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }
    var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url = uSplit.join(splitter);
    var rest = url;
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        self2.path = rest;
        self2.href = rest;
        self2.pathname = simplePath[1];
        if (simplePath[2]) {
          self2.search = simplePath[2];
          if (parseQueryString) {
            self2.query = parse(self2.search.substr(1));
          } else {
            self2.query = self2.search.substr(1);
          }
        } else if (parseQueryString) {
          self2.search = "";
          self2.query = {};
        }
        return self2;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      self2.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        self2.slashes = true;
      }
    }
    var i, hec, l, p;
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        self2.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      if (hostEnd === -1)
        hostEnd = rest.length;
      self2.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      parseHost(self2);
      self2.hostname = self2.hostname || "";
      var ipv6Hostname = self2.hostname[0] === "[" && self2.hostname[self2.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = self2.hostname.split(/\./);
        for (i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part)
            continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += "x";
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = "/" + notHost.join(".") + rest;
              }
              self2.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (self2.hostname.length > hostnameMaxLen) {
        self2.hostname = "";
      } else {
        self2.hostname = self2.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        self2.hostname = toASCII(self2.hostname);
      }
      p = self2.port ? ":" + self2.port : "";
      var h = self2.hostname || "";
      self2.host = h + p;
      self2.href += self2.host;
      if (ipv6Hostname) {
        self2.hostname = self2.hostname.substr(1, self2.hostname.length - 2);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1)
          continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      self2.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      self2.search = rest.substr(qm);
      self2.query = rest.substr(qm + 1);
      if (parseQueryString) {
        self2.query = parse(self2.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      self2.search = "";
      self2.query = {};
    }
    if (rest)
      self2.pathname = rest;
    if (slashedProtocol[lowerProto] && self2.hostname && !self2.pathname) {
      self2.pathname = "/";
    }
    if (self2.pathname || self2.search) {
      p = self2.pathname || "";
      var s = self2.search || "";
      self2.path = p + s;
    }
    self2.href = format2(self2);
    return self2;
  }
  function urlFormat(obj) {
    if (isString(obj))
      obj = parse2({}, obj);
    return format2(obj);
  }
  function format2(self2) {
    var auth = self2.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = self2.protocol || "", pathname = self2.pathname || "", hash = self2.hash || "", host = false, query = "";
    if (self2.host) {
      host = auth + self2.host;
    } else if (self2.hostname) {
      host = auth + (self2.hostname.indexOf(":") === -1 ? self2.hostname : "[" + this.hostname + "]");
      if (self2.port) {
        host += ":" + self2.port;
      }
    }
    if (self2.query && isObject(self2.query) && Object.keys(self2.query).length) {
      query = stringify(self2.query);
    }
    var search = self2.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":")
      protocol += ":";
    if (self2.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = "//" + (host || "");
      if (pathname && pathname.charAt(0) !== "/")
        pathname = "/" + pathname;
    } else if (!host) {
      host = "";
    }
    if (hash && hash.charAt(0) !== "#")
      hash = "#" + hash;
    if (search && search.charAt(0) !== "?")
      search = "?" + search;
    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
  }
  function urlResolve(source, relative2) {
    return urlParse(source, false, true).resolve(relative2);
  }
  function urlResolveObject(source, relative2) {
    if (!source)
      return relative2;
    return urlParse(source, false, true).resolveObject(relative2);
  }
  function parseHost(self2) {
    var host = self2.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        self2.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host)
      self2.hostname = host;
  }
  var url_default, protocolPattern, portPattern, simplePathPattern, delims, unwise, autoEscape, nonHostChars, hostEndingChars, hostnameMaxLen, hostnamePartPattern, hostnamePartStart, unsafeProtocol, hostlessProtocol, slashedProtocol;
  var init_url = __esm({
    "node-modules-polyfills:url"() {
      init_esbuild_inject();
      init_punycode();
      init_util();
      init_querystring();
      url_default = {
        parse: urlParse,
        resolve: urlResolve,
        resolveObject: urlResolveObject,
        format: urlFormat,
        Url
      };
      protocolPattern = /^([a-z0-9.+-]+:)/i;
      portPattern = /:[0-9]*$/;
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
      unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
      autoEscape = ["'"].concat(unwise);
      nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
      hostEndingChars = ["/", "?", "#"];
      hostnameMaxLen = 255;
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      unsafeProtocol = {
        "javascript": true,
        "javascript:": true
      };
      hostlessProtocol = {
        "javascript": true,
        "javascript:": true
      };
      slashedProtocol = {
        "http": true,
        "https": true,
        "ftp": true,
        "gopher": true,
        "file": true,
        "http:": true,
        "https:": true,
        "ftp:": true,
        "gopher:": true,
        "file:": true
      };
      Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
        return parse2(this, url, parseQueryString, slashesDenoteHost);
      };
      Url.prototype.format = function() {
        return format2(this);
      };
      Url.prototype.resolve = function(relative2) {
        return this.resolveObject(urlParse(relative2, false, true)).format();
      };
      Url.prototype.resolveObject = function(relative2) {
        if (isString(relative2)) {
          var rel = new Url();
          rel.parse(relative2, false, true);
          relative2 = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
          var tkey = tkeys[tk];
          result[tkey] = this[tkey];
        }
        result.hash = relative2.hash;
        if (relative2.href === "") {
          result.href = result.format();
          return result;
        }
        if (relative2.slashes && !relative2.protocol) {
          var rkeys = Object.keys(relative2);
          for (var rk = 0; rk < rkeys.length; rk++) {
            var rkey = rkeys[rk];
            if (rkey !== "protocol")
              result[rkey] = relative2[rkey];
          }
          if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
            result.path = result.pathname = "/";
          }
          result.href = result.format();
          return result;
        }
        var relPath;
        if (relative2.protocol && relative2.protocol !== result.protocol) {
          if (!slashedProtocol[relative2.protocol]) {
            var keys2 = Object.keys(relative2);
            for (var v = 0; v < keys2.length; v++) {
              var k = keys2[v];
              result[k] = relative2[k];
            }
            result.href = result.format();
            return result;
          }
          result.protocol = relative2.protocol;
          if (!relative2.host && !hostlessProtocol[relative2.protocol]) {
            relPath = (relative2.pathname || "").split("/");
            while (relPath.length && !(relative2.host = relPath.shift()))
              ;
            if (!relative2.host)
              relative2.host = "";
            if (!relative2.hostname)
              relative2.hostname = "";
            if (relPath[0] !== "")
              relPath.unshift("");
            if (relPath.length < 2)
              relPath.unshift("");
            result.pathname = relPath.join("/");
          } else {
            result.pathname = relative2.pathname;
          }
          result.search = relative2.search;
          result.query = relative2.query;
          result.host = relative2.host || "";
          result.auth = relative2.auth;
          result.hostname = relative2.hostname || relative2.host;
          result.port = relative2.port;
          if (result.pathname || result.search) {
            var p = result.pathname || "";
            var s = result.search || "";
            result.path = p + s;
          }
          result.slashes = result.slashes || relative2.slashes;
          result.href = result.format();
          return result;
        }
        var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative2.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
        relPath = relative2.pathname && relative2.pathname.split("/") || [];
        if (psychotic) {
          result.hostname = "";
          result.port = null;
          if (result.host) {
            if (srcPath[0] === "")
              srcPath[0] = result.host;
            else
              srcPath.unshift(result.host);
          }
          result.host = "";
          if (relative2.protocol) {
            relative2.hostname = null;
            relative2.port = null;
            if (relative2.host) {
              if (relPath[0] === "")
                relPath[0] = relative2.host;
              else
                relPath.unshift(relative2.host);
            }
            relative2.host = null;
          }
          mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
        }
        var authInHost;
        if (isRelAbs) {
          result.host = relative2.host || relative2.host === "" ? relative2.host : result.host;
          result.hostname = relative2.hostname || relative2.hostname === "" ? relative2.hostname : result.hostname;
          result.search = relative2.search;
          result.query = relative2.query;
          srcPath = relPath;
        } else if (relPath.length) {
          if (!srcPath)
            srcPath = [];
          srcPath.pop();
          srcPath = srcPath.concat(relPath);
          result.search = relative2.search;
          result.query = relative2.query;
        } else if (!isNullOrUndefined(relative2.search)) {
          if (psychotic) {
            result.hostname = result.host = srcPath.shift();
            authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          result.search = relative2.search;
          result.query = relative2.query;
          if (!isNull(result.pathname) || !isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.href = result.format();
          return result;
        }
        if (!srcPath.length) {
          result.pathname = null;
          if (result.search) {
            result.path = "/" + result.search;
          } else {
            result.path = null;
          }
          result.href = result.format();
          return result;
        }
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = (result.host || relative2.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
          last = srcPath[i];
          if (last === ".") {
            srcPath.splice(i, 1);
          } else if (last === "..") {
            srcPath.splice(i, 1);
            up++;
          } else if (up) {
            srcPath.splice(i, 1);
            up--;
          }
        }
        if (!mustEndAbs && !removeAllDots) {
          for (; up--; up) {
            srcPath.unshift("..");
          }
        }
        if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
          srcPath.unshift("");
        }
        if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
          srcPath.push("");
        }
        var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
        if (psychotic) {
          result.hostname = result.host = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
          authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        mustEndAbs = mustEndAbs || result.host && srcPath.length;
        if (mustEndAbs && !isAbsolute2) {
          srcPath.unshift("");
        }
        if (!srcPath.length) {
          result.pathname = null;
          result.path = null;
        } else {
          result.pathname = srcPath.join("/");
        }
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.auth = relative2.auth || result.auth;
        result.slashes = result.slashes || relative2.slashes;
        result.href = result.format();
        return result;
      };
      Url.prototype.parseHost = function() {
        return parseHost(this);
      };
    }
  });

  // node-modules-polyfills:http
  var http_exports = {};
  __export(http_exports, {
    Agent: () => Agent,
    METHODS: () => METHODS,
    STATUS_CODES: () => STATUS_CODES,
    default: () => http_default,
    get: () => get,
    request: () => request
  });
  function request(opts, cb) {
    if (typeof opts === "string")
      opts = urlParse(opts);
    var defaultProtocol = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
    var protocol = opts.protocol || defaultProtocol;
    var host = opts.hostname || opts.host;
    var port = opts.port;
    var path = opts.path || "/";
    if (host && host.indexOf(":") !== -1)
      host = "[" + host + "]";
    opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
    opts.method = (opts.method || "GET").toUpperCase();
    opts.headers = opts.headers || {};
    var req = new request_default(opts);
    if (cb)
      req.on("response", cb);
    return req;
  }
  function get(opts, cb) {
    var req = request(opts, cb);
    req.end();
    return req;
  }
  function Agent() {
  }
  var METHODS, STATUS_CODES, http_default;
  var init_http = __esm({
    "node-modules-polyfills:http"() {
      init_esbuild_inject();
      init_request();
      init_url();
      Agent.defaultMaxSockets = 4;
      METHODS = [
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "DELETE",
        "GET",
        "HEAD",
        "LOCK",
        "M-SEARCH",
        "MERGE",
        "MKACTIVITY",
        "MKCOL",
        "MOVE",
        "NOTIFY",
        "OPTIONS",
        "PATCH",
        "POST",
        "PROPFIND",
        "PROPPATCH",
        "PURGE",
        "PUT",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNLOCK",
        "UNSUBSCRIBE"
      ];
      STATUS_CODES = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Moved Temporarily",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Time-out",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Large",
        415: "Unsupported Media Type",
        416: "Requested Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a teapot",
        422: "Unprocessable Entity",
        423: "Locked",
        424: "Failed Dependency",
        425: "Unordered Collection",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Time-out",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        511: "Network Authentication Required"
      };
      http_default = {
        request,
        get,
        Agent,
        METHODS,
        STATUS_CODES
      };
    }
  });

  // node-modules-polyfills-commonjs:http
  var require_http = __commonJS({
    "node-modules-polyfills-commonjs:http"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_http(), __toCommonJS(http_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills:https
  var https_exports = {};
  __export(https_exports, {
    Agent: () => Agent2,
    METHODS: () => METHODS2,
    STATUS_CODES: () => STATUS_CODES2,
    default: () => https_default,
    get: () => get2,
    request: () => request2
  });
  function request2(opts, cb) {
    if (typeof opts === "string")
      opts = urlParse(opts);
    var defaultProtocol = globalThis.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
    var protocol = opts.protocol || defaultProtocol;
    var host = opts.hostname || opts.host;
    var port = opts.port;
    var path = opts.path || "/";
    if (host && host.indexOf(":") !== -1)
      host = "[" + host + "]";
    opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
    opts.method = (opts.method || "GET").toUpperCase();
    opts.headers = opts.headers || {};
    var req = new request_default(opts);
    if (cb)
      req.on("response", cb);
    return req;
  }
  function get2(opts, cb) {
    var req = request2(opts, cb);
    req.end();
    return req;
  }
  function Agent2() {
  }
  var METHODS2, STATUS_CODES2, https_default;
  var init_https = __esm({
    "node-modules-polyfills:https"() {
      init_esbuild_inject();
      init_request();
      init_url();
      Agent2.defaultMaxSockets = 4;
      METHODS2 = [
        "CHECKOUT",
        "CONNECT",
        "COPY",
        "DELETE",
        "GET",
        "HEAD",
        "LOCK",
        "M-SEARCH",
        "MERGE",
        "MKACTIVITY",
        "MKCOL",
        "MOVE",
        "NOTIFY",
        "OPTIONS",
        "PATCH",
        "POST",
        "PROPFIND",
        "PROPPATCH",
        "PURGE",
        "PUT",
        "REPORT",
        "SEARCH",
        "SUBSCRIBE",
        "TRACE",
        "UNLOCK",
        "UNSUBSCRIBE"
      ];
      STATUS_CODES2 = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Moved Temporarily",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Time-out",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Large",
        415: "Unsupported Media Type",
        416: "Requested Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a teapot",
        422: "Unprocessable Entity",
        423: "Locked",
        424: "Failed Dependency",
        425: "Unordered Collection",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Time-out",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        511: "Network Authentication Required"
      };
      https_default = {
        request: request2,
        get: get2,
        Agent: Agent2,
        METHODS: METHODS2,
        STATUS_CODES: STATUS_CODES2
      };
    }
  });

  // node-modules-polyfills-commonjs:https
  var require_https = __commonJS({
    "node-modules-polyfills-commonjs:https"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_https(), __toCommonJS(https_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills-commonjs:querystring
  var require_querystring = __commonJS({
    "node-modules-polyfills-commonjs:querystring"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_querystring(), __toCommonJS(querystring_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills-commonjs:url
  var require_url = __commonJS({
    "node-modules-polyfills-commonjs:url"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_url(), __toCommonJS(url_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node_modules/parse-torrent/node_modules/simple-get/index.js
  var require_simple_get = __commonJS({
    "node_modules/parse-torrent/node_modules/simple-get/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = simpleGet;
      var concat2 = require_simple_concat();
      var decompressResponse = require_decompress_response();
      var http = require_http();
      var https = require_https();
      var once3 = require_once();
      var querystring = require_querystring();
      var url = require_url();
      var isStream = (o) => o !== null && typeof o === "object" && typeof o.pipe === "function";
      function simpleGet(opts, cb) {
        opts = Object.assign({ maxRedirects: 10 }, typeof opts === "string" ? { url: opts } : opts);
        cb = once3(cb);
        if (opts.url) {
          const { hostname: hostname2, port, protocol: protocol2, auth, path } = url.parse(opts.url);
          delete opts.url;
          if (!hostname2 && !port && !protocol2 && !auth)
            opts.path = path;
          else
            Object.assign(opts, { hostname: hostname2, port, protocol: protocol2, auth, path });
        }
        const headers = { "accept-encoding": "gzip, deflate" };
        if (opts.headers)
          Object.keys(opts.headers).forEach((k) => headers[k.toLowerCase()] = opts.headers[k]);
        opts.headers = headers;
        let body;
        if (opts.body) {
          body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body;
        } else if (opts.form) {
          body = typeof opts.form === "string" ? opts.form : querystring.stringify(opts.form);
          opts.headers["content-type"] = "application/x-www-form-urlencoded";
        }
        if (body) {
          if (!opts.method)
            opts.method = "POST";
          if (!isStream(body))
            opts.headers["content-length"] = Buffer3.byteLength(body);
          if (opts.json && !opts.form)
            opts.headers["content-type"] = "application/json";
        }
        delete opts.body;
        delete opts.form;
        if (opts.json)
          opts.headers.accept = "application/json";
        if (opts.method)
          opts.method = opts.method.toUpperCase();
        const originalHost = opts.hostname;
        const protocol = opts.protocol === "https:" ? https : http;
        const req = protocol.request(opts, (res) => {
          if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
            opts.url = res.headers.location;
            delete opts.headers.host;
            res.resume();
            const redirectHost = url.parse(opts.url).hostname;
            if (redirectHost !== null && redirectHost !== originalHost) {
              delete opts.headers.cookie;
              delete opts.headers.authorization;
            }
            if (opts.method === "POST" && [301, 302].includes(res.statusCode)) {
              opts.method = "GET";
              delete opts.headers["content-length"];
              delete opts.headers["content-type"];
            }
            if (opts.maxRedirects-- === 0)
              return cb(new Error("too many redirects"));
            else
              return simpleGet(opts, cb);
          }
          const tryUnzip = typeof decompressResponse === "function" && opts.method !== "HEAD";
          cb(null, tryUnzip ? decompressResponse(res) : res);
        });
        req.on("timeout", () => {
          req.abort();
          cb(new Error("Request timed out"));
        });
        req.on("error", cb);
        if (isStream(body))
          body.on("error", cb).pipe(req);
        else
          req.end(body);
        return req;
      }
      simpleGet.concat = (opts, cb) => {
        return simpleGet(opts, (err, res) => {
          if (err)
            return cb(err);
          concat2(res, (err2, data) => {
            if (err2)
              return cb(err2);
            if (opts.json) {
              try {
                data = JSON.parse(data.toString());
              } catch (err3) {
                return cb(err3, res, data);
              }
            }
            cb(null, res, data);
          });
        });
      };
      ["get", "post", "put", "patch", "head", "delete"].forEach((method) => {
        simpleGet[method] = (opts, cb) => {
          if (typeof opts === "string")
            opts = { url: opts };
          return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb);
        };
      });
    }
  });

  // node_modules/thirty-two/lib/thirty-two/thirty-two.js
  var require_thirty_two = __commonJS({
    "node_modules/thirty-two/lib/thirty-two/thirty-two.js"(exports) {
      "use strict";
      init_esbuild_inject();
      var charTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
      var byteTable = [
        255,
        255,
        26,
        27,
        28,
        29,
        30,
        31,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        255,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        255,
        255,
        255,
        255,
        255,
        255,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        255,
        255,
        255,
        255,
        255
      ];
      function quintetCount(buff) {
        var quintets = Math.floor(buff.length / 5);
        return buff.length % 5 === 0 ? quintets : quintets + 1;
      }
      exports.encode = function(plain) {
        if (!Buffer3.isBuffer(plain)) {
          plain = new Buffer3(plain);
        }
        var i = 0;
        var j = 0;
        var shiftIndex = 0;
        var digit = 0;
        var encoded = new Buffer3(quintetCount(plain) * 8);
        while (i < plain.length) {
          var current = plain[i];
          if (shiftIndex > 3) {
            digit = current & 255 >> shiftIndex;
            shiftIndex = (shiftIndex + 5) % 8;
            digit = digit << shiftIndex | (i + 1 < plain.length ? plain[i + 1] : 0) >> 8 - shiftIndex;
            i++;
          } else {
            digit = current >> 8 - (shiftIndex + 5) & 31;
            shiftIndex = (shiftIndex + 5) % 8;
            if (shiftIndex === 0)
              i++;
          }
          encoded[j] = charTable.charCodeAt(digit);
          j++;
        }
        for (i = j; i < encoded.length; i++) {
          encoded[i] = 61;
        }
        return encoded;
      };
      exports.decode = function(encoded) {
        var shiftIndex = 0;
        var plainDigit = 0;
        var plainChar;
        var plainPos = 0;
        if (!Buffer3.isBuffer(encoded)) {
          encoded = new Buffer3(encoded);
        }
        var decoded = new Buffer3(Math.ceil(encoded.length * 5 / 8));
        for (var i = 0; i < encoded.length; i++) {
          if (encoded[i] === 61) {
            break;
          }
          var encodedByte = encoded[i] - 48;
          if (encodedByte < byteTable.length) {
            plainDigit = byteTable[encodedByte];
            if (shiftIndex <= 3) {
              shiftIndex = (shiftIndex + 5) % 8;
              if (shiftIndex === 0) {
                plainChar |= plainDigit;
                decoded[plainPos] = plainChar;
                plainPos++;
                plainChar = 0;
              } else {
                plainChar |= 255 & plainDigit << 8 - shiftIndex;
              }
            } else {
              shiftIndex = (shiftIndex + 5) % 8;
              plainChar |= 255 & plainDigit >>> shiftIndex;
              decoded[plainPos] = plainChar;
              plainPos++;
              plainChar = 255 & plainDigit << 8 - shiftIndex;
            }
          } else {
            throw new Error("Invalid input - it is not base32 encoded string");
          }
        }
        return decoded.slice(0, plainPos);
      };
    }
  });

  // node_modules/thirty-two/lib/thirty-two/index.js
  var require_thirty_two2 = __commonJS({
    "node_modules/thirty-two/lib/thirty-two/index.js"(exports) {
      init_esbuild_inject();
      var base32 = require_thirty_two();
      exports.encode = base32.encode;
      exports.decode = base32.decode;
    }
  });

  // node_modules/bep53-range/index.js
  var require_bep53_range = __commonJS({
    "node_modules/bep53-range/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = parseRange;
      module.exports.parse = parseRange;
      module.exports.compose = composeRange;
      function composeRange(range) {
        return range.reduce((acc, cur, idx, arr) => {
          if (idx === 0 || cur !== arr[idx - 1] + 1)
            acc.push([]);
          acc[acc.length - 1].push(cur);
          return acc;
        }, []).map((cur) => {
          return cur.length > 1 ? `${cur[0]}-${cur[cur.length - 1]}` : `${cur[0]}`;
        });
      }
      function parseRange(range) {
        const generateRange = (start, end = start) => Array.from({ length: end - start + 1 }, (cur, idx) => idx + start);
        return range.reduce((acc, cur, idx, arr) => {
          const r = cur.split("-").map((cur2) => parseInt(cur2));
          return acc.concat(generateRange(...r));
        }, []);
      }
    }
  });

  // node_modules/magnet-uri/index.js
  var require_magnet_uri = __commonJS({
    "node_modules/magnet-uri/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = magnetURIDecode;
      module.exports.decode = magnetURIDecode;
      module.exports.encode = magnetURIEncode;
      var base32 = require_thirty_two2();
      var bep53Range = require_bep53_range();
      function magnetURIDecode(uri) {
        const result = {};
        const data = uri.split("magnet:?")[1];
        const params = data && data.length >= 0 ? data.split("&") : [];
        params.forEach((param) => {
          const keyval = param.split("=");
          if (keyval.length !== 2)
            return;
          const key = keyval[0];
          let val = keyval[1];
          if (key === "dn")
            val = decodeURIComponent(val).replace(/\+/g, " ");
          if (key === "tr" || key === "xs" || key === "as" || key === "ws") {
            val = decodeURIComponent(val);
          }
          if (key === "kt")
            val = decodeURIComponent(val).split("+");
          if (key === "ix")
            val = Number(val);
          if (key === "so")
            val = bep53Range.parse(decodeURIComponent(val).split(","));
          if (result[key]) {
            if (!Array.isArray(result[key])) {
              result[key] = [result[key]];
            }
            result[key].push(val);
          } else {
            result[key] = val;
          }
        });
        let m;
        if (result.xt) {
          const xts = Array.isArray(result.xt) ? result.xt : [result.xt];
          xts.forEach((xt) => {
            if (m = xt.match(/^urn:btih:(.{40})/)) {
              result.infoHash = m[1].toLowerCase();
            } else if (m = xt.match(/^urn:btih:(.{32})/)) {
              const decodedStr = base32.decode(m[1]);
              result.infoHash = Buffer3.from(decodedStr, "binary").toString("hex");
            } else if (m = xt.match(/^urn:btmh:1220(.{64})/)) {
              result.infoHashV2 = m[1].toLowerCase();
            }
          });
        }
        if (result.xs) {
          const xss = Array.isArray(result.xs) ? result.xs : [result.xs];
          xss.forEach((xs) => {
            if (m = xs.match(/^urn:btpk:(.{64})/)) {
              result.publicKey = m[1].toLowerCase();
            }
          });
        }
        if (result.infoHash)
          result.infoHashBuffer = Buffer3.from(result.infoHash, "hex");
        if (result.infoHashV2)
          result.infoHashV2Buffer = Buffer3.from(result.infoHashV2, "hex");
        if (result.publicKey)
          result.publicKeyBuffer = Buffer3.from(result.publicKey, "hex");
        if (result.dn)
          result.name = result.dn;
        if (result.kt)
          result.keywords = result.kt;
        result.announce = [];
        if (typeof result.tr === "string" || Array.isArray(result.tr)) {
          result.announce = result.announce.concat(result.tr);
        }
        result.urlList = [];
        if (typeof result.as === "string" || Array.isArray(result.as)) {
          result.urlList = result.urlList.concat(result.as);
        }
        if (typeof result.ws === "string" || Array.isArray(result.ws)) {
          result.urlList = result.urlList.concat(result.ws);
        }
        result.peerAddresses = [];
        if (typeof result["x.pe"] === "string" || Array.isArray(result["x.pe"])) {
          result.peerAddresses = result.peerAddresses.concat(result["x.pe"]);
        }
        result.announce = Array.from(new Set(result.announce));
        result.urlList = Array.from(new Set(result.urlList));
        result.peerAddresses = Array.from(new Set(result.peerAddresses));
        return result;
      }
      function magnetURIEncode(obj) {
        obj = Object.assign({}, obj);
        let xts = /* @__PURE__ */ new Set();
        if (obj.xt && typeof obj.xt === "string")
          xts.add(obj.xt);
        if (obj.xt && Array.isArray(obj.xt))
          xts = new Set(obj.xt);
        if (obj.infoHashBuffer)
          xts.add(`urn:btih:${obj.infoHashBuffer.toString("hex")}`);
        if (obj.infoHash)
          xts.add(`urn:btih:${obj.infoHash}`);
        if (obj.infoHashV2Buffer)
          xts.add(obj.xt = `urn:btmh:1220${obj.infoHashV2Buffer.toString("hex")}`);
        if (obj.infoHashV2)
          xts.add(`urn:btmh:1220${obj.infoHashV2}`);
        const xtsDeduped = Array.from(xts);
        if (xtsDeduped.length === 1)
          obj.xt = xtsDeduped[0];
        if (xtsDeduped.length > 1)
          obj.xt = xtsDeduped;
        if (obj.publicKeyBuffer)
          obj.xs = `urn:btpk:${obj.publicKeyBuffer.toString("hex")}`;
        if (obj.publicKey)
          obj.xs = `urn:btpk:${obj.publicKey}`;
        if (obj.name)
          obj.dn = obj.name;
        if (obj.keywords)
          obj.kt = obj.keywords;
        if (obj.announce)
          obj.tr = obj.announce;
        if (obj.urlList) {
          obj.ws = obj.urlList;
          delete obj.as;
        }
        if (obj.peerAddresses)
          obj["x.pe"] = obj.peerAddresses;
        let result = "magnet:?";
        Object.keys(obj).filter((key) => key.length === 2 || key === "x.pe").forEach((key, i) => {
          const values = Array.isArray(obj[key]) ? obj[key] : [obj[key]];
          values.forEach((val, j) => {
            if ((i > 0 || j > 0) && (key !== "kt" && key !== "so" || j === 0))
              result += "&";
            if (key === "dn")
              val = encodeURIComponent(val).replace(/%20/g, "+");
            if (key === "tr" || key === "as" || key === "ws") {
              val = encodeURIComponent(val);
            }
            if (key === "xs" && !val.startsWith("urn:btpk:")) {
              val = encodeURIComponent(val);
            }
            if (key === "kt")
              val = encodeURIComponent(val);
            if (key === "so")
              return;
            if (key === "kt" && j > 0)
              result += `+${val}`;
            else
              result += `${key}=${val}`;
          });
          if (key === "so")
            result += `${key}=${bep53Range.compose(values)}`;
        });
        return result;
      }
    }
  });

  // node_modules/parse-torrent/index.js
  var require_parse_torrent = __commonJS({
    "node_modules/parse-torrent/index.js"(exports, module) {
      init_esbuild_inject();
      var bencode = require_lib();
      var blobToBuffer = require_blob_to_buffer();
      var fs = require_fs();
      var get3 = require_simple_get();
      var magnet = require_magnet_uri();
      var path = require_path();
      var sha1 = require_browser4();
      var queueMicrotask2 = require_queue_microtask();
      module.exports = parseTorrent;
      module.exports.remote = parseTorrentRemote;
      module.exports.toMagnetURI = magnet.encode;
      module.exports.toTorrentFile = encodeTorrentFile;
      function parseTorrent(torrentId) {
        if (typeof torrentId === "string" && /^(stream-)?magnet:/.test(torrentId)) {
          const torrentObj = magnet(torrentId);
          if (!torrentObj.infoHash) {
            throw new Error("Invalid torrent identifier");
          }
          return torrentObj;
        } else if (typeof torrentId === "string" && (/^[a-f0-9]{40}$/i.test(torrentId) || /^[a-z2-7]{32}$/i.test(torrentId))) {
          return magnet(`magnet:?xt=urn:btih:${torrentId}`);
        } else if (Buffer3.isBuffer(torrentId) && torrentId.length === 20) {
          return magnet(`magnet:?xt=urn:btih:${torrentId.toString("hex")}`);
        } else if (Buffer3.isBuffer(torrentId)) {
          return decodeTorrentFile(torrentId);
        } else if (torrentId && torrentId.infoHash) {
          torrentId.infoHash = torrentId.infoHash.toLowerCase();
          if (!torrentId.announce)
            torrentId.announce = [];
          if (typeof torrentId.announce === "string") {
            torrentId.announce = [torrentId.announce];
          }
          if (!torrentId.urlList)
            torrentId.urlList = [];
          return torrentId;
        } else {
          throw new Error("Invalid torrent identifier");
        }
      }
      function parseTorrentRemote(torrentId, opts, cb) {
        if (typeof opts === "function")
          return parseTorrentRemote(torrentId, {}, opts);
        if (typeof cb !== "function")
          throw new Error("second argument must be a Function");
        let parsedTorrent;
        try {
          parsedTorrent = parseTorrent(torrentId);
        } catch (err) {
        }
        if (parsedTorrent && parsedTorrent.infoHash) {
          queueMicrotask2(() => {
            cb(null, parsedTorrent);
          });
        } else if (isBlob(torrentId)) {
          blobToBuffer(torrentId, (err, torrentBuf) => {
            if (err)
              return cb(new Error(`Error converting Blob: ${err.message}`));
            parseOrThrow(torrentBuf);
          });
        } else if (typeof get3 === "function" && /^https?:/.test(torrentId)) {
          opts = Object.assign({
            url: torrentId,
            timeout: 30 * 1e3,
            headers: { "user-agent": "WebTorrent (https://webtorrent.io)" }
          }, opts);
          get3.concat(opts, (err, res, torrentBuf) => {
            if (err)
              return cb(new Error(`Error downloading torrent: ${err.message}`));
            parseOrThrow(torrentBuf);
          });
        } else if (typeof fs.readFile === "function" && typeof torrentId === "string") {
          fs.readFile(torrentId, (err, torrentBuf) => {
            if (err)
              return cb(new Error("Invalid torrent identifier"));
            parseOrThrow(torrentBuf);
          });
        } else {
          queueMicrotask2(() => {
            cb(new Error("Invalid torrent identifier"));
          });
        }
        function parseOrThrow(torrentBuf) {
          try {
            parsedTorrent = parseTorrent(torrentBuf);
          } catch (err) {
            return cb(err);
          }
          if (parsedTorrent && parsedTorrent.infoHash)
            cb(null, parsedTorrent);
          else
            cb(new Error("Invalid torrent identifier"));
        }
      }
      function decodeTorrentFile(torrent) {
        if (Buffer3.isBuffer(torrent)) {
          torrent = bencode.decode(torrent);
        }
        ensure(torrent.info, "info");
        ensure(torrent.info["name.utf-8"] || torrent.info.name, "info.name");
        ensure(torrent.info["piece length"], "info['piece length']");
        ensure(torrent.info.pieces, "info.pieces");
        if (torrent.info.files) {
          torrent.info.files.forEach((file) => {
            ensure(typeof file.length === "number", "info.files[0].length");
            ensure(file["path.utf-8"] || file.path, "info.files[0].path");
          });
        } else {
          ensure(typeof torrent.info.length === "number", "info.length");
        }
        const result = {
          info: torrent.info,
          infoBuffer: bencode.encode(torrent.info),
          name: (torrent.info["name.utf-8"] || torrent.info.name).toString(),
          announce: []
        };
        result.infoHash = sha1.sync(result.infoBuffer);
        result.infoHashBuffer = Buffer3.from(result.infoHash, "hex");
        if (torrent.info.private !== void 0)
          result.private = !!torrent.info.private;
        if (torrent["creation date"])
          result.created = new Date(torrent["creation date"] * 1e3);
        if (torrent["created by"])
          result.createdBy = torrent["created by"].toString();
        if (Buffer3.isBuffer(torrent.comment))
          result.comment = torrent.comment.toString();
        if (Array.isArray(torrent["announce-list"]) && torrent["announce-list"].length > 0) {
          torrent["announce-list"].forEach((urls) => {
            urls.forEach((url) => {
              result.announce.push(url.toString());
            });
          });
        } else if (torrent.announce) {
          result.announce.push(torrent.announce.toString());
        }
        if (Buffer3.isBuffer(torrent["url-list"])) {
          torrent["url-list"] = torrent["url-list"].length > 0 ? [torrent["url-list"]] : [];
        }
        result.urlList = (torrent["url-list"] || []).map((url) => url.toString());
        result.announce = Array.from(new Set(result.announce));
        result.urlList = Array.from(new Set(result.urlList));
        const files = torrent.info.files || [torrent.info];
        result.files = files.map((file, i) => {
          const parts = [].concat(result.name, file["path.utf-8"] || file.path || []).map((p) => p.toString());
          return {
            path: path.join.apply(null, [path.sep].concat(parts)).slice(1),
            name: parts[parts.length - 1],
            length: file.length,
            offset: files.slice(0, i).reduce(sumLength, 0)
          };
        });
        result.length = files.reduce(sumLength, 0);
        const lastFile = result.files[result.files.length - 1];
        result.pieceLength = torrent.info["piece length"];
        result.lastPieceLength = (lastFile.offset + lastFile.length) % result.pieceLength || result.pieceLength;
        result.pieces = splitPieces(torrent.info.pieces);
        return result;
      }
      function encodeTorrentFile(parsed) {
        const torrent = {
          info: parsed.info
        };
        torrent["announce-list"] = (parsed.announce || []).map((url) => {
          if (!torrent.announce)
            torrent.announce = url;
          url = Buffer3.from(url, "utf8");
          return [url];
        });
        torrent["url-list"] = parsed.urlList || [];
        if (parsed.private !== void 0) {
          torrent.private = Number(parsed.private);
        }
        if (parsed.created) {
          torrent["creation date"] = parsed.created.getTime() / 1e3 | 0;
        }
        if (parsed.createdBy) {
          torrent["created by"] = parsed.createdBy;
        }
        if (parsed.comment) {
          torrent.comment = parsed.comment;
        }
        return bencode.encode(torrent);
      }
      function isBlob(obj) {
        return typeof Blob !== "undefined" && obj instanceof Blob;
      }
      function sumLength(sum, file) {
        return sum + file.length;
      }
      function splitPieces(buf) {
        const pieces = [];
        for (let i = 0; i < buf.length; i += 20) {
          pieces.push(buf.slice(i, i + 20).toString("hex"));
        }
        return pieces;
      }
      function ensure(bool, fieldName) {
        if (!bool)
          throw new Error(`Torrent is missing required field: ${fieldName}`);
      }
      (() => {
        Buffer3.alloc(0);
      })();
    }
  });

  // node_modules/get-browser-rtc/index.js
  var require_get_browser_rtc = __commonJS({
    "node_modules/get-browser-rtc/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function getBrowserRTC() {
        if (typeof globalThis === "undefined")
          return null;
        var wrtc = {
          RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
          RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
          RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
        };
        if (!wrtc.RTCPeerConnection)
          return null;
        return wrtc;
      };
    }
  });

  // node_modules/randombytes/browser.js
  var require_browser6 = __commonJS({
    "node_modules/randombytes/browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var MAX_BYTES = 65536;
      var MAX_UINT32 = 4294967295;
      function oldBrowser() {
        throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
      }
      var Buffer4 = require_safe_buffer().Buffer;
      var crypto = globalThis.crypto || globalThis.msCrypto;
      if (crypto && crypto.getRandomValues) {
        module.exports = randomBytes;
      } else {
        module.exports = oldBrowser;
      }
      function randomBytes(size, cb) {
        if (size > MAX_UINT32)
          throw new RangeError("requested too many random bytes");
        var bytes = Buffer4.allocUnsafe(size);
        if (size > 0) {
          if (size > MAX_BYTES) {
            for (var generated = 0; generated < size; generated += MAX_BYTES) {
              crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
            }
          } else {
            crypto.getRandomValues(bytes);
          }
        }
        if (typeof cb === "function") {
          return process.nextTick(function() {
            cb(null, bytes);
          });
        }
        return bytes;
      }
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/errors-browser.js
  var require_errors_browser5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser5().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser5();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy5();
      var _require = require_state5();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser5().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex5();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex5();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable5();
      var Writable2 = require_stream_writable5();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser5().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream5();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser5();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list5();
      var destroyImpl = require_destroy5();
      var _require = require_state5();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser5().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex5();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex5();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator5();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser5();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser5().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex5();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform5();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser5().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream5();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/simple-peer/node_modules/readable-stream/readable-browser.js
  var require_readable_browser5 = __commonJS({
    "node_modules/simple-peer/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable5();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable5();
      exports.Duplex = require_stream_duplex5();
      exports.Transform = require_stream_transform5();
      exports.PassThrough = require_stream_passthrough5();
      exports.finished = require_end_of_stream5();
      exports.pipeline = require_pipeline5();
    }
  });

  // node_modules/err-code/index.js
  var require_err_code = __commonJS({
    "node_modules/err-code/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function assign(obj, props) {
        for (const key in props) {
          Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true
          });
        }
        return obj;
      }
      function createError(err, code, props) {
        if (!err || typeof err === "string") {
          throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
          props = {};
        }
        if (typeof code === "object") {
          props = code;
          code = "";
        }
        if (code) {
          props.code = code;
        }
        try {
          return assign(err, props);
        } catch (_) {
          props.message = err.message;
          props.stack = err.stack;
          const ErrClass = function() {
          };
          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
          const output = assign(new ErrClass(), props);
          return output;
        }
      }
      module.exports = createError;
    }
  });

  // node_modules/simple-peer/index.js
  var require_simple_peer = __commonJS({
    "node_modules/simple-peer/index.js"(exports, module) {
      init_esbuild_inject();
      var debug2 = require_browser5()("simple-peer");
      var getBrowserRTC = require_get_browser_rtc();
      var randombytes = require_browser6();
      var stream = require_readable_browser5();
      var queueMicrotask2 = require_queue_microtask();
      var errCode = require_err_code();
      var { Buffer: Buffer4 } = require_buffer();
      var MAX_BUFFERED_AMOUNT = 64 * 1024;
      var ICECOMPLETE_TIMEOUT = 5 * 1e3;
      var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
      function filterTrickle(sdp) {
        return sdp.replace(/a=ice-options:trickle\s\n/g, "");
      }
      function warn(message) {
        console.warn(message);
      }
      var Peer = class extends stream.Duplex {
        constructor(opts) {
          opts = Object.assign({
            allowHalfOpen: false
          }, opts);
          super(opts);
          this._id = randombytes(4).toString("hex").slice(0, 7);
          this._debug("new peer %o", opts);
          this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
          this.initiator = opts.initiator || false;
          this.channelConfig = opts.channelConfig || Peer.channelConfig;
          this.channelNegotiated = this.channelConfig.negotiated;
          this.config = Object.assign({}, Peer.config, opts.config);
          this.offerOptions = opts.offerOptions || {};
          this.answerOptions = opts.answerOptions || {};
          this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
          this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
          this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
          this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
          this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
          this.destroyed = false;
          this.destroying = false;
          this._connected = false;
          this.remoteAddress = void 0;
          this.remoteFamily = void 0;
          this.remotePort = void 0;
          this.localAddress = void 0;
          this.localFamily = void 0;
          this.localPort = void 0;
          this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
          if (!this._wrtc) {
            if (typeof window === "undefined") {
              throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
            } else {
              throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
            }
          }
          this._pcReady = false;
          this._channelReady = false;
          this._iceComplete = false;
          this._iceCompleteTimer = null;
          this._channel = null;
          this._pendingCandidates = [];
          this._isNegotiating = false;
          this._firstNegotiation = true;
          this._batchedNegotiation = false;
          this._queuedNegotiation = false;
          this._sendersAwaitingStable = [];
          this._senderMap = /* @__PURE__ */ new Map();
          this._closingInterval = null;
          this._remoteTracks = [];
          this._remoteStreams = [];
          this._chunk = null;
          this._cb = null;
          this._interval = null;
          try {
            this._pc = new this._wrtc.RTCPeerConnection(this.config);
          } catch (err) {
            this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
            return;
          }
          this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
          this._pc.oniceconnectionstatechange = () => {
            this._onIceStateChange();
          };
          this._pc.onicegatheringstatechange = () => {
            this._onIceStateChange();
          };
          this._pc.onconnectionstatechange = () => {
            this._onConnectionStateChange();
          };
          this._pc.onsignalingstatechange = () => {
            this._onSignalingStateChange();
          };
          this._pc.onicecandidate = (event) => {
            this._onIceCandidate(event);
          };
          if (typeof this._pc.peerIdentity === "object") {
            this._pc.peerIdentity.catch((err) => {
              this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
            });
          }
          if (this.initiator || this.channelNegotiated) {
            this._setupData({
              channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
            });
          } else {
            this._pc.ondatachannel = (event) => {
              this._setupData(event);
            };
          }
          if (this.streams) {
            this.streams.forEach((stream2) => {
              this.addStream(stream2);
            });
          }
          this._pc.ontrack = (event) => {
            this._onTrack(event);
          };
          this._debug("initial negotiation");
          this._needsNegotiation();
          this._onFinishBound = () => {
            this._onFinish();
          };
          this.once("finish", this._onFinishBound);
        }
        get bufferSize() {
          return this._channel && this._channel.bufferedAmount || 0;
        }
        get connected() {
          return this._connected && this._channel.readyState === "open";
        }
        address() {
          return { port: this.localPort, family: this.localFamily, address: this.localAddress };
        }
        signal(data) {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
          if (typeof data === "string") {
            try {
              data = JSON.parse(data);
            } catch (err) {
              data = {};
            }
          }
          this._debug("signal()");
          if (data.renegotiate && this.initiator) {
            this._debug("got request to renegotiate");
            this._needsNegotiation();
          }
          if (data.transceiverRequest && this.initiator) {
            this._debug("got request for transceiver");
            this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
          }
          if (data.candidate) {
            if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
              this._addIceCandidate(data.candidate);
            } else {
              this._pendingCandidates.push(data.candidate);
            }
          }
          if (data.sdp) {
            this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
              if (this.destroyed)
                return;
              this._pendingCandidates.forEach((candidate) => {
                this._addIceCandidate(candidate);
              });
              this._pendingCandidates = [];
              if (this._pc.remoteDescription.type === "offer")
                this._createAnswer();
            }).catch((err) => {
              this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
            });
          }
          if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
            this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
          }
        }
        _addIceCandidate(candidate) {
          const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
          this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
            if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
              warn("Ignoring unsupported ICE candidate.");
            } else {
              this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
            }
          });
        }
        send(chunk) {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
          this._channel.send(chunk);
        }
        addTransceiver(kind, init2) {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
          this._debug("addTransceiver()");
          if (this.initiator) {
            try {
              this._pc.addTransceiver(kind, init2);
              this._needsNegotiation();
            } catch (err) {
              this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
            }
          } else {
            this.emit("signal", {
              type: "transceiverRequest",
              transceiverRequest: { kind, init: init2 }
            });
          }
        }
        addStream(stream2) {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
          this._debug("addStream()");
          stream2.getTracks().forEach((track) => {
            this.addTrack(track, stream2);
          });
        }
        addTrack(track, stream2) {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
          this._debug("addTrack()");
          const submap = this._senderMap.get(track) || /* @__PURE__ */ new Map();
          let sender = submap.get(stream2);
          if (!sender) {
            sender = this._pc.addTrack(track, stream2);
            submap.set(stream2, sender);
            this._senderMap.set(track, submap);
            this._needsNegotiation();
          } else if (sender.removed) {
            throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
          } else {
            throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
          }
        }
        replaceTrack(oldTrack, newTrack, stream2) {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
          this._debug("replaceTrack()");
          const submap = this._senderMap.get(oldTrack);
          const sender = submap ? submap.get(stream2) : null;
          if (!sender) {
            throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
          }
          if (newTrack)
            this._senderMap.set(newTrack, submap);
          if (sender.replaceTrack != null) {
            sender.replaceTrack(newTrack);
          } else {
            this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
          }
        }
        removeTrack(track, stream2) {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
          this._debug("removeSender()");
          const submap = this._senderMap.get(track);
          const sender = submap ? submap.get(stream2) : null;
          if (!sender) {
            throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
          }
          try {
            sender.removed = true;
            this._pc.removeTrack(sender);
          } catch (err) {
            if (err.name === "NS_ERROR_UNEXPECTED") {
              this._sendersAwaitingStable.push(sender);
            } else {
              this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
            }
          }
          this._needsNegotiation();
        }
        removeStream(stream2) {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
          this._debug("removeSenders()");
          stream2.getTracks().forEach((track) => {
            this.removeTrack(track, stream2);
          });
        }
        _needsNegotiation() {
          this._debug("_needsNegotiation");
          if (this._batchedNegotiation)
            return;
          this._batchedNegotiation = true;
          queueMicrotask2(() => {
            this._batchedNegotiation = false;
            if (this.initiator || !this._firstNegotiation) {
              this._debug("starting batched negotiation");
              this.negotiate();
            } else {
              this._debug("non-initiator initial negotiation request discarded");
            }
            this._firstNegotiation = false;
          });
        }
        negotiate() {
          if (this.destroying)
            return;
          if (this.destroyed)
            throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
          if (this.initiator) {
            if (this._isNegotiating) {
              this._queuedNegotiation = true;
              this._debug("already negotiating, queueing");
            } else {
              this._debug("start negotiation");
              setTimeout(() => {
                this._createOffer();
              }, 0);
            }
          } else {
            if (this._isNegotiating) {
              this._queuedNegotiation = true;
              this._debug("already negotiating, queueing");
            } else {
              this._debug("requesting negotiation from initiator");
              this.emit("signal", {
                type: "renegotiate",
                renegotiate: true
              });
            }
          }
          this._isNegotiating = true;
        }
        destroy(err) {
          this._destroy(err, () => {
          });
        }
        _destroy(err, cb) {
          if (this.destroyed || this.destroying)
            return;
          this.destroying = true;
          this._debug("destroying (error: %s)", err && (err.message || err));
          queueMicrotask2(() => {
            this.destroyed = true;
            this.destroying = false;
            this._debug("destroy (error: %s)", err && (err.message || err));
            this.readable = this.writable = false;
            if (!this._readableState.ended)
              this.push(null);
            if (!this._writableState.finished)
              this.end();
            this._connected = false;
            this._pcReady = false;
            this._channelReady = false;
            this._remoteTracks = null;
            this._remoteStreams = null;
            this._senderMap = null;
            clearInterval(this._closingInterval);
            this._closingInterval = null;
            clearInterval(this._interval);
            this._interval = null;
            this._chunk = null;
            this._cb = null;
            if (this._onFinishBound)
              this.removeListener("finish", this._onFinishBound);
            this._onFinishBound = null;
            if (this._channel) {
              try {
                this._channel.close();
              } catch (err2) {
              }
              this._channel.onmessage = null;
              this._channel.onopen = null;
              this._channel.onclose = null;
              this._channel.onerror = null;
            }
            if (this._pc) {
              try {
                this._pc.close();
              } catch (err2) {
              }
              this._pc.oniceconnectionstatechange = null;
              this._pc.onicegatheringstatechange = null;
              this._pc.onsignalingstatechange = null;
              this._pc.onicecandidate = null;
              this._pc.ontrack = null;
              this._pc.ondatachannel = null;
            }
            this._pc = null;
            this._channel = null;
            if (err)
              this.emit("error", err);
            this.emit("close");
            cb();
          });
        }
        _setupData(event) {
          if (!event.channel) {
            return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
          }
          this._channel = event.channel;
          this._channel.binaryType = "arraybuffer";
          if (typeof this._channel.bufferedAmountLowThreshold === "number") {
            this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
          }
          this.channelName = this._channel.label;
          this._channel.onmessage = (event2) => {
            this._onChannelMessage(event2);
          };
          this._channel.onbufferedamountlow = () => {
            this._onChannelBufferedAmountLow();
          };
          this._channel.onopen = () => {
            this._onChannelOpen();
          };
          this._channel.onclose = () => {
            this._onChannelClose();
          };
          this._channel.onerror = (event2) => {
            const err = event2.error instanceof Error ? event2.error : new Error(`Datachannel error: ${event2.message} ${event2.filename}:${event2.lineno}:${event2.colno}`);
            this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
          };
          let isClosing = false;
          this._closingInterval = setInterval(() => {
            if (this._channel && this._channel.readyState === "closing") {
              if (isClosing)
                this._onChannelClose();
              isClosing = true;
            } else {
              isClosing = false;
            }
          }, CHANNEL_CLOSING_TIMEOUT);
        }
        _read() {
        }
        _write(chunk, encoding, cb) {
          if (this.destroyed)
            return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
          if (this._connected) {
            try {
              this.send(chunk);
            } catch (err) {
              return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
            }
            if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
              this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
              this._cb = cb;
            } else {
              cb(null);
            }
          } else {
            this._debug("write before connect");
            this._chunk = chunk;
            this._cb = cb;
          }
        }
        _onFinish() {
          if (this.destroyed)
            return;
          const destroySoon = () => {
            setTimeout(() => this.destroy(), 1e3);
          };
          if (this._connected) {
            destroySoon();
          } else {
            this.once("connect", destroySoon);
          }
        }
        _startIceCompleteTimeout() {
          if (this.destroyed)
            return;
          if (this._iceCompleteTimer)
            return;
          this._debug("started iceComplete timeout");
          this._iceCompleteTimer = setTimeout(() => {
            if (!this._iceComplete) {
              this._iceComplete = true;
              this._debug("iceComplete timeout completed");
              this.emit("iceTimeout");
              this.emit("_iceComplete");
            }
          }, this.iceCompleteTimeout);
        }
        _createOffer() {
          if (this.destroyed)
            return;
          this._pc.createOffer(this.offerOptions).then((offer) => {
            if (this.destroyed)
              return;
            if (!this.trickle && !this.allowHalfTrickle)
              offer.sdp = filterTrickle(offer.sdp);
            offer.sdp = this.sdpTransform(offer.sdp);
            const sendOffer = () => {
              if (this.destroyed)
                return;
              const signal = this._pc.localDescription || offer;
              this._debug("signal");
              this.emit("signal", {
                type: signal.type,
                sdp: signal.sdp
              });
            };
            const onSuccess = () => {
              this._debug("createOffer success");
              if (this.destroyed)
                return;
              if (this.trickle || this._iceComplete)
                sendOffer();
              else
                this.once("_iceComplete", sendOffer);
            };
            const onError = (err) => {
              this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
            };
            this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
          }).catch((err) => {
            this.destroy(errCode(err, "ERR_CREATE_OFFER"));
          });
        }
        _requestMissingTransceivers() {
          if (this._pc.getTransceivers) {
            this._pc.getTransceivers().forEach((transceiver) => {
              if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
                transceiver.requested = true;
                this.addTransceiver(transceiver.sender.track.kind);
              }
            });
          }
        }
        _createAnswer() {
          if (this.destroyed)
            return;
          this._pc.createAnswer(this.answerOptions).then((answer) => {
            if (this.destroyed)
              return;
            if (!this.trickle && !this.allowHalfTrickle)
              answer.sdp = filterTrickle(answer.sdp);
            answer.sdp = this.sdpTransform(answer.sdp);
            const sendAnswer = () => {
              if (this.destroyed)
                return;
              const signal = this._pc.localDescription || answer;
              this._debug("signal");
              this.emit("signal", {
                type: signal.type,
                sdp: signal.sdp
              });
              if (!this.initiator)
                this._requestMissingTransceivers();
            };
            const onSuccess = () => {
              if (this.destroyed)
                return;
              if (this.trickle || this._iceComplete)
                sendAnswer();
              else
                this.once("_iceComplete", sendAnswer);
            };
            const onError = (err) => {
              this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
            };
            this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
          }).catch((err) => {
            this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
          });
        }
        _onConnectionStateChange() {
          if (this.destroyed)
            return;
          if (this._pc.connectionState === "failed") {
            this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
          }
        }
        _onIceStateChange() {
          if (this.destroyed)
            return;
          const iceConnectionState = this._pc.iceConnectionState;
          const iceGatheringState = this._pc.iceGatheringState;
          this._debug("iceStateChange (connection: %s) (gathering: %s)", iceConnectionState, iceGatheringState);
          this.emit("iceStateChange", iceConnectionState, iceGatheringState);
          if (iceConnectionState === "connected" || iceConnectionState === "completed") {
            this._pcReady = true;
            this._maybeReady();
          }
          if (iceConnectionState === "failed") {
            this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
          }
          if (iceConnectionState === "closed") {
            this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
          }
        }
        getStats(cb) {
          const flattenValues = (report) => {
            if (Object.prototype.toString.call(report.values) === "[object Array]") {
              report.values.forEach((value) => {
                Object.assign(report, value);
              });
            }
            return report;
          };
          if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
            this._pc.getStats().then((res) => {
              const reports = [];
              res.forEach((report) => {
                reports.push(flattenValues(report));
              });
              cb(null, reports);
            }, (err) => cb(err));
          } else if (this._pc.getStats.length > 0) {
            this._pc.getStats((res) => {
              if (this.destroyed)
                return;
              const reports = [];
              res.result().forEach((result) => {
                const report = {};
                result.names().forEach((name) => {
                  report[name] = result.stat(name);
                });
                report.id = result.id;
                report.type = result.type;
                report.timestamp = result.timestamp;
                reports.push(flattenValues(report));
              });
              cb(null, reports);
            }, (err) => cb(err));
          } else {
            cb(null, []);
          }
        }
        _maybeReady() {
          this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
          if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
            return;
          this._connecting = true;
          const findCandidatePair = () => {
            if (this.destroyed)
              return;
            this.getStats((err, items) => {
              if (this.destroyed)
                return;
              if (err)
                items = [];
              const remoteCandidates = {};
              const localCandidates = {};
              const candidatePairs = {};
              let foundSelectedCandidatePair = false;
              items.forEach((item) => {
                if (item.type === "remotecandidate" || item.type === "remote-candidate") {
                  remoteCandidates[item.id] = item;
                }
                if (item.type === "localcandidate" || item.type === "local-candidate") {
                  localCandidates[item.id] = item;
                }
                if (item.type === "candidatepair" || item.type === "candidate-pair") {
                  candidatePairs[item.id] = item;
                }
              });
              const setSelectedCandidatePair = (selectedCandidatePair) => {
                foundSelectedCandidatePair = true;
                let local = localCandidates[selectedCandidatePair.localCandidateId];
                if (local && (local.ip || local.address)) {
                  this.localAddress = local.ip || local.address;
                  this.localPort = Number(local.port);
                } else if (local && local.ipAddress) {
                  this.localAddress = local.ipAddress;
                  this.localPort = Number(local.portNumber);
                } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                  local = selectedCandidatePair.googLocalAddress.split(":");
                  this.localAddress = local[0];
                  this.localPort = Number(local[1]);
                }
                if (this.localAddress) {
                  this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
                }
                let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
                if (remote && (remote.ip || remote.address)) {
                  this.remoteAddress = remote.ip || remote.address;
                  this.remotePort = Number(remote.port);
                } else if (remote && remote.ipAddress) {
                  this.remoteAddress = remote.ipAddress;
                  this.remotePort = Number(remote.portNumber);
                } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                  remote = selectedCandidatePair.googRemoteAddress.split(":");
                  this.remoteAddress = remote[0];
                  this.remotePort = Number(remote[1]);
                }
                if (this.remoteAddress) {
                  this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
                }
                this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
              };
              items.forEach((item) => {
                if (item.type === "transport" && item.selectedCandidatePairId) {
                  setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
                }
                if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
                  setSelectedCandidatePair(item);
                }
              });
              if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
                setTimeout(findCandidatePair, 100);
                return;
              } else {
                this._connecting = false;
                this._connected = true;
              }
              if (this._chunk) {
                try {
                  this.send(this._chunk);
                } catch (err2) {
                  return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
                }
                this._chunk = null;
                this._debug('sent chunk from "write before connect"');
                const cb = this._cb;
                this._cb = null;
                cb(null);
              }
              if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
                this._interval = setInterval(() => this._onInterval(), 150);
                if (this._interval.unref)
                  this._interval.unref();
              }
              this._debug("connect");
              this.emit("connect");
            });
          };
          findCandidatePair();
        }
        _onInterval() {
          if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
            return;
          }
          this._onChannelBufferedAmountLow();
        }
        _onSignalingStateChange() {
          if (this.destroyed)
            return;
          if (this._pc.signalingState === "stable") {
            this._isNegotiating = false;
            this._debug("flushing sender queue", this._sendersAwaitingStable);
            this._sendersAwaitingStable.forEach((sender) => {
              this._pc.removeTrack(sender);
              this._queuedNegotiation = true;
            });
            this._sendersAwaitingStable = [];
            if (this._queuedNegotiation) {
              this._debug("flushing negotiation queue");
              this._queuedNegotiation = false;
              this._needsNegotiation();
            } else {
              this._debug("negotiated");
              this.emit("negotiated");
            }
          }
          this._debug("signalingStateChange %s", this._pc.signalingState);
          this.emit("signalingStateChange", this._pc.signalingState);
        }
        _onIceCandidate(event) {
          if (this.destroyed)
            return;
          if (event.candidate && this.trickle) {
            this.emit("signal", {
              type: "candidate",
              candidate: {
                candidate: event.candidate.candidate,
                sdpMLineIndex: event.candidate.sdpMLineIndex,
                sdpMid: event.candidate.sdpMid
              }
            });
          } else if (!event.candidate && !this._iceComplete) {
            this._iceComplete = true;
            this.emit("_iceComplete");
          }
          if (event.candidate) {
            this._startIceCompleteTimeout();
          }
        }
        _onChannelMessage(event) {
          if (this.destroyed)
            return;
          let data = event.data;
          if (data instanceof ArrayBuffer)
            data = Buffer4.from(data);
          this.push(data);
        }
        _onChannelBufferedAmountLow() {
          if (this.destroyed || !this._cb)
            return;
          this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
          const cb = this._cb;
          this._cb = null;
          cb(null);
        }
        _onChannelOpen() {
          if (this._connected || this.destroyed)
            return;
          this._debug("on channel open");
          this._channelReady = true;
          this._maybeReady();
        }
        _onChannelClose() {
          if (this.destroyed)
            return;
          this._debug("on channel close");
          this.destroy();
        }
        _onTrack(event) {
          if (this.destroyed)
            return;
          event.streams.forEach((eventStream) => {
            this._debug("on track");
            this.emit("track", event.track, eventStream);
            this._remoteTracks.push({
              track: event.track,
              stream: eventStream
            });
            if (this._remoteStreams.some((remoteStream) => {
              return remoteStream.id === eventStream.id;
            }))
              return;
            this._remoteStreams.push(eventStream);
            queueMicrotask2(() => {
              this._debug("on stream");
              this.emit("stream", eventStream);
            });
          });
        }
        _debug() {
          const args = [].slice.call(arguments);
          args[0] = "[" + this._id + "] " + args[0];
          debug2.apply(null, args);
        }
      };
      Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
      Peer.config = {
        iceServers: [
          {
            urls: [
              "stun:stun.l.google.com:19302",
              "stun:global.stun.twilio.com:3478"
            ]
          }
        ],
        sdpSemantics: "unified-plan"
      };
      Peer.channelConfig = {};
      module.exports = Peer;
    }
  });

  // node_modules/throughput/index.js
  var require_throughput = __commonJS({
    "node_modules/throughput/index.js"(exports, module) {
      init_esbuild_inject();
      var maxTick = 65535;
      var resolution = 10;
      var timeDiff = 1e3 / resolution;
      function getTick(start) {
        return (+Date.now() - start) / timeDiff & 65535;
      }
      module.exports = function(seconds) {
        const start = +Date.now();
        const size = resolution * (seconds || 5);
        const buffer = [0];
        let pointer = 1;
        let last = getTick(start) - 1 & maxTick;
        return function(delta) {
          const tick = getTick(start);
          let dist = tick - last & maxTick;
          if (dist > size)
            dist = size;
          last = tick;
          while (dist--) {
            if (pointer === size)
              pointer = 0;
            buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
            pointer++;
          }
          if (delta)
            buffer[pointer - 1] += delta;
          const top = buffer[pointer - 1];
          const btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
          return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
        };
      };
    }
  });

  // node_modules/queue-tick/queue-microtask.js
  var require_queue_microtask2 = __commonJS({
    "node_modules/queue-tick/queue-microtask.js"(exports, module) {
      init_esbuild_inject();
      module.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
    }
  });

  // node_modules/fast-fifo/fixed-size.js
  var require_fixed_size = __commonJS({
    "node_modules/fast-fifo/fixed-size.js"(exports, module) {
      init_esbuild_inject();
      module.exports = class FixedFIFO {
        constructor(hwm) {
          if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
            throw new Error("Max size for a FixedFIFO should be a power of two");
          this.buffer = new Array(hwm);
          this.mask = hwm - 1;
          this.top = 0;
          this.btm = 0;
          this.next = null;
        }
        push(data) {
          if (this.buffer[this.top] !== void 0)
            return false;
          this.buffer[this.top] = data;
          this.top = this.top + 1 & this.mask;
          return true;
        }
        shift() {
          const last = this.buffer[this.btm];
          if (last === void 0)
            return void 0;
          this.buffer[this.btm] = void 0;
          this.btm = this.btm + 1 & this.mask;
          return last;
        }
        peek() {
          return this.buffer[this.btm];
        }
        isEmpty() {
          return this.buffer[this.btm] === void 0;
        }
      };
    }
  });

  // node_modules/fast-fifo/index.js
  var require_fast_fifo = __commonJS({
    "node_modules/fast-fifo/index.js"(exports, module) {
      init_esbuild_inject();
      var FixedFIFO = require_fixed_size();
      module.exports = class FastFIFO {
        constructor(hwm) {
          this.hwm = hwm || 16;
          this.head = new FixedFIFO(this.hwm);
          this.tail = this.head;
        }
        push(val) {
          if (!this.head.push(val)) {
            const prev = this.head;
            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
            this.head.push(val);
          }
        }
        shift() {
          const val = this.tail.shift();
          if (val === void 0 && this.tail.next) {
            const next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            return this.tail.shift();
          }
          return val;
        }
        peek() {
          return this.tail.peek();
        }
        isEmpty() {
          return this.head.isEmpty();
        }
      };
    }
  });

  // node_modules/streamx/index.js
  var require_streamx = __commonJS({
    "node_modules/streamx/index.js"(exports, module) {
      init_esbuild_inject();
      var { EventEmitter: EventEmitter2 } = require_events();
      var STREAM_DESTROYED = new Error("Stream was destroyed");
      var PREMATURE_CLOSE = new Error("Premature close");
      var queueTick = require_queue_microtask2();
      var FIFO = require_fast_fifo();
      var MAX = (1 << 25) - 1;
      var OPENING = 1;
      var DESTROYING = 2;
      var DESTROYED = 4;
      var NOT_OPENING = MAX ^ OPENING;
      var READ_ACTIVE = 1 << 3;
      var READ_PRIMARY = 2 << 3;
      var READ_SYNC = 4 << 3;
      var READ_QUEUED = 8 << 3;
      var READ_RESUMED = 16 << 3;
      var READ_PIPE_DRAINED = 32 << 3;
      var READ_ENDING = 64 << 3;
      var READ_EMIT_DATA = 128 << 3;
      var READ_EMIT_READABLE = 256 << 3;
      var READ_EMITTED_READABLE = 512 << 3;
      var READ_DONE = 1024 << 3;
      var READ_NEXT_TICK = 2049 << 3;
      var READ_NEEDS_PUSH = 4096 << 3;
      var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
      var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
      var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
      var READ_NOT_SYNC = MAX ^ READ_SYNC;
      var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
      var READ_PAUSED = MAX ^ READ_RESUMED;
      var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
      var READ_NOT_ENDING = MAX ^ READ_ENDING;
      var READ_PIPE_NOT_DRAINED = MAX ^ (READ_RESUMED | READ_PIPE_DRAINED);
      var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
      var WRITE_ACTIVE = 1 << 16;
      var WRITE_PRIMARY = 2 << 16;
      var WRITE_SYNC = 4 << 16;
      var WRITE_QUEUED = 8 << 16;
      var WRITE_UNDRAINED = 16 << 16;
      var WRITE_DONE = 32 << 16;
      var WRITE_EMIT_DRAIN = 64 << 16;
      var WRITE_NEXT_TICK = 129 << 16;
      var WRITE_FINISHING = 256 << 16;
      var WRITE_NOT_ACTIVE = MAX ^ WRITE_ACTIVE;
      var WRITE_NOT_SYNC = MAX ^ WRITE_SYNC;
      var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
      var WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;
      var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
      var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
      var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
      var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
      var NOT_ACTIVE = MAX ^ ACTIVE;
      var DONE = READ_DONE | WRITE_DONE;
      var DESTROY_STATUS = DESTROYING | DESTROYED;
      var OPEN_STATUS = DESTROY_STATUS | OPENING;
      var AUTO_DESTROY = DESTROY_STATUS | DONE;
      var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
      var TICKING = (WRITE_NEXT_TICK | READ_NEXT_TICK) & NOT_ACTIVE;
      var ACTIVE_OR_TICKING = ACTIVE | TICKING;
      var IS_OPENING = OPEN_STATUS | TICKING;
      var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
      var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
      var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
      var READ_ACTIVE_AND_SYNC = READ_ACTIVE | READ_SYNC;
      var READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH = READ_ACTIVE | READ_SYNC | READ_NEEDS_PUSH;
      var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
      var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
      var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
      var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
      var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH;
      var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
      var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
      var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
      var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
      var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
      var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED;
      var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
      var WRITE_ACTIVE_AND_SYNC = WRITE_ACTIVE | WRITE_SYNC;
      var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
      var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
      var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");
      var WritableState2 = class {
        constructor(stream, { highWaterMark = 16384, map: map3 = null, mapWritable, byteLength: byteLength2, byteLengthWritable } = {}) {
          this.stream = stream;
          this.queue = new FIFO();
          this.highWaterMark = highWaterMark;
          this.buffered = 0;
          this.error = null;
          this.pipeline = null;
          this.byteLength = byteLengthWritable || byteLength2 || defaultByteLength;
          this.map = mapWritable || map3;
          this.afterWrite = afterWrite2.bind(this);
          this.afterUpdateNextTick = updateWriteNT.bind(this);
        }
        get ended() {
          return (this.stream._duplexState & WRITE_DONE) !== 0;
        }
        push(data) {
          if (this.map !== null)
            data = this.map(data);
          this.buffered += this.byteLength(data);
          this.queue.push(data);
          if (this.buffered < this.highWaterMark) {
            this.stream._duplexState |= WRITE_QUEUED;
            return true;
          }
          this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
          return false;
        }
        shift() {
          const data = this.queue.shift();
          const stream = this.stream;
          this.buffered -= this.byteLength(data);
          if (this.buffered === 0)
            stream._duplexState &= WRITE_NOT_QUEUED;
          return data;
        }
        end(data) {
          if (typeof data === "function")
            this.stream.once("finish", data);
          else if (data !== void 0 && data !== null)
            this.push(data);
          this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
        }
        autoBatch(data, cb) {
          const buffer = [];
          const stream = this.stream;
          buffer.push(data);
          while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
            buffer.push(stream._writableState.shift());
          }
          if ((stream._duplexState & OPEN_STATUS) !== 0)
            return cb(null);
          stream._writev(buffer, cb);
        }
        update() {
          const stream = this.stream;
          while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
            const data = this.shift();
            stream._duplexState |= WRITE_ACTIVE_AND_SYNC;
            stream._write(data, this.afterWrite);
            stream._duplexState &= WRITE_NOT_SYNC;
          }
          if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0)
            this.updateNonPrimary();
        }
        updateNonPrimary() {
          const stream = this.stream;
          if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
            stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;
            stream._final(afterFinal.bind(this));
            return;
          }
          if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
            if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
              stream._duplexState |= ACTIVE;
              stream._destroy(afterDestroy.bind(this));
            }
            return;
          }
          if ((stream._duplexState & IS_OPENING) === OPENING) {
            stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
            stream._open(afterOpen.bind(this));
          }
        }
        updateNextTick() {
          if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0)
            return;
          this.stream._duplexState |= WRITE_NEXT_TICK;
          queueTick(this.afterUpdateNextTick);
        }
      };
      var ReadableState2 = class {
        constructor(stream, { highWaterMark = 16384, map: map3 = null, mapReadable, byteLength: byteLength2, byteLengthReadable } = {}) {
          this.stream = stream;
          this.queue = new FIFO();
          this.highWaterMark = highWaterMark;
          this.buffered = 0;
          this.error = null;
          this.pipeline = null;
          this.byteLength = byteLengthReadable || byteLength2 || defaultByteLength;
          this.map = mapReadable || map3;
          this.pipeTo = null;
          this.afterRead = afterRead.bind(this);
          this.afterUpdateNextTick = updateReadNT.bind(this);
        }
        get ended() {
          return (this.stream._duplexState & READ_DONE) !== 0;
        }
        pipe(pipeTo, cb) {
          if (this.pipeTo !== null)
            throw new Error("Can only pipe to one destination");
          if (typeof cb !== "function")
            cb = null;
          this.stream._duplexState |= READ_PIPE_DRAINED;
          this.pipeTo = pipeTo;
          this.pipeline = new Pipeline(this.stream, pipeTo, cb);
          if (cb)
            this.stream.on("error", noop2);
          if (isStreamx(pipeTo)) {
            pipeTo._writableState.pipeline = this.pipeline;
            if (cb)
              pipeTo.on("error", noop2);
            pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
          } else {
            const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
            const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
            pipeTo.on("error", onerror);
            pipeTo.on("close", onclose);
            pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
          }
          pipeTo.on("drain", afterDrain.bind(this));
          this.stream.emit("piping", pipeTo);
          pipeTo.emit("pipe", this.stream);
        }
        push(data) {
          const stream = this.stream;
          if (data === null) {
            this.highWaterMark = 0;
            stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
            return false;
          }
          if (this.map !== null)
            data = this.map(data);
          this.buffered += this.byteLength(data);
          this.queue.push(data);
          stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
          return this.buffered < this.highWaterMark;
        }
        shift() {
          const data = this.queue.shift();
          this.buffered -= this.byteLength(data);
          if (this.buffered === 0)
            this.stream._duplexState &= READ_NOT_QUEUED;
          return data;
        }
        unshift(data) {
          let tail;
          const pending = [];
          while ((tail = this.queue.shift()) !== void 0) {
            pending.push(tail);
          }
          this.push(data);
          for (let i = 0; i < pending.length; i++) {
            this.queue.push(pending[i]);
          }
        }
        read() {
          const stream = this.stream;
          if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
            const data = this.shift();
            if (this.pipeTo !== null && this.pipeTo.write(data) === false)
              stream._duplexState &= READ_PIPE_NOT_DRAINED;
            if ((stream._duplexState & READ_EMIT_DATA) !== 0)
              stream.emit("data", data);
            return data;
          }
          return null;
        }
        drain() {
          const stream = this.stream;
          while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
            const data = this.shift();
            if (this.pipeTo !== null && this.pipeTo.write(data) === false)
              stream._duplexState &= READ_PIPE_NOT_DRAINED;
            if ((stream._duplexState & READ_EMIT_DATA) !== 0)
              stream.emit("data", data);
          }
        }
        update() {
          const stream = this.stream;
          this.drain();
          while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === 0) {
            stream._duplexState |= READ_ACTIVE_AND_SYNC_AND_NEEDS_PUSH;
            stream._read(this.afterRead);
            stream._duplexState &= READ_NOT_SYNC;
            if ((stream._duplexState & READ_ACTIVE) === 0)
              this.drain();
          }
          if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
            stream._duplexState |= READ_EMITTED_READABLE;
            stream.emit("readable");
          }
          if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0)
            this.updateNonPrimary();
        }
        updateNonPrimary() {
          const stream = this.stream;
          if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
            stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
            stream.emit("end");
            if ((stream._duplexState & AUTO_DESTROY) === DONE)
              stream._duplexState |= DESTROYING;
            if (this.pipeTo !== null)
              this.pipeTo.end();
          }
          if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
            if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
              stream._duplexState |= ACTIVE;
              stream._destroy(afterDestroy.bind(this));
            }
            return;
          }
          if ((stream._duplexState & IS_OPENING) === OPENING) {
            stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
            stream._open(afterOpen.bind(this));
          }
        }
        updateNextTick() {
          if ((this.stream._duplexState & READ_NEXT_TICK) !== 0)
            return;
          this.stream._duplexState |= READ_NEXT_TICK;
          queueTick(this.afterUpdateNextTick);
        }
      };
      var TransformState2 = class {
        constructor(stream) {
          this.data = null;
          this.afterTransform = afterTransform2.bind(stream);
          this.afterFinal = null;
        }
      };
      var Pipeline = class {
        constructor(src, dst, cb) {
          this.from = src;
          this.to = dst;
          this.afterPipe = cb;
          this.error = null;
          this.pipeToFinished = false;
        }
        finished() {
          this.pipeToFinished = true;
        }
        done(stream, err) {
          if (err)
            this.error = err;
          if (stream === this.to) {
            this.to = null;
            if (this.from !== null) {
              if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
                this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
              }
              return;
            }
          }
          if (stream === this.from) {
            this.from = null;
            if (this.to !== null) {
              if ((stream._duplexState & READ_DONE) === 0) {
                this.to.destroy(this.error || new Error("Readable stream closed before ending"));
              }
              return;
            }
          }
          if (this.afterPipe !== null)
            this.afterPipe(this.error);
          this.to = this.from = this.afterPipe = null;
        }
      };
      function afterDrain() {
        this.stream._duplexState |= READ_PIPE_DRAINED;
        if ((this.stream._duplexState & READ_ACTIVE_AND_SYNC) === 0)
          this.updateNextTick();
        else
          this.drain();
      }
      function afterFinal(err) {
        const stream = this.stream;
        if (err)
          stream.destroy(err);
        if ((stream._duplexState & DESTROY_STATUS) === 0) {
          stream._duplexState |= WRITE_DONE;
          stream.emit("finish");
        }
        if ((stream._duplexState & AUTO_DESTROY) === DONE) {
          stream._duplexState |= DESTROYING;
        }
        stream._duplexState &= WRITE_NOT_ACTIVE;
        this.update();
      }
      function afterDestroy(err) {
        const stream = this.stream;
        if (!err && this.error !== STREAM_DESTROYED)
          err = this.error;
        if (err)
          stream.emit("error", err);
        stream._duplexState |= DESTROYED;
        stream.emit("close");
        const rs = stream._readableState;
        const ws = stream._writableState;
        if (rs !== null && rs.pipeline !== null)
          rs.pipeline.done(stream, err);
        if (ws !== null && ws.pipeline !== null)
          ws.pipeline.done(stream, err);
      }
      function afterWrite2(err) {
        const stream = this.stream;
        if (err)
          stream.destroy(err);
        stream._duplexState &= WRITE_NOT_ACTIVE;
        if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
          stream._duplexState &= WRITE_DRAINED;
          if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
            stream.emit("drain");
          }
        }
        if ((stream._duplexState & WRITE_SYNC) === 0)
          this.update();
      }
      function afterRead(err) {
        if (err)
          this.stream.destroy(err);
        this.stream._duplexState &= READ_NOT_ACTIVE;
        if ((this.stream._duplexState & READ_SYNC) === 0)
          this.update();
      }
      function updateReadNT() {
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        this.update();
      }
      function updateWriteNT() {
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        this.update();
      }
      function afterOpen(err) {
        const stream = this.stream;
        if (err)
          stream.destroy(err);
        if ((stream._duplexState & DESTROYING) === 0) {
          if ((stream._duplexState & READ_PRIMARY_STATUS) === 0)
            stream._duplexState |= READ_PRIMARY;
          if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0)
            stream._duplexState |= WRITE_PRIMARY;
          stream.emit("open");
        }
        stream._duplexState &= NOT_ACTIVE;
        if (stream._writableState !== null) {
          stream._writableState.update();
        }
        if (stream._readableState !== null) {
          stream._readableState.update();
        }
      }
      function afterTransform2(err, data) {
        if (data !== void 0 && data !== null)
          this.push(data);
        this._writableState.afterWrite(err);
      }
      var Stream2 = class extends EventEmitter2 {
        constructor(opts) {
          super();
          this._duplexState = 0;
          this._readableState = null;
          this._writableState = null;
          if (opts) {
            if (opts.open)
              this._open = opts.open;
            if (opts.destroy)
              this._destroy = opts.destroy;
            if (opts.predestroy)
              this._predestroy = opts.predestroy;
            if (opts.signal) {
              opts.signal.addEventListener("abort", abort.bind(this));
            }
          }
        }
        _open(cb) {
          cb(null);
        }
        _destroy(cb) {
          cb(null);
        }
        _predestroy() {
        }
        get readable() {
          return this._readableState !== null ? true : void 0;
        }
        get writable() {
          return this._writableState !== null ? true : void 0;
        }
        get destroyed() {
          return (this._duplexState & DESTROYED) !== 0;
        }
        get destroying() {
          return (this._duplexState & DESTROY_STATUS) !== 0;
        }
        destroy(err) {
          if ((this._duplexState & DESTROY_STATUS) === 0) {
            if (!err)
              err = STREAM_DESTROYED;
            this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
            if (this._readableState !== null) {
              this._readableState.error = err;
              this._readableState.updateNextTick();
            }
            if (this._writableState !== null) {
              this._writableState.error = err;
              this._writableState.updateNextTick();
            }
            this._predestroy();
          }
        }
        on(name, fn) {
          if (this._readableState !== null) {
            if (name === "data") {
              this._duplexState |= READ_EMIT_DATA | READ_RESUMED;
              this._readableState.updateNextTick();
            }
            if (name === "readable") {
              this._duplexState |= READ_EMIT_READABLE;
              this._readableState.updateNextTick();
            }
          }
          if (this._writableState !== null) {
            if (name === "drain") {
              this._duplexState |= WRITE_EMIT_DRAIN;
              this._writableState.updateNextTick();
            }
          }
          return super.on(name, fn);
        }
      };
      var Readable2 = class extends Stream2 {
        constructor(opts) {
          super(opts);
          this._duplexState |= OPENING | WRITE_DONE;
          this._readableState = new ReadableState2(this, opts);
          if (opts) {
            if (opts.read)
              this._read = opts.read;
            if (opts.eagerOpen)
              this.resume().pause();
          }
        }
        _read(cb) {
          cb(null);
        }
        pipe(dest, cb) {
          this._readableState.pipe(dest, cb);
          this._readableState.updateNextTick();
          return dest;
        }
        read() {
          this._readableState.updateNextTick();
          return this._readableState.read();
        }
        push(data) {
          this._readableState.updateNextTick();
          return this._readableState.push(data);
        }
        unshift(data) {
          this._readableState.updateNextTick();
          return this._readableState.unshift(data);
        }
        resume() {
          this._duplexState |= READ_RESUMED;
          this._readableState.updateNextTick();
          return this;
        }
        pause() {
          this._duplexState &= READ_PAUSED;
          return this;
        }
        static _fromAsyncIterator(ite, opts) {
          let destroy;
          const rs = new Readable2({
            ...opts,
            read(cb) {
              ite.next().then(push).then(cb.bind(null, null)).catch(cb);
            },
            predestroy() {
              destroy = ite.return();
            },
            destroy(cb) {
              if (!destroy)
                return cb(null);
              destroy.then(cb.bind(null, null)).catch(cb);
            }
          });
          return rs;
          function push(data) {
            if (data.done)
              rs.push(null);
            else
              rs.push(data.value);
          }
        }
        static from(data, opts) {
          if (isReadStreamx(data))
            return data;
          if (data[asyncIterator])
            return this._fromAsyncIterator(data[asyncIterator](), opts);
          if (!Array.isArray(data))
            data = data === void 0 ? [] : [data];
          let i = 0;
          return new Readable2({
            ...opts,
            read(cb) {
              this.push(i === data.length ? null : data[i++]);
              cb(null);
            }
          });
        }
        static isBackpressured(rs) {
          return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
        }
        static isPaused(rs) {
          return (rs._duplexState & READ_RESUMED) === 0;
        }
        [asyncIterator]() {
          const stream = this;
          let error2 = null;
          let promiseResolve = null;
          let promiseReject = null;
          this.on("error", (err) => {
            error2 = err;
          });
          this.on("readable", onreadable);
          this.on("close", onclose);
          return {
            [asyncIterator]() {
              return this;
            },
            next() {
              return new Promise(function(resolve2, reject) {
                promiseResolve = resolve2;
                promiseReject = reject;
                const data = stream.read();
                if (data !== null)
                  ondata(data);
                else if ((stream._duplexState & DESTROYED) !== 0)
                  ondata(null);
              });
            },
            return() {
              return destroy(null);
            },
            throw(err) {
              return destroy(err);
            }
          };
          function onreadable() {
            if (promiseResolve !== null)
              ondata(stream.read());
          }
          function onclose() {
            if (promiseResolve !== null)
              ondata(null);
          }
          function ondata(data) {
            if (promiseReject === null)
              return;
            if (error2)
              promiseReject(error2);
            else if (data === null && (stream._duplexState & READ_DONE) === 0)
              promiseReject(STREAM_DESTROYED);
            else
              promiseResolve({ value: data, done: data === null });
            promiseReject = promiseResolve = null;
          }
          function destroy(err) {
            stream.destroy(err);
            return new Promise((resolve2, reject) => {
              if (stream._duplexState & DESTROYED)
                return resolve2({ value: void 0, done: true });
              stream.once("close", function() {
                if (err)
                  reject(err);
                else
                  resolve2({ value: void 0, done: true });
              });
            });
          }
        }
      };
      var Writable2 = class extends Stream2 {
        constructor(opts) {
          super(opts);
          this._duplexState |= OPENING | READ_DONE;
          this._writableState = new WritableState2(this, opts);
          if (opts) {
            if (opts.writev)
              this._writev = opts.writev;
            if (opts.write)
              this._write = opts.write;
            if (opts.final)
              this._final = opts.final;
          }
        }
        _writev(batch, cb) {
          cb(null);
        }
        _write(data, cb) {
          this._writableState.autoBatch(data, cb);
        }
        _final(cb) {
          cb(null);
        }
        static isBackpressured(ws) {
          return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
        }
        write(data) {
          this._writableState.updateNextTick();
          return this._writableState.push(data);
        }
        end(data) {
          this._writableState.updateNextTick();
          this._writableState.end(data);
          return this;
        }
      };
      var Duplex2 = class extends Readable2 {
        constructor(opts) {
          super(opts);
          this._duplexState = OPENING;
          this._writableState = new WritableState2(this, opts);
          if (opts) {
            if (opts.writev)
              this._writev = opts.writev;
            if (opts.write)
              this._write = opts.write;
            if (opts.final)
              this._final = opts.final;
          }
        }
        _writev(batch, cb) {
          cb(null);
        }
        _write(data, cb) {
          this._writableState.autoBatch(data, cb);
        }
        _final(cb) {
          cb(null);
        }
        write(data) {
          this._writableState.updateNextTick();
          return this._writableState.push(data);
        }
        end(data) {
          this._writableState.updateNextTick();
          this._writableState.end(data);
          return this;
        }
      };
      var Transform2 = class extends Duplex2 {
        constructor(opts) {
          super(opts);
          this._transformState = new TransformState2(this);
          if (opts) {
            if (opts.transform)
              this._transform = opts.transform;
            if (opts.flush)
              this._flush = opts.flush;
          }
        }
        _write(data, cb) {
          if (this._readableState.buffered >= this._readableState.highWaterMark) {
            this._transformState.data = data;
          } else {
            this._transform(data, this._transformState.afterTransform);
          }
        }
        _read(cb) {
          if (this._transformState.data !== null) {
            const data = this._transformState.data;
            this._transformState.data = null;
            cb(null);
            this._transform(data, this._transformState.afterTransform);
          } else {
            cb(null);
          }
        }
        _transform(data, cb) {
          cb(null, data);
        }
        _flush(cb) {
          cb(null);
        }
        _final(cb) {
          this._transformState.afterFinal = cb;
          this._flush(transformAfterFlush.bind(this));
        }
      };
      var PassThrough2 = class extends Transform2 {
      };
      function transformAfterFlush(err, data) {
        const cb = this._transformState.afterFinal;
        if (err)
          return cb(err);
        if (data !== null && data !== void 0)
          this.push(data);
        this.push(null);
        cb(null);
      }
      function pipelinePromise(...streams) {
        return new Promise((resolve2, reject) => {
          return pipeline(...streams, (err) => {
            if (err)
              return reject(err);
            resolve2();
          });
        });
      }
      function pipeline(stream, ...streams) {
        const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
        const done2 = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
        if (all.length < 2)
          throw new Error("Pipeline requires at least 2 streams");
        let src = all[0];
        let dest = null;
        let error2 = null;
        for (let i = 1; i < all.length; i++) {
          dest = all[i];
          if (isStreamx(src)) {
            src.pipe(dest, onerror);
          } else {
            errorHandle(src, true, i > 1, onerror);
            src.pipe(dest);
          }
          src = dest;
        }
        if (done2) {
          let fin = false;
          dest.on("finish", () => {
            fin = true;
          });
          dest.on("error", (err) => {
            error2 = error2 || err;
          });
          dest.on("close", () => done2(error2 || (fin ? null : PREMATURE_CLOSE)));
        }
        return dest;
        function errorHandle(s, rd, wr, onerror2) {
          s.on("error", onerror2);
          s.on("close", onclose);
          function onclose() {
            if (rd && s._readableState && !s._readableState.ended)
              return onerror2(PREMATURE_CLOSE);
            if (wr && s._writableState && !s._writableState.ended)
              return onerror2(PREMATURE_CLOSE);
          }
        }
        function onerror(err) {
          if (!err || error2)
            return;
          error2 = err;
          for (const s of all) {
            s.destroy(err);
          }
        }
      }
      function isStream(stream) {
        return !!stream._readableState || !!stream._writableState;
      }
      function isStreamx(stream) {
        return typeof stream._duplexState === "number" && isStream(stream);
      }
      function isReadStreamx(stream) {
        return isStreamx(stream) && stream.readable;
      }
      function isTypedArray(data) {
        return typeof data === "object" && data !== null && typeof data.byteLength === "number";
      }
      function defaultByteLength(data) {
        return isTypedArray(data) ? data.byteLength : 1024;
      }
      function noop2() {
      }
      function abort() {
        this.destroy(new Error("Stream aborted."));
      }
      module.exports = {
        pipeline,
        pipelinePromise,
        isStream,
        isStreamx,
        Stream: Stream2,
        Writable: Writable2,
        Readable: Readable2,
        Duplex: Duplex2,
        Transform: Transform2,
        PassThrough: PassThrough2
      };
    }
  });

  // node_modules/speed-limiter/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/speed-limiter/lib/utils.js"(exports, module) {
      init_esbuild_inject();
      function wait(time) {
        return new Promise((resolve2) => setTimeout(resolve2, time));
      }
      module.exports = {
        wait
      };
    }
  });

  // node_modules/limiter/lib/tokenBucket.js
  var require_tokenBucket = __commonJS({
    "node_modules/limiter/lib/tokenBucket.js"(exports, module) {
      init_esbuild_inject();
      var TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {
        this.bucketSize = bucketSize;
        this.tokensPerInterval = tokensPerInterval;
        if (typeof interval === "string") {
          switch (interval) {
            case "sec":
            case "second":
              this.interval = 1e3;
              break;
            case "min":
            case "minute":
              this.interval = 1e3 * 60;
              break;
            case "hr":
            case "hour":
              this.interval = 1e3 * 60 * 60;
              break;
            case "day":
              this.interval = 1e3 * 60 * 60 * 24;
              break;
            default:
              throw new Error("Invaid interval " + interval);
          }
        } else {
          this.interval = interval;
        }
        this.parentBucket = parentBucket;
        this.content = 0;
        this.lastDrip = +new Date();
      };
      TokenBucket.prototype = {
        bucketSize: 1,
        tokensPerInterval: 1,
        interval: 1e3,
        parentBucket: null,
        content: 0,
        lastDrip: 0,
        removeTokens: function(count, callback) {
          var self2 = this;
          if (!this.bucketSize) {
            process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
            return true;
          }
          if (count > this.bucketSize) {
            process.nextTick(callback.bind(null, "Requested tokens " + count + " exceeds bucket size " + this.bucketSize, null));
            return false;
          }
          this.drip();
          if (count > this.content)
            return comeBackLater();
          if (this.parentBucket) {
            return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
              if (err)
                return callback(err, null);
              if (count > self2.content)
                return comeBackLater();
              self2.content -= count;
              callback(null, Math.min(remainingTokens, self2.content));
            });
          } else {
            this.content -= count;
            process.nextTick(callback.bind(null, null, this.content));
            return true;
          }
          function comeBackLater() {
            var waitInterval = Math.ceil((count - self2.content) * (self2.interval / self2.tokensPerInterval));
            setTimeout(function() {
              self2.removeTokens(count, callback);
            }, waitInterval);
            return false;
          }
        },
        tryRemoveTokens: function(count) {
          if (!this.bucketSize)
            return true;
          if (count > this.bucketSize)
            return false;
          this.drip();
          if (count > this.content)
            return false;
          if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
            return false;
          this.content -= count;
          return true;
        },
        drip: function() {
          if (!this.tokensPerInterval) {
            this.content = this.bucketSize;
            return;
          }
          var now = +new Date();
          var deltaMS = Math.max(now - this.lastDrip, 0);
          this.lastDrip = now;
          var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
          this.content = Math.min(this.content + dripAmount, this.bucketSize);
        }
      };
      module.exports = TokenBucket;
    }
  });

  // node_modules/limiter/lib/clock.js
  var require_clock = __commonJS({
    "node_modules/limiter/lib/clock.js"(exports, module) {
      init_esbuild_inject();
      var getMilliseconds = function() {
        if (typeof process !== "undefined" && process.hrtime) {
          var hrtime2 = process.hrtime();
          var seconds = hrtime2[0];
          var nanoseconds = hrtime2[1];
          return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
        }
        return new Date().getTime();
      };
      module.exports = getMilliseconds;
    }
  });

  // node_modules/limiter/lib/rateLimiter.js
  var require_rateLimiter = __commonJS({
    "node_modules/limiter/lib/rateLimiter.js"(exports, module) {
      init_esbuild_inject();
      var TokenBucket = require_tokenBucket();
      var getMilliseconds = require_clock();
      var RateLimiter = function(tokensPerInterval, interval, fireImmediately) {
        this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval, interval, null);
        this.tokenBucket.content = tokensPerInterval;
        this.curIntervalStart = getMilliseconds();
        this.tokensThisInterval = 0;
        this.fireImmediately = fireImmediately;
      };
      RateLimiter.prototype = {
        tokenBucket: null,
        curIntervalStart: 0,
        tokensThisInterval: 0,
        fireImmediately: false,
        removeTokens: function(count, callback) {
          if (count > this.tokenBucket.bucketSize) {
            process.nextTick(callback.bind(null, "Requested tokens " + count + " exceeds maximum tokens per interval " + this.tokenBucket.bucketSize, null));
            return false;
          }
          var self2 = this;
          var now = getMilliseconds();
          if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
            this.curIntervalStart = now;
            this.tokensThisInterval = 0;
          }
          if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
            if (this.fireImmediately) {
              process.nextTick(callback.bind(null, null, -1));
            } else {
              var waitInterval = Math.ceil(this.curIntervalStart + this.tokenBucket.interval - now);
              setTimeout(function() {
                self2.tokenBucket.removeTokens(count, afterTokensRemoved);
              }, waitInterval);
            }
            return false;
          }
          return this.tokenBucket.removeTokens(count, afterTokensRemoved);
          function afterTokensRemoved(err, tokensRemaining) {
            if (err)
              return callback(err, null);
            self2.tokensThisInterval += count;
            callback(null, tokensRemaining);
          }
        },
        tryRemoveTokens: function(count) {
          if (count > this.tokenBucket.bucketSize)
            return false;
          var now = getMilliseconds();
          if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
            this.curIntervalStart = now;
            this.tokensThisInterval = 0;
          }
          if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
            return false;
          var removed = this.tokenBucket.tryRemoveTokens(count);
          if (removed) {
            this.tokensThisInterval += count;
          }
          return removed;
        },
        getTokensRemaining: function() {
          this.tokenBucket.drip();
          return this.tokenBucket.content;
        }
      };
      module.exports = RateLimiter;
    }
  });

  // node_modules/limiter/index.js
  var require_limiter = __commonJS({
    "node_modules/limiter/index.js"(exports) {
      init_esbuild_inject();
      exports.RateLimiter = require_rateLimiter();
      exports.TokenBucket = require_tokenBucket();
    }
  });

  // node_modules/speed-limiter/lib/throttle-group.js
  var require_throttle_group = __commonJS({
    "node_modules/speed-limiter/lib/throttle-group.js"(exports, module) {
      init_esbuild_inject();
      var { TokenBucket } = require_limiter();
      var Throttle = require_throttle();
      var ThrottleGroup = class {
        constructor(opts = {}) {
          if (typeof opts !== "object")
            throw new Error("Options must be an object");
          this.throttles = [];
          this.setEnabled(opts.enabled);
          this.setRate(opts.rate, opts.chunksize);
        }
        getEnabled() {
          return this._enabled;
        }
        getRate() {
          return this.bucket.tokensPerInterval;
        }
        getChunksize() {
          return this.chunksize;
        }
        setEnabled(val = true) {
          if (typeof val !== "boolean")
            throw new Error("Enabled must be a boolean");
          this._enabled = val;
          for (const throttle of this.throttles) {
            throttle.setEnabled(val);
          }
        }
        setRate(rate, chunksize = null) {
          if (!Number.isInteger(rate) || rate < 0)
            throw new Error("Rate must be an integer bigger than zero");
          rate = parseInt(rate);
          if (chunksize && (typeof chunksize !== "number" || chunksize <= 0))
            throw new Error("Chunksize must be bigger than zero");
          chunksize = chunksize || Math.max(parseInt(rate / 10), 1);
          chunksize = parseInt(chunksize);
          if (rate > 0 && chunksize > rate)
            throw new Error("Chunk size must be smaller than rate");
          if (!this.bucket)
            this.bucket = new TokenBucket(rate, rate, "second", null);
          this.bucket.bucketSize = rate;
          this.bucket.tokensPerInterval = rate;
          this.chunksize = chunksize;
        }
        setChunksize(chunksize) {
          if (!Number.isInteger(chunksize) || chunksize <= 0)
            throw new Error("Chunk size must be an integer bigger than zero");
          const rate = this.getRate();
          chunksize = parseInt(chunksize);
          if (rate > 0 && chunksize > rate)
            throw new Error("Chunk size must be smaller than rate");
          this.chunksize = chunksize;
        }
        throttle(opts = {}) {
          if (typeof opts !== "object")
            throw new Error("Options must be an object");
          const newThrottle = new Throttle({
            ...opts,
            group: this
          });
          return newThrottle;
        }
        destroy() {
          for (const throttle of this.throttles) {
            throttle.destroy();
          }
          this.throttles = [];
        }
        _addThrottle(throttle) {
          if (!(throttle instanceof Throttle))
            throw new Error("Throttle must be an instance of Throttle");
          this.throttles.push(throttle);
        }
        _removeThrottle(throttle) {
          const index = this.throttles.indexOf(throttle);
          if (index > -1)
            this.throttles.splice(index, 1);
        }
      };
      module.exports = ThrottleGroup;
    }
  });

  // node_modules/speed-limiter/lib/throttle.js
  var require_throttle = __commonJS({
    "node_modules/speed-limiter/lib/throttle.js"(exports, module) {
      init_esbuild_inject();
      var { EventEmitter: EventEmitter2 } = require_events();
      var { Transform: Transform2 } = require_streamx();
      var { wait } = require_utils();
      var Throttle = class extends Transform2 {
        constructor(opts = {}) {
          super();
          if (typeof opts !== "object")
            throw new Error("Options must be an object");
          const params = Object.assign({}, opts);
          if (params.group && !(params.group instanceof ThrottleGroup))
            throw new Error("Group must be an instanece of ThrottleGroup");
          else if (!params.group)
            params.group = new ThrottleGroup(params);
          this._setEnabled(params.enabled || params.group.enabled);
          this._group = params.group;
          this._emitter = new EventEmitter2();
          this._destroyed = false;
          this._group._addThrottle(this);
        }
        getEnabled() {
          return this._enabled;
        }
        getGroup() {
          return this._group;
        }
        _setEnabled(val = true) {
          if (typeof val !== "boolean")
            throw new Error("Enabled must be a boolean");
          this._enabled = val;
        }
        setEnabled(val) {
          this._setEnabled(val);
          if (this._enabled)
            this._emitter.emit("enabled");
          else
            this._emitter.emit("disabled");
        }
        _transform(chunk, done2) {
          this._processChunk(chunk, done2);
        }
        async _waitForTokens(amount) {
          return new Promise((resolve2, reject) => {
            let done2 = false;
            const self2 = this;
            function isDone(err) {
              self2._emitter.removeListener("disabled", isDone);
              self2._emitter.removeListener("destroyed", isDone);
              if (done2)
                return;
              done2 = true;
              if (err)
                return reject(err);
              resolve2();
            }
            this._emitter.once("disabled", isDone);
            this._emitter.once("destroyed", isDone);
            this._group.bucket.removeTokens(amount, isDone);
          });
        }
        _areBothEnabled() {
          return this._enabled && this._group.getEnabled();
        }
        async _processChunk(chunk, done2) {
          if (!this._areBothEnabled())
            return done2(null, chunk);
          let pos = 0;
          let chunksize = this._group.getChunksize();
          let slice2 = chunk.slice(pos, pos + chunksize);
          while (slice2.length > 0) {
            if (this._areBothEnabled()) {
              try {
                while (this._group.getRate() === 0 && !this._destroyed && this._areBothEnabled()) {
                  await wait(1e3);
                  if (this._destroyed)
                    return;
                }
                if (this._areBothEnabled() && !this._group.bucket.tryRemoveTokens(slice2.length)) {
                  await this._waitForTokens(slice2.length);
                  if (this._destroyed)
                    return;
                }
              } catch (err) {
                return done2(err);
              }
            }
            this.push(slice2);
            pos += chunksize;
            chunksize = this._areBothEnabled() ? this._group.getChunksize() : chunk.length - pos;
            slice2 = chunk.slice(pos, pos + chunksize);
          }
          return done2();
        }
        destroy(...args) {
          this._group._removeThrottle(this);
          this._destroyed = true;
          this._emitter.emit("destroyed");
          super.destroy(...args);
        }
      };
      module.exports = Throttle;
      var ThrottleGroup = require_throttle_group();
    }
  });

  // node_modules/speed-limiter/index.js
  var require_speed_limiter = __commonJS({
    "node_modules/speed-limiter/index.js"(exports, module) {
      init_esbuild_inject();
      var Throttle = require_throttle();
      var ThrottleGroup = require_throttle_group();
      module.exports = {
        Throttle,
        ThrottleGroup
      };
    }
  });

  // (disabled):node_modules/webtorrent/lib/conn-pool.js
  var require_conn_pool = __commonJS({
    "(disabled):node_modules/webtorrent/lib/conn-pool.js"() {
      init_esbuild_inject();
    }
  });

  // node-modules-polyfills:net
  var net_exports = {};
  __export(net_exports, {
    default: () => net_default
  });
  var net_default;
  var init_net = __esm({
    "node-modules-polyfills:net"() {
      init_esbuild_inject();
      net_default = {};
    }
  });

  // node-modules-polyfills-commonjs:net
  var require_net = __commonJS({
    "node-modules-polyfills-commonjs:net"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_net(), __toCommonJS(net_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node-modules-polyfills:os
  var os_exports = {};
  __export(os_exports, {
    EOL: () => EOL,
    arch: () => arch,
    cpus: () => cpus,
    default: () => os_default,
    endianness: () => endianness,
    freemem: () => freemem,
    getNetworkInterfaces: () => getNetworkInterfaces,
    hostname: () => hostname,
    loadavg: () => loadavg,
    networkInterfaces: () => networkInterfaces,
    platform: () => platform2,
    release: () => release2,
    tmpDir: () => tmpDir,
    tmpdir: () => tmpdir,
    totalmem: () => totalmem,
    type: () => type,
    uptime: () => uptime2
  });
  function endianness() {
    if (typeof _endianness === "undefined") {
      var a = new ArrayBuffer(2);
      var b = new Uint8Array(a);
      var c = new Uint16Array(a);
      b[0] = 1;
      b[1] = 2;
      if (c[0] === 258) {
        _endianness = "BE";
      } else if (c[0] === 513) {
        _endianness = "LE";
      } else {
        throw new Error("unable to figure out endianess");
      }
    }
    return _endianness;
  }
  function hostname() {
    if (typeof globalThis.location !== "undefined") {
      return globalThis.location.hostname;
    } else
      return "";
  }
  function loadavg() {
    return [];
  }
  function uptime2() {
    return 0;
  }
  function freemem() {
    return Number.MAX_VALUE;
  }
  function totalmem() {
    return Number.MAX_VALUE;
  }
  function cpus() {
    return [];
  }
  function type() {
    return "Browser";
  }
  function release2() {
    if (typeof globalThis.navigator !== "undefined") {
      return globalThis.navigator.appVersion;
    }
    return "";
  }
  function networkInterfaces() {
  }
  function getNetworkInterfaces() {
  }
  function arch() {
    return "javascript";
  }
  function platform2() {
    return "browser";
  }
  function tmpDir() {
    return "/tmp";
  }
  var _endianness, tmpdir, EOL, os_default;
  var init_os = __esm({
    "node-modules-polyfills:os"() {
      init_esbuild_inject();
      tmpdir = tmpDir;
      EOL = "\n";
      os_default = {
        EOL,
        tmpdir,
        tmpDir,
        networkInterfaces,
        getNetworkInterfaces,
        release: release2,
        type,
        cpus,
        totalmem,
        freemem,
        uptime: uptime2,
        loadavg,
        hostname,
        endianness
      };
    }
  });

  // node-modules-polyfills-commonjs:os
  var require_os = __commonJS({
    "node-modules-polyfills-commonjs:os"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_os(), __toCommonJS(os_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node_modules/addr-to-ip-port/index.js
  var require_addr_to_ip_port = __commonJS({
    "node_modules/addr-to-ip-port/index.js"(exports, module) {
      init_esbuild_inject();
      var ADDR_RE = /^\[?([^\]]+)]?:(\d+)$/;
      var cache = /* @__PURE__ */ new Map();
      module.exports = function addrToIPPort(addr) {
        if (cache.size === 1e5)
          cache.clear();
        if (!cache.has(addr)) {
          const m = ADDR_RE.exec(addr);
          if (!m)
            throw new Error(`invalid addr: ${addr}`);
          cache.set(addr, [m[1], Number(m[2])]);
        }
        return cache.get(addr);
      };
    }
  });

  // node_modules/bitfield/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/bitfield/lib/index.js"(exports) {
      "use strict";
      init_esbuild_inject();
      Object.defineProperty(exports, "__esModule", { value: true });
      function getByteSize(num) {
        var out = num >> 3;
        if (num % 8 !== 0)
          out++;
        return out;
      }
      var BitField = function() {
        function BitField2(data, opts) {
          if (data === void 0) {
            data = 0;
          }
          var grow = opts === null || opts === void 0 ? void 0 : opts.grow;
          this.grow = grow && isFinite(grow) && getByteSize(grow) || grow || 0;
          this.buffer = typeof data === "number" ? new Uint8Array(getByteSize(data)) : data;
        }
        BitField2.prototype.get = function(i) {
          var j = i >> 3;
          return j < this.buffer.length && !!(this.buffer[j] & 128 >> i % 8);
        };
        BitField2.prototype.set = function(i, value) {
          if (value === void 0) {
            value = true;
          }
          var j = i >> 3;
          if (value) {
            if (this.buffer.length < j + 1) {
              var length = Math.max(j + 1, Math.min(2 * this.buffer.length, this.grow));
              if (length <= this.grow) {
                var newBuffer = new Uint8Array(length);
                newBuffer.set(this.buffer);
                this.buffer = newBuffer;
              }
            }
            this.buffer[j] |= 128 >> i % 8;
          } else if (j < this.buffer.length) {
            this.buffer[j] &= ~(128 >> i % 8);
          }
        };
        BitField2.prototype.forEach = function(fn, start, end) {
          if (start === void 0) {
            start = 0;
          }
          if (end === void 0) {
            end = this.buffer.length * 8;
          }
          for (var i = start, j = i >> 3, y = 128 >> i % 8, byte = this.buffer[j]; i < end; i++) {
            fn(!!(byte & y), i);
            y = y === 1 ? (byte = this.buffer[++j], 128) : y >> 1;
          }
        };
        return BitField2;
      }();
      exports.default = BitField;
    }
  });

  // node_modules/lru/index.js
  var require_lru = __commonJS({
    "node_modules/lru/index.js"(exports, module) {
      init_esbuild_inject();
      var events = require_events();
      var inherits2 = require_inherits_browser();
      module.exports = LRU;
      function LRU(opts) {
        if (!(this instanceof LRU))
          return new LRU(opts);
        if (typeof opts === "number")
          opts = { max: opts };
        if (!opts)
          opts = {};
        events.EventEmitter.call(this);
        this.cache = {};
        this.head = this.tail = null;
        this.length = 0;
        this.max = opts.max || 1e3;
        this.maxAge = opts.maxAge || 0;
      }
      inherits2(LRU, events.EventEmitter);
      Object.defineProperty(LRU.prototype, "keys", {
        get: function() {
          return Object.keys(this.cache);
        }
      });
      LRU.prototype.clear = function() {
        this.cache = {};
        this.head = this.tail = null;
        this.length = 0;
      };
      LRU.prototype.remove = function(key) {
        if (typeof key !== "string")
          key = "" + key;
        if (!this.cache.hasOwnProperty(key))
          return;
        var element = this.cache[key];
        delete this.cache[key];
        this._unlink(key, element.prev, element.next);
        return element.value;
      };
      LRU.prototype._unlink = function(key, prev, next) {
        this.length--;
        if (this.length === 0) {
          this.head = this.tail = null;
        } else {
          if (this.head === key) {
            this.head = prev;
            this.cache[this.head].next = null;
          } else if (this.tail === key) {
            this.tail = next;
            this.cache[this.tail].prev = null;
          } else {
            this.cache[prev].next = next;
            this.cache[next].prev = prev;
          }
        }
      };
      LRU.prototype.peek = function(key) {
        if (!this.cache.hasOwnProperty(key))
          return;
        var element = this.cache[key];
        if (!this._checkAge(key, element))
          return;
        return element.value;
      };
      LRU.prototype.set = function(key, value) {
        if (typeof key !== "string")
          key = "" + key;
        var element;
        if (this.cache.hasOwnProperty(key)) {
          element = this.cache[key];
          element.value = value;
          if (this.maxAge)
            element.modified = Date.now();
          if (key === this.head)
            return value;
          this._unlink(key, element.prev, element.next);
        } else {
          element = { value, modified: 0, next: null, prev: null };
          if (this.maxAge)
            element.modified = Date.now();
          this.cache[key] = element;
          if (this.length === this.max)
            this.evict();
        }
        this.length++;
        element.next = null;
        element.prev = this.head;
        if (this.head)
          this.cache[this.head].next = key;
        this.head = key;
        if (!this.tail)
          this.tail = key;
        return value;
      };
      LRU.prototype._checkAge = function(key, element) {
        if (this.maxAge && Date.now() - element.modified > this.maxAge) {
          this.remove(key);
          this.emit("evict", { key, value: element.value });
          return false;
        }
        return true;
      };
      LRU.prototype.get = function(key) {
        if (typeof key !== "string")
          key = "" + key;
        if (!this.cache.hasOwnProperty(key))
          return;
        var element = this.cache[key];
        if (!this._checkAge(key, element))
          return;
        if (this.head !== key) {
          if (key === this.tail) {
            this.tail = element.next;
            this.cache[this.tail].prev = null;
          } else {
            this.cache[element.prev].next = element.next;
          }
          this.cache[element.next].prev = element.prev;
          this.cache[this.head].next = key;
          element.prev = this.head;
          element.next = null;
          this.head = key;
        }
        return element.value;
      };
      LRU.prototype.evict = function() {
        if (!this.tail)
          return;
        var key = this.tail;
        var value = this.remove(this.tail);
        this.emit("evict", { key, value });
      };
    }
  });

  // node_modules/cache-chunk-store/index.js
  var require_cache_chunk_store = __commonJS({
    "node_modules/cache-chunk-store/index.js"(exports, module) {
      init_esbuild_inject();
      var LRU = require_lru();
      var queueMicrotask2 = require_queue_microtask();
      var CacheStore = class {
        constructor(store, opts) {
          this.store = store;
          this.chunkLength = store.chunkLength;
          this.inProgressGets = /* @__PURE__ */ new Map();
          if (!this.store || !this.store.get || !this.store.put) {
            throw new Error("First argument must be abstract-chunk-store compliant");
          }
          this.cache = new LRU(opts);
        }
        put(index, buf, cb = () => {
        }) {
          if (!this.cache) {
            return queueMicrotask2(() => cb(new Error("CacheStore closed")));
          }
          this.cache.remove(index);
          this.store.put(index, buf, cb);
        }
        get(index, opts, cb = () => {
        }) {
          if (typeof opts === "function")
            return this.get(index, null, opts);
          if (!this.cache) {
            return queueMicrotask2(() => cb(new Error("CacheStore closed")));
          }
          if (!opts)
            opts = {};
          let buf = this.cache.get(index);
          if (buf) {
            const offset = opts.offset || 0;
            const len = opts.length || buf.length - offset;
            if (offset !== 0 || len !== buf.length) {
              buf = buf.slice(offset, len + offset);
            }
            return queueMicrotask2(() => cb(null, buf));
          }
          let waiters = this.inProgressGets.get(index);
          const getAlreadyStarted = !!waiters;
          if (!waiters) {
            waiters = [];
            this.inProgressGets.set(index, waiters);
          }
          waiters.push({
            opts,
            cb
          });
          if (!getAlreadyStarted) {
            this.store.get(index, (err, buf2) => {
              if (!err && this.cache != null)
                this.cache.set(index, buf2);
              const inProgressEntry = this.inProgressGets.get(index);
              this.inProgressGets.delete(index);
              for (const { opts: opts2, cb: cb2 } of inProgressEntry) {
                if (err) {
                  cb2(err);
                } else {
                  const offset = opts2.offset || 0;
                  const len = opts2.length || buf2.length - offset;
                  let slicedBuf = buf2;
                  if (offset !== 0 || len !== buf2.length) {
                    slicedBuf = buf2.slice(offset, len + offset);
                  }
                  cb2(null, slicedBuf);
                }
              }
            });
          }
        }
        close(cb = () => {
        }) {
          if (!this.cache) {
            return queueMicrotask2(() => cb(new Error("CacheStore closed")));
          }
          this.cache = null;
          this.store.close(cb);
        }
        destroy(cb = () => {
        }) {
          if (!this.cache) {
            return queueMicrotask2(() => cb(new Error("CacheStore closed")));
          }
          this.cache = null;
          this.store.destroy(cb);
        }
      };
      module.exports = CacheStore;
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/errors-browser.js
  var require_errors_browser6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser6().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser6();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy6();
      var _require = require_state6();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser6().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex6();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex6();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable6();
      var Writable2 = require_stream_writable6();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser6().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream6();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser6();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list6();
      var destroyImpl = require_destroy6();
      var _require = require_state6();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser6().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex6();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex6();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator6();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser6();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser6().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex6();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform6();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser6().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream6();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/chunk-store-stream/node_modules/readable-stream/readable-browser.js
  var require_readable_browser6 = __commonJS({
    "node_modules/chunk-store-stream/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable6();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable6();
      exports.Duplex = require_stream_duplex6();
      exports.Transform = require_stream_transform6();
      exports.PassThrough = require_stream_passthrough6();
      exports.finished = require_end_of_stream6();
      exports.pipeline = require_pipeline6();
    }
  });

  // node_modules/chunk-store-stream/write.js
  var require_write = __commonJS({
    "node_modules/chunk-store-stream/write.js"(exports, module) {
      init_esbuild_inject();
      var BlockStream = require_block_stream2();
      var stream = require_readable_browser6();
      var ChunkStoreWriteStream = class extends stream.Writable {
        constructor(store, chunkLength, opts = {}) {
          super(opts);
          if (!store || !store.put || !store.get) {
            throw new Error("First argument must be an abstract-chunk-store compliant store");
          }
          chunkLength = Number(chunkLength);
          if (!chunkLength)
            throw new Error("Second argument must be a chunk length");
          const zeroPadding = opts.zeroPadding === void 0 ? false : opts.zeroPadding;
          this._blockstream = new BlockStream(chunkLength, { ...opts, zeroPadding });
          this._outstandingPuts = 0;
          this._storeMaxOutstandingPuts = opts.storeMaxOutstandingPuts || 16;
          let index = 0;
          const onData = (chunk) => {
            if (this.destroyed)
              return;
            this._outstandingPuts += 1;
            if (this._outstandingPuts >= this._storeMaxOutstandingPuts) {
              this._blockstream.pause();
            }
            store.put(index, chunk, (err) => {
              if (err)
                return this.destroy(err);
              this._outstandingPuts -= 1;
              if (this._outstandingPuts < this._storeMaxOutstandingPuts) {
                this._blockstream.resume();
              }
              if (this._outstandingPuts === 0 && typeof this._finalCb === "function") {
                this._finalCb(null);
                this._finalCb = null;
              }
            });
            index += 1;
          };
          this._blockstream.on("data", onData).on("error", (err) => {
            this.destroy(err);
          });
        }
        _write(chunk, encoding, callback) {
          this._blockstream.write(chunk, encoding, callback);
        }
        _final(cb) {
          this._blockstream.end();
          this._blockstream.once("end", () => {
            if (this._outstandingPuts === 0)
              cb(null);
            else
              this._finalCb = cb;
          });
        }
        destroy(err) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          if (err)
            this.emit("error", err);
          this.emit("close");
        }
      };
      module.exports = ChunkStoreWriteStream;
    }
  });

  // node_modules/cpus/browser.js
  var require_browser7 = __commonJS({
    "node_modules/cpus/browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function cpus2() {
        var num = navigator.hardwareConcurrency || 1;
        var cpus3 = [];
        for (var i = 0; i < num; i++) {
          cpus3.push({
            model: "",
            speed: 0,
            times: { user: 0, nice: 0, sys: 0, idle: 0, irq: 0 }
          });
        }
        return cpus3;
      };
    }
  });

  // (disabled):node_modules/bittorrent-tracker/lib/common-node
  var require_common_node = __commonJS({
    "(disabled):node_modules/bittorrent-tracker/lib/common-node"() {
      init_esbuild_inject();
    }
  });

  // node_modules/bittorrent-tracker/lib/common.js
  var require_common3 = __commonJS({
    "node_modules/bittorrent-tracker/lib/common.js"(exports) {
      init_esbuild_inject();
      exports.DEFAULT_ANNOUNCE_PEERS = 50;
      exports.MAX_ANNOUNCE_PEERS = 82;
      exports.binaryToHex = (str) => {
        if (typeof str !== "string") {
          str = String(str);
        }
        return Buffer3.from(str, "binary").toString("hex");
      };
      exports.hexToBinary = (str) => {
        if (typeof str !== "string") {
          str = String(str);
        }
        return Buffer3.from(str, "hex").toString("binary");
      };
      exports.parseUrl = (str) => {
        const url = new URL(str.replace(/^udp:/, "http:"));
        if (str.match(/^udp:/)) {
          Object.defineProperties(url, {
            href: { value: url.href.replace(/^http/, "udp") },
            protocol: { value: url.protocol.replace(/^http/, "udp") },
            origin: { value: url.origin.replace(/^http/, "udp") }
          });
        }
        return url;
      };
      var config2 = require_common_node();
      Object.assign(exports, config2);
    }
  });

  // (disabled):node_modules/bittorrent-tracker/lib/client/http-tracker
  var require_http_tracker = __commonJS({
    "(disabled):node_modules/bittorrent-tracker/lib/client/http-tracker"() {
      init_esbuild_inject();
    }
  });

  // (disabled):node_modules/bittorrent-tracker/lib/client/udp-tracker
  var require_udp_tracker = __commonJS({
    "(disabled):node_modules/bittorrent-tracker/lib/client/udp-tracker"() {
      init_esbuild_inject();
    }
  });

  // node_modules/clone/clone.js
  var require_clone = __commonJS({
    "node_modules/clone/clone.js"(exports, module) {
      init_esbuild_inject();
      var clone = function() {
        "use strict";
        function _instanceof(obj, type2) {
          return type2 != null && obj instanceof type2;
        }
        var nativeMap;
        try {
          nativeMap = Map;
        } catch (_) {
          nativeMap = function() {
          };
        }
        var nativeSet;
        try {
          nativeSet = Set;
        } catch (_) {
          nativeSet = function() {
          };
        }
        var nativePromise;
        try {
          nativePromise = Promise;
        } catch (_) {
          nativePromise = function() {
          };
        }
        function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
          if (typeof circular === "object") {
            depth = circular.depth;
            prototype = circular.prototype;
            includeNonEnumerable = circular.includeNonEnumerable;
            circular = circular.circular;
          }
          var allParents = [];
          var allChildren = [];
          var useBuffer = typeof Buffer3 != "undefined";
          if (typeof circular == "undefined")
            circular = true;
          if (typeof depth == "undefined")
            depth = Infinity;
          function _clone(parent2, depth2) {
            if (parent2 === null)
              return null;
            if (depth2 === 0)
              return parent2;
            var child;
            var proto;
            if (typeof parent2 != "object") {
              return parent2;
            }
            if (_instanceof(parent2, nativeMap)) {
              child = new nativeMap();
            } else if (_instanceof(parent2, nativeSet)) {
              child = new nativeSet();
            } else if (_instanceof(parent2, nativePromise)) {
              child = new nativePromise(function(resolve2, reject) {
                parent2.then(function(value) {
                  resolve2(_clone(value, depth2 - 1));
                }, function(err) {
                  reject(_clone(err, depth2 - 1));
                });
              });
            } else if (clone2.__isArray(parent2)) {
              child = [];
            } else if (clone2.__isRegExp(parent2)) {
              child = new RegExp(parent2.source, __getRegExpFlags(parent2));
              if (parent2.lastIndex)
                child.lastIndex = parent2.lastIndex;
            } else if (clone2.__isDate(parent2)) {
              child = new Date(parent2.getTime());
            } else if (useBuffer && Buffer3.isBuffer(parent2)) {
              if (Buffer3.allocUnsafe) {
                child = Buffer3.allocUnsafe(parent2.length);
              } else {
                child = new Buffer3(parent2.length);
              }
              parent2.copy(child);
              return child;
            } else if (_instanceof(parent2, Error)) {
              child = Object.create(parent2);
            } else {
              if (typeof prototype == "undefined") {
                proto = Object.getPrototypeOf(parent2);
                child = Object.create(proto);
              } else {
                child = Object.create(prototype);
                proto = prototype;
              }
            }
            if (circular) {
              var index = allParents.indexOf(parent2);
              if (index != -1) {
                return allChildren[index];
              }
              allParents.push(parent2);
              allChildren.push(child);
            }
            if (_instanceof(parent2, nativeMap)) {
              parent2.forEach(function(value, key) {
                var keyChild = _clone(key, depth2 - 1);
                var valueChild = _clone(value, depth2 - 1);
                child.set(keyChild, valueChild);
              });
            }
            if (_instanceof(parent2, nativeSet)) {
              parent2.forEach(function(value) {
                var entryChild = _clone(value, depth2 - 1);
                child.add(entryChild);
              });
            }
            for (var i in parent2) {
              var attrs;
              if (proto) {
                attrs = Object.getOwnPropertyDescriptor(proto, i);
              }
              if (attrs && attrs.set == null) {
                continue;
              }
              child[i] = _clone(parent2[i], depth2 - 1);
            }
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(parent2);
              for (var i = 0; i < symbols.length; i++) {
                var symbol = symbols[i];
                var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
                if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                  continue;
                }
                child[symbol] = _clone(parent2[symbol], depth2 - 1);
                if (!descriptor.enumerable) {
                  Object.defineProperty(child, symbol, {
                    enumerable: false
                  });
                }
              }
            }
            if (includeNonEnumerable) {
              var allPropertyNames = Object.getOwnPropertyNames(parent2);
              for (var i = 0; i < allPropertyNames.length; i++) {
                var propertyName = allPropertyNames[i];
                var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
                if (descriptor && descriptor.enumerable) {
                  continue;
                }
                child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
                Object.defineProperty(child, propertyName, {
                  enumerable: false
                });
              }
            }
            return child;
          }
          return _clone(parent, depth);
        }
        clone2.clonePrototype = function clonePrototype(parent) {
          if (parent === null)
            return null;
          var c = function() {
          };
          c.prototype = parent;
          return new c();
        };
        function __objToStr(o) {
          return Object.prototype.toString.call(o);
        }
        clone2.__objToStr = __objToStr;
        function __isDate(o) {
          return typeof o === "object" && __objToStr(o) === "[object Date]";
        }
        clone2.__isDate = __isDate;
        function __isArray(o) {
          return typeof o === "object" && __objToStr(o) === "[object Array]";
        }
        clone2.__isArray = __isArray;
        function __isRegExp(o) {
          return typeof o === "object" && __objToStr(o) === "[object RegExp]";
        }
        clone2.__isRegExp = __isRegExp;
        function __getRegExpFlags(re) {
          var flags = "";
          if (re.global)
            flags += "g";
          if (re.ignoreCase)
            flags += "i";
          if (re.multiline)
            flags += "m";
          return flags;
        }
        clone2.__getRegExpFlags = __getRegExpFlags;
        return clone2;
      }();
      if (typeof module === "object" && module.exports) {
        module.exports = clone;
      }
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/errors-browser.js
  var require_errors_browser7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser7().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser7();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy7();
      var _require = require_state7();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser7().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex7();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex7();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable7();
      var Writable2 = require_stream_writable7();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser7().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream7();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser7();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list7();
      var destroyImpl = require_destroy7();
      var _require = require_state7();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser7().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex7();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex7();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator7();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser7();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser7().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex7();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform7();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser7().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream7();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/simple-websocket/node_modules/readable-stream/readable-browser.js
  var require_readable_browser7 = __commonJS({
    "node_modules/simple-websocket/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable7();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable7();
      exports.Duplex = require_stream_duplex7();
      exports.Transform = require_stream_transform7();
      exports.PassThrough = require_stream_passthrough7();
      exports.finished = require_end_of_stream7();
      exports.pipeline = require_pipeline7();
    }
  });

  // (disabled):node_modules/ws/browser.js
  var require_browser8 = __commonJS({
    "(disabled):node_modules/ws/browser.js"() {
      init_esbuild_inject();
    }
  });

  // node_modules/simple-websocket/index.js
  var require_simple_websocket = __commonJS({
    "node_modules/simple-websocket/index.js"(exports, module) {
      init_esbuild_inject();
      var debug2 = require_browser5()("simple-websocket");
      var randombytes = require_browser6();
      var stream = require_readable_browser7();
      var queueMicrotask2 = require_queue_microtask();
      var ws = require_browser8();
      var _WebSocket = typeof ws !== "function" ? WebSocket : ws;
      var MAX_BUFFERED_AMOUNT = 64 * 1024;
      var Socket = class extends stream.Duplex {
        constructor(opts = {}) {
          if (typeof opts === "string") {
            opts = { url: opts };
          }
          opts = Object.assign({
            allowHalfOpen: false
          }, opts);
          super(opts);
          if (opts.url == null && opts.socket == null) {
            throw new Error("Missing required `url` or `socket` option");
          }
          if (opts.url != null && opts.socket != null) {
            throw new Error("Must specify either `url` or `socket` option, not both");
          }
          this._id = randombytes(4).toString("hex").slice(0, 7);
          this._debug("new websocket: %o", opts);
          this.connected = false;
          this.destroyed = false;
          this._chunk = null;
          this._cb = null;
          this._interval = null;
          if (opts.socket) {
            this.url = opts.socket.url;
            this._ws = opts.socket;
            this.connected = opts.socket.readyState === _WebSocket.OPEN;
          } else {
            this.url = opts.url;
            try {
              if (typeof ws === "function") {
                this._ws = new _WebSocket(opts.url, null, {
                  ...opts,
                  encoding: void 0
                });
              } else {
                this._ws = new _WebSocket(opts.url);
              }
            } catch (err) {
              queueMicrotask2(() => this.destroy(err));
              return;
            }
          }
          this._ws.binaryType = "arraybuffer";
          if (opts.socket && this.connected) {
            queueMicrotask2(() => this._handleOpen());
          } else {
            this._ws.onopen = () => this._handleOpen();
          }
          this._ws.onmessage = (event) => this._handleMessage(event);
          this._ws.onclose = () => this._handleClose();
          this._ws.onerror = (err) => this._handleError(err);
          this._handleFinishBound = () => this._handleFinish();
          this.once("finish", this._handleFinishBound);
        }
        send(chunk) {
          this._ws.send(chunk);
        }
        destroy(err) {
          this._destroy(err, () => {
          });
        }
        _destroy(err, cb) {
          if (this.destroyed)
            return;
          this._debug("destroy (error: %s)", err && (err.message || err));
          this.readable = this.writable = false;
          if (!this._readableState.ended)
            this.push(null);
          if (!this._writableState.finished)
            this.end();
          this.connected = false;
          this.destroyed = true;
          clearInterval(this._interval);
          this._interval = null;
          this._chunk = null;
          this._cb = null;
          if (this._handleFinishBound) {
            this.removeListener("finish", this._handleFinishBound);
          }
          this._handleFinishBound = null;
          if (this._ws) {
            const ws2 = this._ws;
            const onClose = () => {
              ws2.onclose = null;
            };
            if (ws2.readyState === _WebSocket.CLOSED) {
              onClose();
            } else {
              try {
                ws2.onclose = onClose;
                ws2.close();
              } catch (err2) {
                onClose();
              }
            }
            ws2.onopen = null;
            ws2.onmessage = null;
            ws2.onerror = () => {
            };
          }
          this._ws = null;
          if (err)
            this.emit("error", err);
          this.emit("close");
          cb();
        }
        _read() {
        }
        _write(chunk, encoding, cb) {
          if (this.destroyed)
            return cb(new Error("cannot write after socket is destroyed"));
          if (this.connected) {
            try {
              this.send(chunk);
            } catch (err) {
              return this.destroy(err);
            }
            if (typeof ws !== "function" && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
              this._debug("start backpressure: bufferedAmount %d", this._ws.bufferedAmount);
              this._cb = cb;
            } else {
              cb(null);
            }
          } else {
            this._debug("write before connect");
            this._chunk = chunk;
            this._cb = cb;
          }
        }
        _handleOpen() {
          if (this.connected || this.destroyed)
            return;
          this.connected = true;
          if (this._chunk) {
            try {
              this.send(this._chunk);
            } catch (err) {
              return this.destroy(err);
            }
            this._chunk = null;
            this._debug('sent chunk from "write before connect"');
            const cb = this._cb;
            this._cb = null;
            cb(null);
          }
          if (typeof ws !== "function") {
            this._interval = setInterval(() => this._onInterval(), 150);
            if (this._interval.unref)
              this._interval.unref();
          }
          this._debug("connect");
          this.emit("connect");
        }
        _handleMessage(event) {
          if (this.destroyed)
            return;
          let data = event.data;
          if (data instanceof ArrayBuffer)
            data = Buffer3.from(data);
          this.push(data);
        }
        _handleClose() {
          if (this.destroyed)
            return;
          this._debug("on close");
          this.destroy();
        }
        _handleError(_) {
          this.destroy(new Error(`Error connecting to ${this.url}`));
        }
        _handleFinish() {
          if (this.destroyed)
            return;
          const destroySoon = () => {
            setTimeout(() => this.destroy(), 1e3);
          };
          if (this.connected) {
            destroySoon();
          } else {
            this.once("connect", destroySoon);
          }
        }
        _onInterval() {
          if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {
            return;
          }
          this._debug("ending backpressure: bufferedAmount %d", this._ws.bufferedAmount);
          const cb = this._cb;
          this._cb = null;
          cb(null);
        }
        _debug() {
          const args = [].slice.call(arguments);
          args[0] = "[" + this._id + "] " + args[0];
          debug2.apply(null, args);
        }
      };
      Socket.WEBSOCKET_SUPPORT = !!_WebSocket;
      module.exports = Socket;
    }
  });

  // (disabled):node_modules/socks/build/index.js
  var require_build = __commonJS({
    "(disabled):node_modules/socks/build/index.js"() {
      init_esbuild_inject();
    }
  });

  // node_modules/bittorrent-tracker/lib/client/tracker.js
  var require_tracker = __commonJS({
    "node_modules/bittorrent-tracker/lib/client/tracker.js"(exports, module) {
      init_esbuild_inject();
      var EventEmitter2 = require_events();
      var Tracker = class extends EventEmitter2 {
        constructor(client, announceUrl) {
          super();
          this.client = client;
          this.announceUrl = announceUrl;
          this.interval = null;
          this.destroyed = false;
        }
        setInterval(intervalMs) {
          if (intervalMs == null)
            intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL;
          clearInterval(this.interval);
          if (intervalMs) {
            this.interval = setInterval(() => {
              this.announce(this.client._defaultAnnounceOpts());
            }, intervalMs);
            if (this.interval.unref)
              this.interval.unref();
          }
        }
      };
      module.exports = Tracker;
    }
  });

  // node_modules/bittorrent-tracker/lib/client/websocket-tracker.js
  var require_websocket_tracker = __commonJS({
    "node_modules/bittorrent-tracker/lib/client/websocket-tracker.js"(exports, module) {
      init_esbuild_inject();
      var clone = require_clone();
      var debug2 = require_browser5()("bittorrent-tracker:websocket-tracker");
      var Peer = require_simple_peer();
      var randombytes = require_browser6();
      var Socket = require_simple_websocket();
      var Socks = require_build();
      var common = require_common3();
      var Tracker = require_tracker();
      var socketPool = {};
      var RECONNECT_MINIMUM = 10 * 1e3;
      var RECONNECT_MAXIMUM = 60 * 60 * 1e3;
      var RECONNECT_VARIANCE = 5 * 60 * 1e3;
      var OFFER_TIMEOUT = 50 * 1e3;
      var WebSocketTracker = class extends Tracker {
        constructor(client, announceUrl) {
          super(client, announceUrl);
          debug2("new websocket tracker %s", announceUrl);
          this.peers = {};
          this.socket = null;
          this.reconnecting = false;
          this.retries = 0;
          this.reconnectTimer = null;
          this.expectingResponse = false;
          this._openSocket();
        }
        announce(opts) {
          if (this.destroyed || this.reconnecting)
            return;
          if (!this.socket.connected) {
            this.socket.once("connect", () => {
              this.announce(opts);
            });
            return;
          }
          const params = Object.assign({}, opts, {
            action: "announce",
            info_hash: this.client._infoHashBinary,
            peer_id: this.client._peerIdBinary
          });
          if (this._trackerId)
            params.trackerid = this._trackerId;
          if (opts.event === "stopped" || opts.event === "completed") {
            this._send(params);
          } else {
            const numwant = Math.min(opts.numwant, 5);
            this._generateOffers(numwant, (offers) => {
              params.numwant = numwant;
              params.offers = offers;
              this._send(params);
            });
          }
        }
        scrape(opts) {
          if (this.destroyed || this.reconnecting)
            return;
          if (!this.socket.connected) {
            this.socket.once("connect", () => {
              this.scrape(opts);
            });
            return;
          }
          const infoHashes = Array.isArray(opts.infoHash) && opts.infoHash.length > 0 ? opts.infoHash.map((infoHash) => infoHash.toString("binary")) : opts.infoHash && opts.infoHash.toString("binary") || this.client._infoHashBinary;
          const params = {
            action: "scrape",
            info_hash: infoHashes
          };
          this._send(params);
        }
        destroy(cb = noop2) {
          if (this.destroyed)
            return cb(null);
          this.destroyed = true;
          clearInterval(this.interval);
          clearTimeout(this.reconnectTimer);
          for (const peerId in this.peers) {
            const peer = this.peers[peerId];
            clearTimeout(peer.trackerTimeout);
            peer.destroy();
          }
          this.peers = null;
          if (this.socket) {
            this.socket.removeListener("connect", this._onSocketConnectBound);
            this.socket.removeListener("data", this._onSocketDataBound);
            this.socket.removeListener("close", this._onSocketCloseBound);
            this.socket.removeListener("error", this._onSocketErrorBound);
            this.socket = null;
          }
          this._onSocketConnectBound = null;
          this._onSocketErrorBound = null;
          this._onSocketDataBound = null;
          this._onSocketCloseBound = null;
          if (socketPool[this.announceUrl]) {
            socketPool[this.announceUrl].consumers -= 1;
          }
          if (socketPool[this.announceUrl].consumers > 0)
            return cb();
          let socket = socketPool[this.announceUrl];
          delete socketPool[this.announceUrl];
          socket.on("error", noop2);
          socket.once("close", cb);
          let timeout;
          if (!this.expectingResponse)
            return destroyCleanup();
          timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT);
          socket.once("data", destroyCleanup);
          function destroyCleanup() {
            if (timeout) {
              clearTimeout(timeout);
              timeout = null;
            }
            socket.removeListener("data", destroyCleanup);
            socket.destroy();
            socket = null;
          }
        }
        _openSocket() {
          this.destroyed = false;
          if (!this.peers)
            this.peers = {};
          this._onSocketConnectBound = () => {
            this._onSocketConnect();
          };
          this._onSocketErrorBound = (err) => {
            this._onSocketError(err);
          };
          this._onSocketDataBound = (data) => {
            this._onSocketData(data);
          };
          this._onSocketCloseBound = () => {
            this._onSocketClose();
          };
          this.socket = socketPool[this.announceUrl];
          if (this.socket) {
            socketPool[this.announceUrl].consumers += 1;
            if (this.socket.connected) {
              this._onSocketConnectBound();
            }
          } else {
            const parsedUrl = new URL(this.announceUrl);
            let agent;
            if (this.client._proxyOpts) {
              agent = parsedUrl.protocol === "wss:" ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent;
              if (!agent && this.client._proxyOpts.socksProxy) {
                agent = new Socks.Agent(clone(this.client._proxyOpts.socksProxy), parsedUrl.protocol === "wss:");
              }
            }
            this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent });
            this.socket.consumers = 1;
            this.socket.once("connect", this._onSocketConnectBound);
          }
          this.socket.on("data", this._onSocketDataBound);
          this.socket.once("close", this._onSocketCloseBound);
          this.socket.once("error", this._onSocketErrorBound);
        }
        _onSocketConnect() {
          if (this.destroyed)
            return;
          if (this.reconnecting) {
            this.reconnecting = false;
            this.retries = 0;
            this.announce(this.client._defaultAnnounceOpts());
          }
        }
        _onSocketData(data) {
          if (this.destroyed)
            return;
          this.expectingResponse = false;
          try {
            data = JSON.parse(data);
          } catch (err) {
            this.client.emit("warning", new Error("Invalid tracker response"));
            return;
          }
          if (data.action === "announce") {
            this._onAnnounceResponse(data);
          } else if (data.action === "scrape") {
            this._onScrapeResponse(data);
          } else {
            this._onSocketError(new Error(`invalid action in WS response: ${data.action}`));
          }
        }
        _onAnnounceResponse(data) {
          if (data.info_hash !== this.client._infoHashBinary) {
            debug2("ignoring websocket data from %s for %s (looking for %s: reused socket)", this.announceUrl, common.binaryToHex(data.info_hash), this.client.infoHash);
            return;
          }
          if (data.peer_id && data.peer_id === this.client._peerIdBinary) {
            return;
          }
          debug2("received %s from %s for %s", JSON.stringify(data), this.announceUrl, this.client.infoHash);
          const failure = data["failure reason"];
          if (failure)
            return this.client.emit("warning", new Error(failure));
          const warning = data["warning message"];
          if (warning)
            this.client.emit("warning", new Error(warning));
          const interval = data.interval || data["min interval"];
          if (interval)
            this.setInterval(interval * 1e3);
          const trackerId = data["tracker id"];
          if (trackerId) {
            this._trackerId = trackerId;
          }
          if (data.complete != null) {
            const response = Object.assign({}, data, {
              announce: this.announceUrl,
              infoHash: common.binaryToHex(data.info_hash)
            });
            this.client.emit("update", response);
          }
          let peer;
          if (data.offer && data.peer_id) {
            debug2("creating peer (from remote offer)");
            peer = this._createPeer();
            peer.id = common.binaryToHex(data.peer_id);
            peer.once("signal", (answer) => {
              const params = {
                action: "announce",
                info_hash: this.client._infoHashBinary,
                peer_id: this.client._peerIdBinary,
                to_peer_id: data.peer_id,
                answer,
                offer_id: data.offer_id
              };
              if (this._trackerId)
                params.trackerid = this._trackerId;
              this._send(params);
            });
            this.client.emit("peer", peer);
            peer.signal(data.offer);
          }
          if (data.answer && data.peer_id) {
            const offerId = common.binaryToHex(data.offer_id);
            peer = this.peers[offerId];
            if (peer) {
              peer.id = common.binaryToHex(data.peer_id);
              this.client.emit("peer", peer);
              peer.signal(data.answer);
              clearTimeout(peer.trackerTimeout);
              peer.trackerTimeout = null;
              delete this.peers[offerId];
            } else {
              debug2(`got unexpected answer: ${JSON.stringify(data.answer)}`);
            }
          }
        }
        _onScrapeResponse(data) {
          data = data.files || {};
          const keys2 = Object.keys(data);
          if (keys2.length === 0) {
            this.client.emit("warning", new Error("invalid scrape response"));
            return;
          }
          keys2.forEach((infoHash) => {
            const response = Object.assign(data[infoHash], {
              announce: this.announceUrl,
              infoHash: common.binaryToHex(infoHash)
            });
            this.client.emit("scrape", response);
          });
        }
        _onSocketClose() {
          if (this.destroyed)
            return;
          this.destroy();
          this._startReconnectTimer();
        }
        _onSocketError(err) {
          if (this.destroyed)
            return;
          this.destroy();
          this.client.emit("warning", err);
          this._startReconnectTimer();
        }
        _startReconnectTimer() {
          const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM);
          this.reconnecting = true;
          clearTimeout(this.reconnectTimer);
          this.reconnectTimer = setTimeout(() => {
            this.retries++;
            this._openSocket();
          }, ms);
          if (this.reconnectTimer.unref)
            this.reconnectTimer.unref();
          debug2("reconnecting socket in %s ms", ms);
        }
        _send(params) {
          if (this.destroyed)
            return;
          this.expectingResponse = true;
          const message = JSON.stringify(params);
          debug2("send %s", message);
          this.socket.send(message);
        }
        _generateOffers(numwant, cb) {
          const self2 = this;
          const offers = [];
          debug2("generating %s offers", numwant);
          for (let i = 0; i < numwant; ++i) {
            generateOffer();
          }
          checkDone();
          function generateOffer() {
            const offerId = randombytes(20).toString("hex");
            debug2("creating peer (from _generateOffers)");
            const peer = self2.peers[offerId] = self2._createPeer({ initiator: true });
            peer.once("signal", (offer) => {
              offers.push({
                offer,
                offer_id: common.hexToBinary(offerId)
              });
              checkDone();
            });
            peer.trackerTimeout = setTimeout(() => {
              debug2("tracker timeout: destroying peer");
              peer.trackerTimeout = null;
              delete self2.peers[offerId];
              peer.destroy();
            }, OFFER_TIMEOUT);
            if (peer.trackerTimeout.unref)
              peer.trackerTimeout.unref();
          }
          function checkDone() {
            if (offers.length === numwant) {
              debug2("generated %s offers", numwant);
              cb(offers);
            }
          }
        }
        _createPeer(opts) {
          const self2 = this;
          opts = Object.assign({
            trickle: false,
            config: self2.client._rtcConfig,
            wrtc: self2.client._wrtc
          }, opts);
          const peer = new Peer(opts);
          peer.once("error", onError);
          peer.once("connect", onConnect);
          return peer;
          function onError(err) {
            self2.client.emit("warning", new Error(`Connection error: ${err.message}`));
            peer.destroy();
          }
          function onConnect() {
            peer.removeListener("error", onError);
            peer.removeListener("connect", onConnect);
          }
        }
      };
      WebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30 * 1e3;
      WebSocketTracker._socketPool = socketPool;
      function noop2() {
      }
      module.exports = WebSocketTracker;
    }
  });

  // node_modules/bittorrent-tracker/client.js
  var require_client2 = __commonJS({
    "node_modules/bittorrent-tracker/client.js"(exports, module) {
      init_esbuild_inject();
      var debug2 = require_browser5()("bittorrent-tracker:client");
      var EventEmitter2 = require_events();
      var once3 = require_once();
      var parallel = require_run_parallel();
      var Peer = require_simple_peer();
      var queueMicrotask2 = require_queue_microtask();
      var common = require_common3();
      var HTTPTracker = require_http_tracker();
      var UDPTracker = require_udp_tracker();
      var WebSocketTracker = require_websocket_tracker();
      var Client = class extends EventEmitter2 {
        constructor(opts = {}) {
          super();
          if (!opts.peerId)
            throw new Error("Option `peerId` is required");
          if (!opts.infoHash)
            throw new Error("Option `infoHash` is required");
          if (!opts.announce)
            throw new Error("Option `announce` is required");
          if (!process.browser && !opts.port)
            throw new Error("Option `port` is required");
          this.peerId = typeof opts.peerId === "string" ? opts.peerId : opts.peerId.toString("hex");
          this._peerIdBuffer = Buffer3.from(this.peerId, "hex");
          this._peerIdBinary = this._peerIdBuffer.toString("binary");
          this.infoHash = typeof opts.infoHash === "string" ? opts.infoHash.toLowerCase() : opts.infoHash.toString("hex");
          this._infoHashBuffer = Buffer3.from(this.infoHash, "hex");
          this._infoHashBinary = this._infoHashBuffer.toString("binary");
          debug2("new client %s", this.infoHash);
          this.destroyed = false;
          this._port = opts.port;
          this._getAnnounceOpts = opts.getAnnounceOpts;
          this._rtcConfig = opts.rtcConfig;
          this._userAgent = opts.userAgent;
          this._proxyOpts = opts.proxyOpts;
          this._wrtc = typeof opts.wrtc === "function" ? opts.wrtc() : opts.wrtc;
          let announce = typeof opts.announce === "string" ? [opts.announce] : opts.announce == null ? [] : opts.announce;
          announce = announce.map((announceUrl) => {
            announceUrl = announceUrl.toString();
            if (announceUrl[announceUrl.length - 1] === "/") {
              announceUrl = announceUrl.substring(0, announceUrl.length - 1);
            }
            return announceUrl;
          });
          announce = Array.from(new Set(announce));
          const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT);
          const nextTickWarn = (err) => {
            queueMicrotask2(() => {
              this.emit("warning", err);
            });
          };
          this._trackers = announce.map((announceUrl) => {
            let parsedUrl;
            try {
              parsedUrl = common.parseUrl(announceUrl);
            } catch (err) {
              nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`));
              return null;
            }
            const port = parsedUrl.port;
            if (port < 0 || port > 65535) {
              nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`));
              return null;
            }
            const protocol = parsedUrl.protocol;
            if ((protocol === "http:" || protocol === "https:") && typeof HTTPTracker === "function") {
              return new HTTPTracker(this, announceUrl);
            } else if (protocol === "udp:" && typeof UDPTracker === "function") {
              return new UDPTracker(this, announceUrl);
            } else if ((protocol === "ws:" || protocol === "wss:") && webrtcSupport) {
              if (protocol === "ws:" && typeof window !== "undefined" && window.location.protocol === "https:") {
                nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`));
                return null;
              }
              return new WebSocketTracker(this, announceUrl);
            } else {
              nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`));
              return null;
            }
          }).filter(Boolean);
        }
        start(opts) {
          opts = this._defaultAnnounceOpts(opts);
          opts.event = "started";
          debug2("send `start` %o", opts);
          this._announce(opts);
          this._trackers.forEach((tracker) => {
            tracker.setInterval();
          });
        }
        stop(opts) {
          opts = this._defaultAnnounceOpts(opts);
          opts.event = "stopped";
          debug2("send `stop` %o", opts);
          this._announce(opts);
        }
        complete(opts) {
          if (!opts)
            opts = {};
          opts = this._defaultAnnounceOpts(opts);
          opts.event = "completed";
          debug2("send `complete` %o", opts);
          this._announce(opts);
        }
        update(opts) {
          opts = this._defaultAnnounceOpts(opts);
          if (opts.event)
            delete opts.event;
          debug2("send `update` %o", opts);
          this._announce(opts);
        }
        _announce(opts) {
          this._trackers.forEach((tracker) => {
            tracker.announce(opts);
          });
        }
        scrape(opts) {
          debug2("send `scrape`");
          if (!opts)
            opts = {};
          this._trackers.forEach((tracker) => {
            tracker.scrape(opts);
          });
        }
        setInterval(intervalMs) {
          debug2("setInterval %d", intervalMs);
          this._trackers.forEach((tracker) => {
            tracker.setInterval(intervalMs);
          });
        }
        destroy(cb) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          debug2("destroy");
          const tasks = this._trackers.map((tracker) => (cb2) => {
            tracker.destroy(cb2);
          });
          parallel(tasks, cb);
          this._trackers = [];
          this._getAnnounceOpts = null;
        }
        _defaultAnnounceOpts(opts = {}) {
          if (opts.numwant == null)
            opts.numwant = common.DEFAULT_ANNOUNCE_PEERS;
          if (opts.uploaded == null)
            opts.uploaded = 0;
          if (opts.downloaded == null)
            opts.downloaded = 0;
          if (this._getAnnounceOpts)
            opts = Object.assign({}, opts, this._getAnnounceOpts());
          return opts;
        }
      };
      Client.scrape = (opts, cb) => {
        cb = once3(cb);
        if (!opts.infoHash)
          throw new Error("Option `infoHash` is required");
        if (!opts.announce)
          throw new Error("Option `announce` is required");
        const clientOpts = Object.assign({}, opts, {
          infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,
          peerId: Buffer3.from("01234567890123456789"),
          port: 6881
        });
        const client = new Client(clientOpts);
        client.once("error", cb);
        client.once("warning", cb);
        let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1;
        const results = {};
        client.on("scrape", (data) => {
          len -= 1;
          results[data.infoHash] = data;
          if (len === 0) {
            client.destroy();
            const keys2 = Object.keys(results);
            if (keys2.length === 1) {
              cb(null, results[keys2[0]]);
            } else {
              cb(null, results);
            }
          }
        });
        opts.infoHash = Array.isArray(opts.infoHash) ? opts.infoHash.map((infoHash) => Buffer3.from(infoHash, "hex")) : Buffer3.from(opts.infoHash, "hex");
        client.scrape({ infoHash: opts.infoHash });
        return client;
      };
      module.exports = Client;
    }
  });

  // (disabled):node_modules/bittorrent-lsd/index.js
  var require_bittorrent_lsd = __commonJS({
    "(disabled):node_modules/bittorrent-lsd/index.js"() {
      init_esbuild_inject();
    }
  });

  // node_modules/torrent-discovery/index.js
  var require_torrent_discovery = __commonJS({
    "node_modules/torrent-discovery/index.js"(exports, module) {
      init_esbuild_inject();
      var debug2 = require_browser5()("torrent-discovery");
      var DHT = require_client();
      var EventEmitter2 = require_events().EventEmitter;
      var parallel = require_run_parallel();
      var Tracker = require_client2();
      var LSD = require_bittorrent_lsd();
      var Discovery = class extends EventEmitter2 {
        constructor(opts) {
          super();
          if (!opts.peerId)
            throw new Error("Option `peerId` is required");
          if (!opts.infoHash)
            throw new Error("Option `infoHash` is required");
          if (!process.browser && !opts.port)
            throw new Error("Option `port` is required");
          this.peerId = typeof opts.peerId === "string" ? opts.peerId : opts.peerId.toString("hex");
          this.infoHash = typeof opts.infoHash === "string" ? opts.infoHash.toLowerCase() : opts.infoHash.toString("hex");
          this._port = opts.port;
          this._userAgent = opts.userAgent;
          this.destroyed = false;
          this._announce = opts.announce || [];
          this._intervalMs = opts.intervalMs || 15 * 60 * 1e3;
          this._trackerOpts = null;
          this._dhtAnnouncing = false;
          this._dhtTimeout = false;
          this._internalDHT = false;
          this._onWarning = (err) => {
            this.emit("warning", err);
          };
          this._onError = (err) => {
            this.emit("error", err);
          };
          this._onDHTPeer = (peer, infoHash) => {
            if (infoHash.toString("hex") !== this.infoHash)
              return;
            this.emit("peer", `${peer.host}:${peer.port}`, "dht");
          };
          this._onTrackerPeer = (peer) => {
            this.emit("peer", peer, "tracker");
          };
          this._onTrackerAnnounce = () => {
            this.emit("trackerAnnounce");
          };
          this._onLSDPeer = (peer, infoHash) => {
            this.emit("peer", peer, "lsd");
          };
          const createDHT = (port, opts2) => {
            const dht = new DHT(opts2);
            dht.on("warning", this._onWarning);
            dht.on("error", this._onError);
            dht.listen(port);
            this._internalDHT = true;
            return dht;
          };
          if (opts.tracker === false) {
            this.tracker = null;
          } else if (opts.tracker && typeof opts.tracker === "object") {
            this._trackerOpts = Object.assign({}, opts.tracker);
            this.tracker = this._createTracker();
          } else {
            this.tracker = this._createTracker();
          }
          if (opts.dht === false || typeof DHT !== "function") {
            this.dht = null;
          } else if (opts.dht && typeof opts.dht.addNode === "function") {
            this.dht = opts.dht;
          } else if (opts.dht && typeof opts.dht === "object") {
            this.dht = createDHT(opts.dhtPort, opts.dht);
          } else {
            this.dht = createDHT(opts.dhtPort);
          }
          if (this.dht) {
            this.dht.on("peer", this._onDHTPeer);
            this._dhtAnnounce();
          }
          if (opts.lsd === false || typeof LSD !== "function") {
            this.lsd = null;
          } else {
            this.lsd = this._createLSD();
          }
        }
        updatePort(port) {
          if (port === this._port)
            return;
          this._port = port;
          if (this.dht)
            this._dhtAnnounce();
          if (this.tracker) {
            this.tracker.stop();
            this.tracker.destroy(() => {
              this.tracker = this._createTracker();
            });
          }
        }
        complete(opts) {
          if (this.tracker) {
            this.tracker.complete(opts);
          }
        }
        destroy(cb) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          clearTimeout(this._dhtTimeout);
          const tasks = [];
          if (this.tracker) {
            this.tracker.stop();
            this.tracker.removeListener("warning", this._onWarning);
            this.tracker.removeListener("error", this._onError);
            this.tracker.removeListener("peer", this._onTrackerPeer);
            this.tracker.removeListener("update", this._onTrackerAnnounce);
            tasks.push((cb2) => {
              this.tracker.destroy(cb2);
            });
          }
          if (this.dht) {
            this.dht.removeListener("peer", this._onDHTPeer);
          }
          if (this._internalDHT) {
            this.dht.removeListener("warning", this._onWarning);
            this.dht.removeListener("error", this._onError);
            tasks.push((cb2) => {
              this.dht.destroy(cb2);
            });
          }
          if (this.lsd) {
            this.lsd.removeListener("warning", this._onWarning);
            this.lsd.removeListener("error", this._onError);
            this.lsd.removeListener("peer", this._onLSDPeer);
            tasks.push((cb2) => {
              this.lsd.destroy(cb2);
            });
          }
          parallel(tasks, cb);
          this.dht = null;
          this.tracker = null;
          this.lsd = null;
          this._announce = null;
        }
        _createTracker() {
          const opts = Object.assign({}, this._trackerOpts, {
            infoHash: this.infoHash,
            announce: this._announce,
            peerId: this.peerId,
            port: this._port,
            userAgent: this._userAgent
          });
          const tracker = new Tracker(opts);
          tracker.on("warning", this._onWarning);
          tracker.on("error", this._onError);
          tracker.on("peer", this._onTrackerPeer);
          tracker.on("update", this._onTrackerAnnounce);
          tracker.setInterval(this._intervalMs);
          tracker.start();
          return tracker;
        }
        _dhtAnnounce() {
          if (this._dhtAnnouncing)
            return;
          debug2("dht announce");
          this._dhtAnnouncing = true;
          clearTimeout(this._dhtTimeout);
          this.dht.announce(this.infoHash, this._port, (err) => {
            this._dhtAnnouncing = false;
            debug2("dht announce complete");
            if (err)
              this.emit("warning", err);
            this.emit("dhtAnnounce");
            if (!this.destroyed) {
              this._dhtTimeout = setTimeout(() => {
                this._dhtAnnounce();
              }, this._intervalMs + Math.floor(Math.random() * this._intervalMs / 5));
              if (this._dhtTimeout.unref)
                this._dhtTimeout.unref();
            }
          });
        }
        _createLSD() {
          const opts = Object.assign({}, {
            infoHash: this.infoHash,
            peerId: this.peerId,
            port: this._port
          });
          const lsd = new LSD(opts);
          lsd.on("warning", this._onWarning);
          lsd.on("error", this._onError);
          lsd.on("peer", this._onLSDPeer);
          lsd.start();
          return lsd;
        }
      };
      module.exports = Discovery;
    }
  });

  // node_modules/memory-chunk-store/index.js
  var require_memory_chunk_store = __commonJS({
    "node_modules/memory-chunk-store/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = Storage;
      var queueMicrotask2 = require_queue_microtask();
      function Storage(chunkLength, opts) {
        if (!(this instanceof Storage))
          return new Storage(chunkLength, opts);
        if (!opts)
          opts = {};
        this.chunkLength = Number(chunkLength);
        if (!this.chunkLength)
          throw new Error("First argument must be a chunk length");
        this.chunks = [];
        this.closed = false;
        this.length = Number(opts.length) || Infinity;
        if (this.length !== Infinity) {
          this.lastChunkLength = this.length % this.chunkLength || this.chunkLength;
          this.lastChunkIndex = Math.ceil(this.length / this.chunkLength) - 1;
        }
      }
      Storage.prototype.put = function(index, buf, cb = () => {
      }) {
        if (this.closed)
          return queueMicrotask2(() => cb(new Error("Storage is closed")));
        const isLastChunk = index === this.lastChunkIndex;
        if (isLastChunk && buf.length !== this.lastChunkLength) {
          return queueMicrotask2(() => cb(new Error("Last chunk length must be " + this.lastChunkLength)));
        }
        if (!isLastChunk && buf.length !== this.chunkLength) {
          return queueMicrotask2(() => cb(new Error("Chunk length must be " + this.chunkLength)));
        }
        this.chunks[index] = buf;
        queueMicrotask2(() => cb(null));
      };
      Storage.prototype.get = function(index, opts, cb = () => {
      }) {
        if (typeof opts === "function")
          return this.get(index, null, opts);
        if (this.closed)
          return queueMicrotask2(() => cb(new Error("Storage is closed")));
        let buf = this.chunks[index];
        if (!buf) {
          const err = new Error("Chunk not found");
          err.notFound = true;
          return queueMicrotask2(() => cb(err));
        }
        if (!opts)
          opts = {};
        const offset = opts.offset || 0;
        const len = opts.length || buf.length - offset;
        if (offset !== 0 || len !== buf.length) {
          buf = buf.slice(offset, len + offset);
        }
        queueMicrotask2(() => cb(null, buf));
      };
      Storage.prototype.close = Storage.prototype.destroy = function(cb = () => {
      }) {
        if (this.closed)
          return queueMicrotask2(() => cb(new Error("Storage is closed")));
        this.closed = true;
        this.chunks = null;
        queueMicrotask2(() => cb(null));
      };
    }
  });

  // (disabled):node_modules/webtorrent/node_modules/decompress-response/index.js
  var require_decompress_response2 = __commonJS({
    "(disabled):node_modules/webtorrent/node_modules/decompress-response/index.js"() {
      init_esbuild_inject();
    }
  });

  // node_modules/webtorrent/node_modules/simple-get/index.js
  var require_simple_get2 = __commonJS({
    "node_modules/webtorrent/node_modules/simple-get/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = simpleGet;
      var concat2 = require_simple_concat();
      var decompressResponse = require_decompress_response2();
      var http = require_http();
      var https = require_https();
      var once3 = require_once();
      var querystring = require_querystring();
      var url = require_url();
      var isStream = (o) => o !== null && typeof o === "object" && typeof o.pipe === "function";
      function simpleGet(opts, cb) {
        opts = Object.assign({ maxRedirects: 10 }, typeof opts === "string" ? { url: opts } : opts);
        cb = once3(cb);
        if (opts.url) {
          const { hostname: hostname2, port, protocol: protocol2, auth, path } = url.parse(opts.url);
          delete opts.url;
          if (!hostname2 && !port && !protocol2 && !auth)
            opts.path = path;
          else
            Object.assign(opts, { hostname: hostname2, port, protocol: protocol2, auth, path });
        }
        const headers = { "accept-encoding": "gzip, deflate" };
        if (opts.headers)
          Object.keys(opts.headers).forEach((k) => headers[k.toLowerCase()] = opts.headers[k]);
        opts.headers = headers;
        let body;
        if (opts.body) {
          body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body;
        } else if (opts.form) {
          body = typeof opts.form === "string" ? opts.form : querystring.stringify(opts.form);
          opts.headers["content-type"] = "application/x-www-form-urlencoded";
        }
        if (body) {
          if (!opts.method)
            opts.method = "POST";
          if (!isStream(body))
            opts.headers["content-length"] = Buffer3.byteLength(body);
          if (opts.json && !opts.form)
            opts.headers["content-type"] = "application/json";
        }
        delete opts.body;
        delete opts.form;
        if (opts.json)
          opts.headers.accept = "application/json";
        if (opts.method)
          opts.method = opts.method.toUpperCase();
        const originalHost = opts.hostname;
        const protocol = opts.protocol === "https:" ? https : http;
        const req = protocol.request(opts, (res) => {
          if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
            opts.url = res.headers.location;
            delete opts.headers.host;
            res.resume();
            const redirectHost = url.parse(opts.url).hostname;
            if (redirectHost !== null && redirectHost !== originalHost) {
              delete opts.headers.cookie;
              delete opts.headers.authorization;
            }
            if (opts.method === "POST" && [301, 302].includes(res.statusCode)) {
              opts.method = "GET";
              delete opts.headers["content-length"];
              delete opts.headers["content-type"];
            }
            if (opts.maxRedirects-- === 0)
              return cb(new Error("too many redirects"));
            else
              return simpleGet(opts, cb);
          }
          const tryUnzip = typeof decompressResponse === "function" && opts.method !== "HEAD";
          cb(null, tryUnzip ? decompressResponse(res) : res);
        });
        req.on("timeout", () => {
          req.abort();
          cb(new Error("Request timed out"));
        });
        req.on("error", cb);
        if (isStream(body))
          body.on("error", cb).pipe(req);
        else
          req.end(body);
        return req;
      }
      simpleGet.concat = (opts, cb) => {
        return simpleGet(opts, (err, res) => {
          if (err)
            return cb(err);
          concat2(res, (err2, data) => {
            if (err2)
              return cb(err2);
            if (opts.json) {
              try {
                data = JSON.parse(data.toString());
              } catch (err3) {
                return cb(err3, res, data);
              }
            }
            cb(null, res, data);
          });
        });
      };
      ["get", "post", "put", "patch", "head", "delete"].forEach((method) => {
        simpleGet[method] = (opts, cb) => {
          if (typeof opts === "string")
            opts = { url: opts };
          return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb);
        };
      });
    }
  });

  // node_modules/immediate-chunk-store/index.js
  var require_immediate_chunk_store = __commonJS({
    "node_modules/immediate-chunk-store/index.js"(exports, module) {
      init_esbuild_inject();
      var queueMicrotask2 = require_queue_microtask();
      var ImmediateStore = class {
        constructor(store) {
          this.store = store;
          this.chunkLength = store.chunkLength;
          if (!this.store || !this.store.get || !this.store.put) {
            throw new Error("First argument must be abstract-chunk-store compliant");
          }
          this.mem = [];
        }
        put(index, buf, cb = () => {
        }) {
          this.mem[index] = buf;
          this.store.put(index, buf, (err) => {
            this.mem[index] = null;
            cb(err);
          });
        }
        get(index, opts, cb = () => {
        }) {
          if (typeof opts === "function")
            return this.get(index, null, opts);
          let buf = this.mem[index];
          if (!buf) {
            return this.store.get(index, opts, cb);
          }
          if (!opts)
            opts = {};
          const offset = opts.offset || 0;
          const len = opts.length || buf.length - offset;
          if (offset !== 0 || len !== buf.length) {
            buf = buf.slice(offset, len + offset);
          }
          queueMicrotask2(() => cb(null, buf));
        }
        close(cb = () => {
        }) {
          this.store.close(cb);
        }
        destroy(cb = () => {
        }) {
          this.store.destroy(cb);
        }
      };
      module.exports = ImmediateStore;
    }
  });

  // node_modules/unordered-array-remove/index.js
  var require_unordered_array_remove = __commonJS({
    "node_modules/unordered-array-remove/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = remove;
      function remove(arr, i) {
        if (i >= arr.length || i < 0)
          return;
        var last = arr.pop();
        if (i < arr.length) {
          var tmp = arr[i];
          arr[i] = last;
          return tmp;
        }
        return last;
      }
    }
  });

  // node_modules/lt_donthave/index.js
  var require_lt_donthave = __commonJS({
    "node_modules/lt_donthave/index.js"(exports, module) {
      init_esbuild_inject();
      var arrayRemove = require_unordered_array_remove();
      var { EventEmitter: EventEmitter2 } = require_events();
      var debug2 = require_browser5()("lt_donthave");
      module.exports = () => {
        class ltDontHave extends EventEmitter2 {
          constructor(wire) {
            super();
            this._peerSupports = false;
            this._wire = wire;
          }
          onExtendedHandshake() {
            this._peerSupports = true;
          }
          onMessage(buf) {
            let index;
            try {
              index = buf.readUInt32BE();
            } catch (err) {
              return;
            }
            if (!this._wire.peerPieces.get(index))
              return;
            debug2("got donthave %d", index);
            this._wire.peerPieces.set(index, false);
            this.emit("donthave", index);
            this._failRequests(index);
          }
          donthave(index) {
            if (!this._peerSupports)
              return;
            debug2("donthave %d", index);
            const buf = Buffer3.alloc(4);
            buf.writeUInt32BE(index);
            this._wire.extended("lt_donthave", buf);
          }
          _failRequests(index) {
            const requests = this._wire.requests;
            for (let i = 0; i < requests.length; i++) {
              const req = requests[i];
              if (req.piece === index) {
                arrayRemove(requests, i);
                i -= 1;
                this._wire._callback(req, new Error("peer sent donthave"), null);
              }
            }
          }
        }
        ltDontHave.prototype.name = "lt_donthave";
        return ltDontHave;
      };
    }
  });

  // node_modules/run-parallel-limit/index.js
  var require_run_parallel_limit = __commonJS({
    "node_modules/run-parallel-limit/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = runParallelLimit;
      var queueMicrotask2 = require_queue_microtask();
      function runParallelLimit(tasks, limit, cb) {
        if (typeof limit !== "number")
          throw new Error("second argument must be a Number");
        let results, len, pending, keys2, isErrored;
        let isSync = true;
        let next;
        if (Array.isArray(tasks)) {
          results = [];
          pending = len = tasks.length;
        } else {
          keys2 = Object.keys(tasks);
          results = {};
          pending = len = keys2.length;
        }
        function done2(err) {
          function end() {
            if (cb)
              cb(err, results);
            cb = null;
          }
          if (isSync)
            queueMicrotask2(end);
          else
            end();
        }
        function each(i, err, result) {
          results[i] = result;
          if (err)
            isErrored = true;
          if (--pending === 0 || err) {
            done2(err);
          } else if (!isErrored && next < len) {
            let key;
            if (keys2) {
              key = keys2[next];
              next += 1;
              tasks[key](function(err2, result2) {
                each(key, err2, result2);
              });
            } else {
              key = next;
              next += 1;
              tasks[key](function(err2, result2) {
                each(key, err2, result2);
              });
            }
          }
        }
        next = limit;
        if (!pending) {
          done2(null);
        } else if (keys2) {
          keys2.some(function(key, i) {
            tasks[key](function(err, result) {
              each(key, err, result);
            });
            if (i === limit - 1)
              return true;
            return false;
          });
        } else {
          tasks.some(function(task, i) {
            task(function(err, result) {
              each(i, err, result);
            });
            if (i === limit - 1)
              return true;
            return false;
          });
        }
        isSync = false;
      }
    }
  });

  // node_modules/torrent-piece/index.js
  var require_torrent_piece = __commonJS({
    "node_modules/torrent-piece/index.js"(exports, module) {
      init_esbuild_inject();
      var BLOCK_LENGTH = 1 << 14;
      var Piece = class {
        constructor(length) {
          this.length = length;
          this.missing = length;
          this.sources = null;
          this._chunks = Math.ceil(length / BLOCK_LENGTH);
          this._remainder = length % BLOCK_LENGTH || BLOCK_LENGTH;
          this._buffered = 0;
          this._buffer = null;
          this._cancellations = null;
          this._reservations = 0;
          this._flushed = false;
        }
        chunkLength(i) {
          return i === this._chunks - 1 ? this._remainder : BLOCK_LENGTH;
        }
        chunkLengthRemaining(i) {
          return this.length - i * BLOCK_LENGTH;
        }
        chunkOffset(i) {
          return i * BLOCK_LENGTH;
        }
        reserve() {
          if (!this.init())
            return -1;
          if (this._cancellations.length)
            return this._cancellations.pop();
          if (this._reservations < this._chunks)
            return this._reservations++;
          return -1;
        }
        reserveRemaining() {
          if (!this.init())
            return -1;
          if (this._cancellations.length || this._reservations < this._chunks) {
            let min = this._reservations;
            while (this._cancellations.length) {
              min = Math.min(min, this._cancellations.pop());
            }
            this._reservations = this._chunks;
            return min;
          }
          return -1;
        }
        cancel(i) {
          if (!this.init())
            return;
          this._cancellations.push(i);
        }
        cancelRemaining(i) {
          if (!this.init())
            return;
          this._reservations = i;
        }
        get(i) {
          if (!this.init())
            return null;
          return this._buffer[i];
        }
        set(i, data, source) {
          if (!this.init())
            return false;
          const len = data.length;
          const blocks = Math.ceil(len / BLOCK_LENGTH);
          for (let j = 0; j < blocks; j++) {
            if (!this._buffer[i + j]) {
              const offset = j * BLOCK_LENGTH;
              const splitData = data.slice(offset, offset + BLOCK_LENGTH);
              this._buffered++;
              this._buffer[i + j] = splitData;
              this.missing -= splitData.length;
              if (!this.sources.includes(source)) {
                this.sources.push(source);
              }
            }
          }
          return this._buffered === this._chunks;
        }
        flush() {
          if (!this._buffer || this._chunks !== this._buffered)
            return null;
          const buffer = Buffer3.concat(this._buffer, this.length);
          this._buffer = null;
          this._cancellations = null;
          this.sources = null;
          this._flushed = true;
          return buffer;
        }
        init() {
          if (this._flushed)
            return false;
          if (this._buffer)
            return true;
          this._buffer = new Array(this._chunks);
          this._cancellations = [];
          this.sources = [];
          return true;
        }
      };
      Object.defineProperty(Piece, "BLOCK_LENGTH", { value: BLOCK_LENGTH });
      module.exports = Piece;
    }
  });

  // node_modules/end-of-stream/index.js
  var require_end_of_stream8 = __commonJS({
    "node_modules/end-of-stream/index.js"(exports, module) {
      init_esbuild_inject();
      var once3 = require_once();
      var noop2 = function() {
      };
      var isRequest = function(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      };
      var isChildProcess = function(stream) {
        return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
      };
      var eos = function(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var ws = stream._writableState;
        var rs = stream._readableState;
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var cancelled = false;
        var onlegacyfinish = function() {
          if (!stream.writable)
            onfinish();
        };
        var onfinish = function() {
          writable = false;
          if (!readable)
            callback.call(stream);
        };
        var onend2 = function() {
          readable = false;
          if (!writable)
            callback.call(stream);
        };
        var onexit = function(exitCode) {
          callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
        };
        var onerror = function(err) {
          callback.call(stream, err);
        };
        var onclose = function() {
          process.nextTick(onclosenexttick);
        };
        var onclosenexttick = function() {
          if (cancelled)
            return;
          if (readable && !(rs && (rs.ended && !rs.destroyed)))
            return callback.call(stream, new Error("premature close"));
          if (writable && !(ws && (ws.ended && !ws.destroyed)))
            return callback.call(stream, new Error("premature close"));
        };
        var onrequest = function() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !ws) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        if (isChildProcess(stream))
          stream.on("exit", onexit);
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          cancelled = true;
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("exit", onexit);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      };
      module.exports = eos;
    }
  });

  // node_modules/pump/index.js
  var require_pump = __commonJS({
    "node_modules/pump/index.js"(exports, module) {
      init_esbuild_inject();
      var once3 = require_once();
      var eos = require_end_of_stream8();
      var fs = require_fs();
      var noop2 = function() {
      };
      var ancient = /^v?\.0/.test(process.version);
      var isFn = function(fn) {
        return typeof fn === "function";
      };
      var isFS = function(stream) {
        if (!ancient)
          return false;
        if (!fs)
          return false;
        return (stream instanceof (fs.ReadStream || noop2) || stream instanceof (fs.WriteStream || noop2)) && isFn(stream.close);
      };
      var isRequest = function(stream) {
        return stream.setHeader && isFn(stream.abort);
      };
      var destroyer = function(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        eos(stream, { readable: reading, writable: writing }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isFS(stream))
            return stream.close(noop2);
          if (isRequest(stream))
            return stream.abort();
          if (isFn(stream.destroy))
            return stream.destroy();
          callback(err || new Error("stream was destroyed"));
        };
      };
      var call = function(fn) {
        fn();
      };
      var pipe = function(from2, to) {
        return from2.pipe(to);
      };
      var pump = function() {
        var streams = Array.prototype.slice.call(arguments);
        var callback = isFn(streams[streams.length - 1] || noop2) && streams.pop() || noop2;
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2)
          throw new Error("pump requires two streams per minimum");
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      };
      module.exports = pump;
    }
  });

  // node_modules/random-iterate/index.js
  var require_random_iterate = __commonJS({
    "node_modules/random-iterate/index.js"(exports, module) {
      init_esbuild_inject();
      var iterate = function(list) {
        var offset = 0;
        return function() {
          if (offset === list.length)
            return null;
          var len = list.length - offset;
          var i = Math.random() * len | 0;
          var el = list[offset + i];
          var tmp = list[offset];
          list[offset] = el;
          list[offset + i] = tmp;
          offset++;
          return el;
        };
      };
      module.exports = iterate;
    }
  });

  // node_modules/ut_metadata/index.js
  var require_ut_metadata = __commonJS({
    "node_modules/ut_metadata/index.js"(exports, module) {
      init_esbuild_inject();
      var { EventEmitter: EventEmitter2 } = require_events();
      var bencode = require_lib();
      var BitField = require_lib2().default;
      var debug2 = require_browser5()("ut_metadata");
      var sha1 = require_browser4();
      var MAX_METADATA_SIZE = 1e7;
      var BITFIELD_GROW = 1e3;
      var PIECE_LENGTH = 1 << 14;
      module.exports = (metadata) => {
        class utMetadata extends EventEmitter2 {
          constructor(wire) {
            super();
            this._wire = wire;
            this._fetching = false;
            this._metadataComplete = false;
            this._metadataSize = null;
            this._remainingRejects = null;
            this._bitfield = new BitField(0, { grow: BITFIELD_GROW });
            if (Buffer3.isBuffer(metadata)) {
              this.setMetadata(metadata);
            }
          }
          onHandshake(infoHash, peerId, extensions) {
            this._infoHash = infoHash;
          }
          onExtendedHandshake(handshake) {
            if (!handshake.m || !handshake.m.ut_metadata) {
              return this.emit("warning", new Error("Peer does not support ut_metadata"));
            }
            if (!handshake.metadata_size) {
              return this.emit("warning", new Error("Peer does not have metadata"));
            }
            if (typeof handshake.metadata_size !== "number" || MAX_METADATA_SIZE < handshake.metadata_size || handshake.metadata_size <= 0) {
              return this.emit("warning", new Error("Peer gave invalid metadata size"));
            }
            this._metadataSize = handshake.metadata_size;
            this._numPieces = Math.ceil(this._metadataSize / PIECE_LENGTH);
            this._remainingRejects = this._numPieces * 2;
            this._requestPieces();
          }
          onMessage(buf) {
            let dict;
            let trailer;
            try {
              const str = buf.toString();
              const trailerIndex = str.indexOf("ee") + 2;
              dict = bencode.decode(str.substring(0, trailerIndex));
              trailer = buf.slice(trailerIndex);
            } catch (err) {
              return;
            }
            switch (dict.msg_type) {
              case 0:
                this._onRequest(dict.piece);
                break;
              case 1:
                this._onData(dict.piece, trailer, dict.total_size);
                break;
              case 2:
                this._onReject(dict.piece);
                break;
            }
          }
          fetch() {
            if (this._metadataComplete) {
              return;
            }
            this._fetching = true;
            if (this._metadataSize) {
              this._requestPieces();
            }
          }
          cancel() {
            this._fetching = false;
          }
          setMetadata(metadata2) {
            if (this._metadataComplete)
              return true;
            debug2("set metadata");
            try {
              const info = bencode.decode(metadata2).info;
              if (info) {
                metadata2 = bencode.encode(info);
              }
            } catch (err) {
            }
            if (this._infoHash && this._infoHash !== sha1.sync(metadata2)) {
              return false;
            }
            this.cancel();
            this.metadata = metadata2;
            this._metadataComplete = true;
            this._metadataSize = this.metadata.length;
            this._wire.extendedHandshake.metadata_size = this._metadataSize;
            this.emit("metadata", bencode.encode({
              info: bencode.decode(this.metadata)
            }));
            return true;
          }
          _send(dict, trailer) {
            let buf = bencode.encode(dict);
            if (Buffer3.isBuffer(trailer)) {
              buf = Buffer3.concat([buf, trailer]);
            }
            this._wire.extended("ut_metadata", buf);
          }
          _request(piece) {
            this._send({ msg_type: 0, piece });
          }
          _data(piece, buf, totalSize) {
            const msg = { msg_type: 1, piece };
            if (typeof totalSize === "number") {
              msg.total_size = totalSize;
            }
            this._send(msg, buf);
          }
          _reject(piece) {
            this._send({ msg_type: 2, piece });
          }
          _onRequest(piece) {
            if (!this._metadataComplete) {
              this._reject(piece);
              return;
            }
            const start = piece * PIECE_LENGTH;
            let end = start + PIECE_LENGTH;
            if (end > this._metadataSize) {
              end = this._metadataSize;
            }
            const buf = this.metadata.slice(start, end);
            this._data(piece, buf, this._metadataSize);
          }
          _onData(piece, buf, totalSize) {
            if (buf.length > PIECE_LENGTH || !this._fetching) {
              return;
            }
            buf.copy(this.metadata, piece * PIECE_LENGTH);
            this._bitfield.set(piece);
            this._checkDone();
          }
          _onReject(piece) {
            if (this._remainingRejects > 0 && this._fetching) {
              this._request(piece);
              this._remainingRejects -= 1;
            } else {
              this.emit("warning", new Error('Peer sent "reject" too much'));
            }
          }
          _requestPieces() {
            if (!this._fetching)
              return;
            this.metadata = Buffer3.alloc(this._metadataSize);
            for (let piece = 0; piece < this._numPieces; piece++) {
              this._request(piece);
            }
          }
          _checkDone() {
            let done2 = true;
            for (let piece = 0; piece < this._numPieces; piece++) {
              if (!this._bitfield.get(piece)) {
                done2 = false;
                break;
              }
            }
            if (!done2)
              return;
            const success = this.setMetadata(this.metadata);
            if (!success) {
              this._failedMetadata();
            }
          }
          _failedMetadata() {
            this._bitfield = new BitField(0, { grow: BITFIELD_GROW });
            this._remainingRejects -= this._numPieces;
            if (this._remainingRejects > 0) {
              this._requestPieces();
            } else {
              this.emit("warning", new Error("Peer sent invalid metadata"));
            }
          }
        }
        utMetadata.prototype.name = "ut_metadata";
        return utMetadata;
      };
    }
  });

  // (disabled):node_modules/ut_pex/index.js
  var require_ut_pex = __commonJS({
    "(disabled):node_modules/ut_pex/index.js"() {
      init_esbuild_inject();
    }
  });

  // node-modules-polyfills-commonjs:stream
  var require_stream = __commonJS({
    "node-modules-polyfills-commonjs:stream"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_stream(), __toCommonJS(stream_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node_modules/render-media/lib/mime.json
  var require_mime = __commonJS({
    "node_modules/render-media/lib/mime.json"(exports, module) {
      module.exports = {
        ".3gp": "video/3gpp",
        ".aac": "audio/aac",
        ".aif": "audio/x-aiff",
        ".aiff": "audio/x-aiff",
        ".atom": "application/atom+xml",
        ".avi": "video/x-msvideo",
        ".bmp": "image/bmp",
        ".bz2": "application/x-bzip2",
        ".conf": "text/plain",
        ".css": "text/css",
        ".csv": "text/plain",
        ".diff": "text/x-diff",
        ".doc": "application/msword",
        ".flv": "video/x-flv",
        ".gif": "image/gif",
        ".gz": "application/x-gzip",
        ".htm": "text/html",
        ".html": "text/html",
        ".ico": "image/vnd.microsoft.icon",
        ".ics": "text/calendar",
        ".iso": "application/octet-stream",
        ".jar": "application/java-archive",
        ".jpeg": "image/jpeg",
        ".jpg": "image/jpeg",
        ".js": "application/javascript",
        ".json": "application/json",
        ".less": "text/css",
        ".log": "text/plain",
        ".m3u": "audio/x-mpegurl",
        ".m4a": "audio/x-m4a",
        ".m4b": "audio/mp4",
        ".m4p": "audio/mp4",
        ".m4v": "video/x-m4v",
        ".manifest": "text/cache-manifest",
        ".markdown": "text/x-markdown",
        ".mathml": "application/mathml+xml",
        ".md": "text/x-markdown",
        ".mid": "audio/midi",
        ".midi": "audio/midi",
        ".mov": "video/quicktime",
        ".mp3": "audio/mpeg",
        ".mp4": "video/mp4",
        ".mp4v": "video/mp4",
        ".mpeg": "video/mpeg",
        ".mpg": "video/mpeg",
        ".odp": "application/vnd.oasis.opendocument.presentation",
        ".ods": "application/vnd.oasis.opendocument.spreadsheet",
        ".odt": "application/vnd.oasis.opendocument.text",
        ".oga": "audio/ogg",
        ".ogg": "application/ogg",
        ".pdf": "application/pdf",
        ".png": "image/png",
        ".pps": "application/vnd.ms-powerpoint",
        ".ppt": "application/vnd.ms-powerpoint",
        ".ps": "application/postscript",
        ".psd": "image/vnd.adobe.photoshop",
        ".qt": "video/quicktime",
        ".rar": "application/x-rar-compressed",
        ".rdf": "application/rdf+xml",
        ".rss": "application/rss+xml",
        ".rtf": "application/rtf",
        ".svg": "image/svg+xml",
        ".svgz": "image/svg+xml",
        ".swf": "application/x-shockwave-flash",
        ".tar": "application/x-tar",
        ".tbz": "application/x-bzip-compressed-tar",
        ".text": "text/plain",
        ".tif": "image/tiff",
        ".tiff": "image/tiff",
        ".torrent": "application/x-bittorrent",
        ".ttf": "application/x-font-ttf",
        ".txt": "text/plain",
        ".wav": "audio/wav",
        ".webm": "video/webm",
        ".wma": "audio/x-ms-wma",
        ".wmv": "video/x-ms-wmv",
        ".xls": "application/vnd.ms-excel",
        ".xml": "application/xml",
        ".yaml": "text/yaml",
        ".yml": "text/yaml",
        ".zip": "application/zip"
      };
    }
  });

  // node_modules/is-ascii/index.js
  var require_is_ascii = __commonJS({
    "node_modules/is-ascii/index.js"(exports, module) {
      init_esbuild_inject();
      var MAX_ASCII_CHAR_CODE = 127;
      module.exports = function isAscii(str) {
        for (var i = 0, strLen = str.length; i < strLen; ++i) {
          if (str.charCodeAt(i) > MAX_ASCII_CHAR_CODE)
            return false;
        }
        return true;
      };
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/errors-browser.js
  var require_errors_browser8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser8().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser8();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy8();
      var _require = require_state8();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser8().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex8();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex8();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable8();
      var Writable2 = require_stream_writable8();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream9 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser8().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream9();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser8();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list8();
      var destroyImpl = require_destroy8();
      var _require = require_state8();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser8().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex8();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex8();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator8();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser8();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser8().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex8();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform8();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser8().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream9();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/mediasource/node_modules/readable-stream/readable-browser.js
  var require_readable_browser8 = __commonJS({
    "node_modules/mediasource/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable8();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable8();
      exports.Duplex = require_stream_duplex8();
      exports.Transform = require_stream_transform8();
      exports.PassThrough = require_stream_passthrough8();
      exports.finished = require_end_of_stream9();
      exports.pipeline = require_pipeline8();
    }
  });

  // node_modules/to-arraybuffer/index.js
  var require_to_arraybuffer = __commonJS({
    "node_modules/to-arraybuffer/index.js"(exports, module) {
      init_esbuild_inject();
      var Buffer4 = require_buffer().Buffer;
      module.exports = function(buf) {
        if (buf instanceof Uint8Array) {
          if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
            return buf.buffer;
          } else if (typeof buf.buffer.slice === "function") {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          }
        }
        if (Buffer4.isBuffer(buf)) {
          var arrayCopy = new Uint8Array(buf.length);
          var len = buf.length;
          for (var i = 0; i < len; i++) {
            arrayCopy[i] = buf[i];
          }
          return arrayCopy.buffer;
        } else {
          throw new Error("Argument must be a Buffer");
        }
      };
    }
  });

  // node_modules/mediasource/index.js
  var require_mediasource = __commonJS({
    "node_modules/mediasource/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = MediaElementWrapper;
      var inherits2 = require_inherits_browser();
      var stream = require_readable_browser8();
      var toArrayBuffer = require_to_arraybuffer();
      var MediaSource = typeof window !== "undefined" && window.MediaSource;
      var DEFAULT_BUFFER_DURATION = 60;
      function MediaElementWrapper(elem, opts) {
        var self2 = this;
        if (!(self2 instanceof MediaElementWrapper))
          return new MediaElementWrapper(elem, opts);
        if (!MediaSource)
          throw new Error("web browser lacks MediaSource support");
        if (!opts)
          opts = {};
        self2._debug = opts.debug;
        self2._bufferDuration = opts.bufferDuration || DEFAULT_BUFFER_DURATION;
        self2._elem = elem;
        self2._mediaSource = new MediaSource();
        self2._streams = [];
        self2.detailedError = null;
        self2._errorHandler = function() {
          self2._elem.removeEventListener("error", self2._errorHandler);
          var streams = self2._streams.slice();
          streams.forEach(function(stream2) {
            stream2.destroy(self2._elem.error);
          });
        };
        self2._elem.addEventListener("error", self2._errorHandler);
        self2._elem.src = window.URL.createObjectURL(self2._mediaSource);
      }
      MediaElementWrapper.prototype.createWriteStream = function(obj) {
        var self2 = this;
        return new MediaSourceStream(self2, obj);
      };
      MediaElementWrapper.prototype.error = function(err) {
        var self2 = this;
        if (!self2.detailedError) {
          self2.detailedError = err;
        }
        self2._dumpDebugData();
        try {
          self2._mediaSource.endOfStream("decode");
        } catch (err2) {
        }
        try {
          window.URL.revokeObjectURL(self2._elem.src);
        } catch (err2) {
        }
      };
      MediaElementWrapper.prototype._dumpDebugData = function() {
        var self2 = this;
        if (self2._debug) {
          self2._debug = false;
          self2._streams.forEach(function(stream2, i) {
            downloadBuffers(stream2._debugBuffers, "mediasource-stream-" + i);
          });
        }
      };
      inherits2(MediaSourceStream, stream.Writable);
      function MediaSourceStream(wrapper, obj) {
        var self2 = this;
        stream.Writable.call(self2);
        self2._wrapper = wrapper;
        self2._elem = wrapper._elem;
        self2._mediaSource = wrapper._mediaSource;
        self2._allStreams = wrapper._streams;
        self2._allStreams.push(self2);
        self2._bufferDuration = wrapper._bufferDuration;
        self2._sourceBuffer = null;
        self2._debugBuffers = [];
        self2._openHandler = function() {
          self2._onSourceOpen();
        };
        self2._flowHandler = function() {
          self2._flow();
        };
        self2._errorHandler = function(err) {
          if (!self2.destroyed) {
            self2.emit("error", err);
          }
        };
        if (typeof obj === "string") {
          self2._type = obj;
          if (self2._mediaSource.readyState === "open") {
            self2._createSourceBuffer();
          } else {
            self2._mediaSource.addEventListener("sourceopen", self2._openHandler);
          }
        } else if (obj._sourceBuffer === null) {
          obj.destroy();
          self2._type = obj._type;
          self2._mediaSource.addEventListener("sourceopen", self2._openHandler);
        } else if (obj._sourceBuffer) {
          obj.destroy();
          self2._type = obj._type;
          self2._sourceBuffer = obj._sourceBuffer;
          self2._debugBuffers = obj._debugBuffers;
          self2._sourceBuffer.addEventListener("updateend", self2._flowHandler);
          self2._sourceBuffer.addEventListener("error", self2._errorHandler);
        } else {
          throw new Error("The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function");
        }
        self2._elem.addEventListener("timeupdate", self2._flowHandler);
        self2.on("error", function(err) {
          self2._wrapper.error(err);
        });
        self2.on("finish", function() {
          if (self2.destroyed)
            return;
          self2._finished = true;
          if (self2._allStreams.every(function(other) {
            return other._finished;
          })) {
            self2._wrapper._dumpDebugData();
            try {
              self2._mediaSource.endOfStream();
            } catch (err) {
            }
          }
        });
      }
      MediaSourceStream.prototype._onSourceOpen = function() {
        var self2 = this;
        if (self2.destroyed)
          return;
        self2._mediaSource.removeEventListener("sourceopen", self2._openHandler);
        self2._createSourceBuffer();
      };
      MediaSourceStream.prototype.destroy = function(err) {
        var self2 = this;
        if (self2.destroyed)
          return;
        self2.destroyed = true;
        self2._allStreams.splice(self2._allStreams.indexOf(self2), 1);
        self2._mediaSource.removeEventListener("sourceopen", self2._openHandler);
        self2._elem.removeEventListener("timeupdate", self2._flowHandler);
        if (self2._sourceBuffer) {
          self2._sourceBuffer.removeEventListener("updateend", self2._flowHandler);
          self2._sourceBuffer.removeEventListener("error", self2._errorHandler);
          if (self2._mediaSource.readyState === "open") {
            self2._sourceBuffer.abort();
          }
        }
        if (err)
          self2.emit("error", err);
        self2.emit("close");
      };
      MediaSourceStream.prototype._createSourceBuffer = function() {
        var self2 = this;
        if (self2.destroyed)
          return;
        if (MediaSource.isTypeSupported(self2._type)) {
          self2._sourceBuffer = self2._mediaSource.addSourceBuffer(self2._type);
          self2._sourceBuffer.addEventListener("updateend", self2._flowHandler);
          self2._sourceBuffer.addEventListener("error", self2._errorHandler);
          if (self2._cb) {
            var cb = self2._cb;
            self2._cb = null;
            cb();
          }
        } else {
          self2.destroy(new Error("The provided type is not supported"));
        }
      };
      MediaSourceStream.prototype._write = function(chunk, encoding, cb) {
        var self2 = this;
        if (self2.destroyed)
          return;
        if (!self2._sourceBuffer) {
          self2._cb = function(err) {
            if (err)
              return cb(err);
            self2._write(chunk, encoding, cb);
          };
          return;
        }
        if (self2._sourceBuffer.updating) {
          return cb(new Error("Cannot append buffer while source buffer updating"));
        }
        var arr = toArrayBuffer(chunk);
        if (self2._wrapper._debug) {
          self2._debugBuffers.push(arr);
        }
        try {
          self2._sourceBuffer.appendBuffer(arr);
        } catch (err) {
          self2.destroy(err);
          return;
        }
        self2._cb = cb;
      };
      MediaSourceStream.prototype._flow = function() {
        var self2 = this;
        if (self2.destroyed || !self2._sourceBuffer || self2._sourceBuffer.updating) {
          return;
        }
        if (self2._mediaSource.readyState === "open") {
          if (self2._getBufferDuration() > self2._bufferDuration) {
            return;
          }
        }
        if (self2._cb) {
          var cb = self2._cb;
          self2._cb = null;
          cb();
        }
      };
      var EPSILON = 0;
      MediaSourceStream.prototype._getBufferDuration = function() {
        var self2 = this;
        var buffered = self2._sourceBuffer.buffered;
        var currentTime = self2._elem.currentTime;
        var bufferEnd = -1;
        for (var i = 0; i < buffered.length; i++) {
          var start = buffered.start(i);
          var end = buffered.end(i) + EPSILON;
          if (start > currentTime) {
            break;
          } else if (bufferEnd >= 0 || currentTime <= end) {
            bufferEnd = end;
          }
        }
        var bufferedTime = bufferEnd - currentTime;
        if (bufferedTime < 0) {
          bufferedTime = 0;
        }
        return bufferedTime;
      };
      function downloadBuffers(bufs, name) {
        var a = document.createElement("a");
        a.href = window.URL.createObjectURL(new window.Blob(bufs));
        a.download = name;
        a.click();
      }
    }
  });

  // node_modules/stream-to-blob/index.js
  var require_stream_to_blob = __commonJS({
    "node_modules/stream-to-blob/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = streamToBlob;
      function streamToBlob(stream, mimeType) {
        if (mimeType != null && typeof mimeType !== "string") {
          throw new Error("Invalid mimetype, expected string.");
        }
        return new Promise((resolve2, reject) => {
          const chunks = [];
          stream.on("data", (chunk) => chunks.push(chunk)).once("end", () => {
            const blob = mimeType != null ? new Blob(chunks, { type: mimeType }) : new Blob(chunks);
            resolve2(blob);
          }).once("error", reject);
        });
      }
    }
  });

  // node_modules/stream-to-blob-url/index.js
  var require_stream_to_blob_url = __commonJS({
    "node_modules/stream-to-blob-url/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = getBlobURL;
      var getBlob = require_stream_to_blob();
      async function getBlobURL(stream, mimeType) {
        const blob = await getBlob(stream, mimeType);
        const url = URL.createObjectURL(blob);
        return url;
      }
    }
  });

  // node_modules/binary-search/index.js
  var require_binary_search = __commonJS({
    "node_modules/binary-search/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function(haystack, needle, comparator, low, high) {
        var mid, cmp;
        if (low === void 0)
          low = 0;
        else {
          low = low | 0;
          if (low < 0 || low >= haystack.length)
            throw new RangeError("invalid lower bound");
        }
        if (high === void 0)
          high = haystack.length - 1;
        else {
          high = high | 0;
          if (high < low || high >= haystack.length)
            throw new RangeError("invalid upper bound");
        }
        while (low <= high) {
          mid = low + (high - low >>> 1);
          cmp = +comparator(haystack[mid], needle, mid, haystack);
          if (cmp < 0)
            low = mid + 1;
          else if (cmp > 0)
            high = mid - 1;
          else
            return mid;
        }
        return ~low;
      };
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/errors-browser.js
  var require_errors_browser9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser9().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser9();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy9();
      var _require = require_state9();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser9().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex9();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex9();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable9();
      var Writable2 = require_stream_writable9();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream10 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser9().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream10();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser9();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list9();
      var destroyImpl = require_destroy9();
      var _require = require_state9();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser9().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex9();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex9();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator9();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser9();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser9().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex9();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform9();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser9().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream10();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/mp4-stream/node_modules/readable-stream/readable-browser.js
  var require_readable_browser9 = __commonJS({
    "node_modules/mp4-stream/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable9();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable9();
      exports.Duplex = require_stream_duplex9();
      exports.Transform = require_stream_transform9();
      exports.PassThrough = require_stream_passthrough9();
      exports.finished = require_end_of_stream10();
      exports.pipeline = require_pipeline9();
    }
  });

  // node_modules/next-event/index.js
  var require_next_event = __commonJS({
    "node_modules/next-event/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = nextEvent;
      function nextEvent(emitter, name) {
        var next = null;
        emitter.on(name, function(data) {
          if (!next)
            return;
          var fn = next;
          next = null;
          fn(data);
        });
        return function(once3) {
          next = once3;
        };
      }
    }
  });

  // node_modules/buffer-fill/index.js
  var require_buffer_fill = __commonJS({
    "node_modules/buffer-fill/index.js"(exports, module) {
      init_esbuild_inject();
      var hasFullSupport = function() {
        try {
          if (!Buffer3.isEncoding("latin1")) {
            return false;
          }
          var buf = Buffer3.alloc ? Buffer3.alloc(4) : new Buffer3(4);
          buf.fill("ab", "ucs2");
          return buf.toString("hex") === "61006200";
        } catch (_) {
          return false;
        }
      }();
      function isSingleByte(val) {
        return val.length === 1 && val.charCodeAt(0) < 256;
      }
      function fillWithNumber(buffer, val, start, end) {
        if (start < 0 || end > buffer.length) {
          throw new RangeError("Out of range index");
        }
        start = start >>> 0;
        end = end === void 0 ? buffer.length : end >>> 0;
        if (end > start) {
          buffer.fill(val, start, end);
        }
        return buffer;
      }
      function fillWithBuffer(buffer, val, start, end) {
        if (start < 0 || end > buffer.length) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return buffer;
        }
        start = start >>> 0;
        end = end === void 0 ? buffer.length : end >>> 0;
        var pos = start;
        var len = val.length;
        while (pos <= end - len) {
          val.copy(buffer, pos);
          pos += len;
        }
        if (pos !== end) {
          val.copy(buffer, pos, 0, end - pos);
        }
        return buffer;
      }
      function fill2(buffer, val, start, end, encoding) {
        if (hasFullSupport) {
          return buffer.fill(val, start, end, encoding);
        }
        if (typeof val === "number") {
          return fillWithNumber(buffer, val, start, end);
        }
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = buffer.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = buffer.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (encoding === "latin1") {
            encoding = "binary";
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val === "") {
            return fillWithNumber(buffer, 0, start, end);
          }
          if (isSingleByte(val)) {
            return fillWithNumber(buffer, val.charCodeAt(0), start, end);
          }
          val = new Buffer3(val, encoding);
        }
        if (Buffer3.isBuffer(val)) {
          return fillWithBuffer(buffer, val, start, end);
        }
        return fillWithNumber(buffer, 0, start, end);
      }
      module.exports = fill2;
    }
  });

  // node_modules/buffer-alloc-unsafe/index.js
  var require_buffer_alloc_unsafe = __commonJS({
    "node_modules/buffer-alloc-unsafe/index.js"(exports, module) {
      init_esbuild_inject();
      function allocUnsafe2(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be a number');
        }
        if (size < 0) {
          throw new RangeError('"size" argument must not be negative');
        }
        if (Buffer3.allocUnsafe) {
          return Buffer3.allocUnsafe(size);
        } else {
          return new Buffer3(size);
        }
      }
      module.exports = allocUnsafe2;
    }
  });

  // node_modules/buffer-alloc/index.js
  var require_buffer_alloc = __commonJS({
    "node_modules/buffer-alloc/index.js"(exports, module) {
      init_esbuild_inject();
      var bufferFill = require_buffer_fill();
      var allocUnsafe2 = require_buffer_alloc_unsafe();
      module.exports = function alloc2(size, fill2, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be a number');
        }
        if (size < 0) {
          throw new RangeError('"size" argument must not be negative');
        }
        if (Buffer3.alloc) {
          return Buffer3.alloc(size, fill2, encoding);
        }
        var buffer = allocUnsafe2(size);
        if (size === 0) {
          return buffer;
        }
        if (fill2 === void 0) {
          return bufferFill(buffer, 0);
        }
        if (typeof encoding !== "string") {
          encoding = void 0;
        }
        return bufferFill(buffer, fill2, encoding);
      };
    }
  });

  // node_modules/uint64be/index.js
  var require_uint64be = __commonJS({
    "node_modules/uint64be/index.js"(exports) {
      init_esbuild_inject();
      var bufferAlloc = require_buffer_alloc();
      var UINT_32_MAX = Math.pow(2, 32);
      exports.encodingLength = function() {
        return 8;
      };
      exports.encode = function(num, buf, offset) {
        if (!buf)
          buf = bufferAlloc(8);
        if (!offset)
          offset = 0;
        var top = Math.floor(num / UINT_32_MAX);
        var rem = num - top * UINT_32_MAX;
        buf.writeUInt32BE(top, offset);
        buf.writeUInt32BE(rem, offset + 4);
        return buf;
      };
      exports.decode = function(buf, offset) {
        if (!offset)
          offset = 0;
        var top = buf.readUInt32BE(offset);
        var rem = buf.readUInt32BE(offset + 4);
        return top * UINT_32_MAX + rem;
      };
      exports.encode.bytes = 8;
      exports.decode.bytes = 8;
    }
  });

  // node_modules/mp4-box-encoding/descriptor.js
  var require_descriptor = __commonJS({
    "node_modules/mp4-box-encoding/descriptor.js"(exports) {
      init_esbuild_inject();
      var tagToName = {
        3: "ESDescriptor",
        4: "DecoderConfigDescriptor",
        5: "DecoderSpecificInfo",
        6: "SLConfigDescriptor"
      };
      exports.Descriptor = {};
      exports.Descriptor.decode = function(buf, start, end) {
        var tag = buf.readUInt8(start);
        var ptr = start + 1;
        var lenByte;
        var len = 0;
        do {
          lenByte = buf.readUInt8(ptr++);
          len = len << 7 | lenByte & 127;
        } while (lenByte & 128);
        var obj;
        var tagName = tagToName[tag];
        if (exports[tagName]) {
          obj = exports[tagName].decode(buf, ptr, end);
        } else {
          obj = {
            buffer: Buffer3.from(buf.slice(ptr, ptr + len))
          };
        }
        obj.tag = tag;
        obj.tagName = tagName;
        obj.length = ptr - start + len;
        obj.contentsLen = len;
        return obj;
      };
      exports.DescriptorArray = {};
      exports.DescriptorArray.decode = function(buf, start, end) {
        var ptr = start;
        var obj = {};
        while (ptr + 2 <= end) {
          var descriptor = exports.Descriptor.decode(buf, ptr, end);
          ptr += descriptor.length;
          var tagName = tagToName[descriptor.tag] || "Descriptor" + descriptor.tag;
          obj[tagName] = descriptor;
        }
        return obj;
      };
      exports.ESDescriptor = {};
      exports.ESDescriptor.decode = function(buf, start, end) {
        var flags = buf.readUInt8(start + 2);
        var ptr = start + 3;
        if (flags & 128) {
          ptr += 2;
        }
        if (flags & 64) {
          var len = buf.readUInt8(ptr);
          ptr += len + 1;
        }
        if (flags & 32) {
          ptr += 2;
        }
        return exports.DescriptorArray.decode(buf, ptr, end);
      };
      exports.DecoderConfigDescriptor = {};
      exports.DecoderConfigDescriptor.decode = function(buf, start, end) {
        var oti = buf.readUInt8(start);
        var obj = exports.DescriptorArray.decode(buf, start + 13, end);
        obj.oti = oti;
        return obj;
      };
    }
  });

  // node_modules/mp4-box-encoding/boxes.js
  var require_boxes = __commonJS({
    "node_modules/mp4-box-encoding/boxes.js"(exports) {
      init_esbuild_inject();
      var Box = require_mp4_box_encoding();
      var Descriptor = require_descriptor();
      var uint64be = require_uint64be();
      var TIME_OFFSET = 20828448e5;
      exports.fullBoxes = {};
      var fullBoxes = [
        "mvhd",
        "tkhd",
        "mdhd",
        "vmhd",
        "smhd",
        "stsd",
        "esds",
        "stsz",
        "stco",
        "co64",
        "stss",
        "stts",
        "ctts",
        "stsc",
        "dref",
        "elst",
        "hdlr",
        "mehd",
        "trex",
        "mfhd",
        "tfhd",
        "tfdt",
        "trun"
      ];
      fullBoxes.forEach(function(type2) {
        exports.fullBoxes[type2] = true;
      });
      exports.ftyp = {};
      exports.ftyp.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.ftyp.encodingLength(box));
        var brands = box.compatibleBrands || [];
        buf.write(box.brand, 0, 4, "ascii");
        buf.writeUInt32BE(box.brandVersion, 4);
        for (var i = 0; i < brands.length; i++)
          buf.write(brands[i], 8 + i * 4, 4, "ascii");
        exports.ftyp.encode.bytes = 8 + brands.length * 4;
        return buf;
      };
      exports.ftyp.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var brand = buf.toString("ascii", 0, 4);
        var version3 = buf.readUInt32BE(4);
        var compatibleBrands = [];
        for (var i = 8; i < buf.length; i += 4)
          compatibleBrands.push(buf.toString("ascii", i, i + 4));
        return {
          brand,
          brandVersion: version3,
          compatibleBrands
        };
      };
      exports.ftyp.encodingLength = function(box) {
        return 8 + (box.compatibleBrands || []).length * 4;
      };
      exports.mvhd = {};
      exports.mvhd.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(96);
        writeDate(box.ctime || new Date(), buf, 0);
        writeDate(box.mtime || new Date(), buf, 4);
        buf.writeUInt32BE(box.timeScale || 0, 8);
        buf.writeUInt32BE(box.duration || 0, 12);
        writeFixed32(box.preferredRate || 0, buf, 16);
        writeFixed16(box.preferredVolume || 0, buf, 20);
        writeReserved(buf, 22, 32);
        writeMatrix(box.matrix, buf, 32);
        buf.writeUInt32BE(box.previewTime || 0, 68);
        buf.writeUInt32BE(box.previewDuration || 0, 72);
        buf.writeUInt32BE(box.posterTime || 0, 76);
        buf.writeUInt32BE(box.selectionTime || 0, 80);
        buf.writeUInt32BE(box.selectionDuration || 0, 84);
        buf.writeUInt32BE(box.currentTime || 0, 88);
        buf.writeUInt32BE(box.nextTrackId || 0, 92);
        exports.mvhd.encode.bytes = 96;
        return buf;
      };
      exports.mvhd.decode = function(buf, offset) {
        buf = buf.slice(offset);
        return {
          ctime: readDate(buf, 0),
          mtime: readDate(buf, 4),
          timeScale: buf.readUInt32BE(8),
          duration: buf.readUInt32BE(12),
          preferredRate: readFixed32(buf, 16),
          preferredVolume: readFixed16(buf, 20),
          matrix: readMatrix(buf.slice(32, 68)),
          previewTime: buf.readUInt32BE(68),
          previewDuration: buf.readUInt32BE(72),
          posterTime: buf.readUInt32BE(76),
          selectionTime: buf.readUInt32BE(80),
          selectionDuration: buf.readUInt32BE(84),
          currentTime: buf.readUInt32BE(88),
          nextTrackId: buf.readUInt32BE(92)
        };
      };
      exports.mvhd.encodingLength = function(box) {
        return 96;
      };
      exports.tkhd = {};
      exports.tkhd.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(80);
        writeDate(box.ctime || new Date(), buf, 0);
        writeDate(box.mtime || new Date(), buf, 4);
        buf.writeUInt32BE(box.trackId || 0, 8);
        writeReserved(buf, 12, 16);
        buf.writeUInt32BE(box.duration || 0, 16);
        writeReserved(buf, 20, 28);
        buf.writeUInt16BE(box.layer || 0, 28);
        buf.writeUInt16BE(box.alternateGroup || 0, 30);
        buf.writeUInt16BE(box.volume || 0, 32);
        writeMatrix(box.matrix, buf, 36);
        buf.writeUInt32BE(box.trackWidth || 0, 72);
        buf.writeUInt32BE(box.trackHeight || 0, 76);
        exports.tkhd.encode.bytes = 80;
        return buf;
      };
      exports.tkhd.decode = function(buf, offset) {
        buf = buf.slice(offset);
        return {
          ctime: readDate(buf, 0),
          mtime: readDate(buf, 4),
          trackId: buf.readUInt32BE(8),
          duration: buf.readUInt32BE(16),
          layer: buf.readUInt16BE(28),
          alternateGroup: buf.readUInt16BE(30),
          volume: buf.readUInt16BE(32),
          matrix: readMatrix(buf.slice(36, 72)),
          trackWidth: buf.readUInt32BE(72),
          trackHeight: buf.readUInt32BE(76)
        };
      };
      exports.tkhd.encodingLength = function(box) {
        return 80;
      };
      exports.mdhd = {};
      exports.mdhd.encode = function(box, buf, offset) {
        if (box.version === 1) {
          buf = buf ? buf.slice(offset) : Buffer3.alloc(32);
          writeDate64(box.ctime || new Date(), buf, 0);
          writeDate64(box.mtime || new Date(), buf, 8);
          buf.writeUInt32BE(box.timeScale || 0, 16);
          buf.writeUIntBE(box.duration || 0, 20, 6);
          buf.writeUInt16BE(box.language || 0, 28);
          buf.writeUInt16BE(box.quality || 0, 30);
          exports.mdhd.encode.bytes = 32;
          return buf;
        }
        buf = buf ? buf.slice(offset) : Buffer3.alloc(20);
        writeDate(box.ctime || new Date(), buf, 0);
        writeDate(box.mtime || new Date(), buf, 4);
        buf.writeUInt32BE(box.timeScale || 0, 8);
        buf.writeUInt32BE(box.duration || 0, 12);
        buf.writeUInt16BE(box.language || 0, 16);
        buf.writeUInt16BE(box.quality || 0, 18);
        exports.mdhd.encode.bytes = 20;
        return buf;
      };
      exports.mdhd.decode = function(buf, offset, end) {
        buf = buf.slice(offset);
        var version1 = end - offset !== 20;
        if (version1) {
          return {
            ctime: readDate64(buf, 0),
            mtime: readDate64(buf, 8),
            timeScale: buf.readUInt32BE(16),
            duration: buf.readUIntBE(20, 6),
            language: buf.readUInt16BE(28),
            quality: buf.readUInt16BE(30)
          };
        }
        return {
          ctime: readDate(buf, 0),
          mtime: readDate(buf, 4),
          timeScale: buf.readUInt32BE(8),
          duration: buf.readUInt32BE(12),
          language: buf.readUInt16BE(16),
          quality: buf.readUInt16BE(18)
        };
      };
      exports.mdhd.encodingLength = function(box) {
        if (box.version === 1)
          return 32;
        return 20;
      };
      exports.vmhd = {};
      exports.vmhd.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(8);
        buf.writeUInt16BE(box.graphicsMode || 0, 0);
        var opcolor = box.opcolor || [0, 0, 0];
        buf.writeUInt16BE(opcolor[0], 2);
        buf.writeUInt16BE(opcolor[1], 4);
        buf.writeUInt16BE(opcolor[2], 6);
        exports.vmhd.encode.bytes = 8;
        return buf;
      };
      exports.vmhd.decode = function(buf, offset) {
        buf = buf.slice(offset);
        return {
          graphicsMode: buf.readUInt16BE(0),
          opcolor: [buf.readUInt16BE(2), buf.readUInt16BE(4), buf.readUInt16BE(6)]
        };
      };
      exports.vmhd.encodingLength = function(box) {
        return 8;
      };
      exports.smhd = {};
      exports.smhd.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(4);
        buf.writeUInt16BE(box.balance || 0, 0);
        writeReserved(buf, 2, 4);
        exports.smhd.encode.bytes = 4;
        return buf;
      };
      exports.smhd.decode = function(buf, offset) {
        buf = buf.slice(offset);
        return {
          balance: buf.readUInt16BE(0)
        };
      };
      exports.smhd.encodingLength = function(box) {
        return 4;
      };
      exports.stsd = {};
      exports.stsd.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.stsd.encodingLength(box));
        var entries = box.entries || [];
        buf.writeUInt32BE(entries.length, 0);
        var ptr = 4;
        for (var i = 0; i < entries.length; i++) {
          var entry = entries[i];
          Box.encode(entry, buf, ptr);
          ptr += Box.encode.bytes;
        }
        exports.stsd.encode.bytes = ptr;
        return buf;
      };
      exports.stsd.decode = function(buf, offset, end) {
        buf = buf.slice(offset);
        var num = buf.readUInt32BE(0);
        var entries = new Array(num);
        var ptr = 4;
        for (var i = 0; i < num; i++) {
          var entry = Box.decode(buf, ptr, end);
          entries[i] = entry;
          ptr += entry.length;
        }
        return {
          entries
        };
      };
      exports.stsd.encodingLength = function(box) {
        var totalSize = 4;
        if (!box.entries)
          return totalSize;
        for (var i = 0; i < box.entries.length; i++) {
          totalSize += Box.encodingLength(box.entries[i]);
        }
        return totalSize;
      };
      exports.avc1 = exports.VisualSampleEntry = {};
      exports.VisualSampleEntry.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.VisualSampleEntry.encodingLength(box));
        writeReserved(buf, 0, 6);
        buf.writeUInt16BE(box.dataReferenceIndex || 0, 6);
        writeReserved(buf, 8, 24);
        buf.writeUInt16BE(box.width || 0, 24);
        buf.writeUInt16BE(box.height || 0, 26);
        buf.writeUInt32BE(box.hResolution || 4718592, 28);
        buf.writeUInt32BE(box.vResolution || 4718592, 32);
        writeReserved(buf, 36, 40);
        buf.writeUInt16BE(box.frameCount || 1, 40);
        var compressorName = box.compressorName || "";
        var nameLen = Math.min(compressorName.length, 31);
        buf.writeUInt8(nameLen, 42);
        buf.write(compressorName, 43, nameLen, "utf8");
        buf.writeUInt16BE(box.depth || 24, 74);
        buf.writeInt16BE(-1, 76);
        var ptr = 78;
        var children = box.children || [];
        children.forEach(function(child) {
          Box.encode(child, buf, ptr);
          ptr += Box.encode.bytes;
        });
        exports.VisualSampleEntry.encode.bytes = ptr;
      };
      exports.VisualSampleEntry.decode = function(buf, offset, end) {
        buf = buf.slice(offset);
        var length = end - offset;
        var nameLen = Math.min(buf.readUInt8(42), 31);
        var box = {
          dataReferenceIndex: buf.readUInt16BE(6),
          width: buf.readUInt16BE(24),
          height: buf.readUInt16BE(26),
          hResolution: buf.readUInt32BE(28),
          vResolution: buf.readUInt32BE(32),
          frameCount: buf.readUInt16BE(40),
          compressorName: buf.toString("utf8", 43, 43 + nameLen),
          depth: buf.readUInt16BE(74),
          children: []
        };
        var ptr = 78;
        while (length - ptr >= 8) {
          var child = Box.decode(buf, ptr, length);
          box.children.push(child);
          box[child.type] = child;
          ptr += child.length;
        }
        return box;
      };
      exports.VisualSampleEntry.encodingLength = function(box) {
        var len = 78;
        var children = box.children || [];
        children.forEach(function(child) {
          len += Box.encodingLength(child);
        });
        return len;
      };
      exports.avcC = {};
      exports.avcC.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(box.buffer.length);
        box.buffer.copy(buf);
        exports.avcC.encode.bytes = box.buffer.length;
      };
      exports.avcC.decode = function(buf, offset, end) {
        buf = buf.slice(offset, end);
        return {
          mimeCodec: buf.toString("hex", 1, 4),
          buffer: Buffer3.from(buf)
        };
      };
      exports.avcC.encodingLength = function(box) {
        return box.buffer.length;
      };
      exports.mp4a = exports.AudioSampleEntry = {};
      exports.AudioSampleEntry.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.AudioSampleEntry.encodingLength(box));
        writeReserved(buf, 0, 6);
        buf.writeUInt16BE(box.dataReferenceIndex || 0, 6);
        writeReserved(buf, 8, 16);
        buf.writeUInt16BE(box.channelCount || 2, 16);
        buf.writeUInt16BE(box.sampleSize || 16, 18);
        writeReserved(buf, 20, 24);
        buf.writeUInt32BE(box.sampleRate || 0, 24);
        var ptr = 28;
        var children = box.children || [];
        children.forEach(function(child) {
          Box.encode(child, buf, ptr);
          ptr += Box.encode.bytes;
        });
        exports.AudioSampleEntry.encode.bytes = ptr;
      };
      exports.AudioSampleEntry.decode = function(buf, offset, end) {
        buf = buf.slice(offset, end);
        var length = end - offset;
        var box = {
          dataReferenceIndex: buf.readUInt16BE(6),
          channelCount: buf.readUInt16BE(16),
          sampleSize: buf.readUInt16BE(18),
          sampleRate: buf.readUInt32BE(24),
          children: []
        };
        var ptr = 28;
        while (length - ptr >= 8) {
          var child = Box.decode(buf, ptr, length);
          box.children.push(child);
          box[child.type] = child;
          ptr += child.length;
        }
        return box;
      };
      exports.AudioSampleEntry.encodingLength = function(box) {
        var len = 28;
        var children = box.children || [];
        children.forEach(function(child) {
          len += Box.encodingLength(child);
        });
        return len;
      };
      exports.esds = {};
      exports.esds.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(box.buffer.length);
        box.buffer.copy(buf, 0);
        exports.esds.encode.bytes = box.buffer.length;
      };
      exports.esds.decode = function(buf, offset, end) {
        buf = buf.slice(offset, end);
        var desc = Descriptor.Descriptor.decode(buf, 0, buf.length);
        var esd = desc.tagName === "ESDescriptor" ? desc : {};
        var dcd = esd.DecoderConfigDescriptor || {};
        var oti = dcd.oti || 0;
        var dsi = dcd.DecoderSpecificInfo;
        var audioConfig = dsi ? (dsi.buffer.readUInt8(0) & 248) >> 3 : 0;
        var mimeCodec = null;
        if (oti) {
          mimeCodec = oti.toString(16);
          if (audioConfig) {
            mimeCodec += "." + audioConfig;
          }
        }
        return {
          mimeCodec,
          buffer: Buffer3.from(buf.slice(0))
        };
      };
      exports.esds.encodingLength = function(box) {
        return box.buffer.length;
      };
      exports.stsz = {};
      exports.stsz.encode = function(box, buf, offset) {
        var entries = box.entries || [];
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.stsz.encodingLength(box));
        buf.writeUInt32BE(0, 0);
        buf.writeUInt32BE(entries.length, 4);
        for (var i = 0; i < entries.length; i++) {
          buf.writeUInt32BE(entries[i], i * 4 + 8);
        }
        exports.stsz.encode.bytes = 8 + entries.length * 4;
        return buf;
      };
      exports.stsz.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var size = buf.readUInt32BE(0);
        var num = buf.readUInt32BE(4);
        var entries = new Array(num);
        for (var i = 0; i < num; i++) {
          if (size === 0) {
            entries[i] = buf.readUInt32BE(i * 4 + 8);
          } else {
            entries[i] = size;
          }
        }
        return {
          entries
        };
      };
      exports.stsz.encodingLength = function(box) {
        return 8 + box.entries.length * 4;
      };
      exports.stss = exports.stco = {};
      exports.stco.encode = function(box, buf, offset) {
        var entries = box.entries || [];
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.stco.encodingLength(box));
        buf.writeUInt32BE(entries.length, 0);
        for (var i = 0; i < entries.length; i++) {
          buf.writeUInt32BE(entries[i], i * 4 + 4);
        }
        exports.stco.encode.bytes = 4 + entries.length * 4;
        return buf;
      };
      exports.stco.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var num = buf.readUInt32BE(0);
        var entries = new Array(num);
        for (var i = 0; i < num; i++) {
          entries[i] = buf.readUInt32BE(i * 4 + 4);
        }
        return {
          entries
        };
      };
      exports.stco.encodingLength = function(box) {
        return 4 + box.entries.length * 4;
      };
      exports.co64 = {};
      exports.co64.encode = function(box, buf, offset) {
        var entries = box.entries || [];
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.co64.encodingLength(box));
        buf.writeUInt32BE(entries.length, 0);
        for (var i = 0; i < entries.length; i++) {
          uint64be.encode(entries[i], buf, i * 8 + 4);
        }
        exports.co64.encode.bytes = 4 + entries.length * 8;
        return buf;
      };
      exports.co64.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var num = buf.readUInt32BE(0);
        var entries = new Array(num);
        for (var i = 0; i < num; i++) {
          entries[i] = uint64be.decode(buf, i * 8 + 4);
        }
        return {
          entries
        };
      };
      exports.co64.encodingLength = function(box) {
        return 4 + box.entries.length * 8;
      };
      exports.stts = {};
      exports.stts.encode = function(box, buf, offset) {
        var entries = box.entries || [];
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.stts.encodingLength(box));
        buf.writeUInt32BE(entries.length, 0);
        for (var i = 0; i < entries.length; i++) {
          var ptr = i * 8 + 4;
          buf.writeUInt32BE(entries[i].count || 0, ptr);
          buf.writeUInt32BE(entries[i].duration || 0, ptr + 4);
        }
        exports.stts.encode.bytes = 4 + box.entries.length * 8;
        return buf;
      };
      exports.stts.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var num = buf.readUInt32BE(0);
        var entries = new Array(num);
        for (var i = 0; i < num; i++) {
          var ptr = i * 8 + 4;
          entries[i] = {
            count: buf.readUInt32BE(ptr),
            duration: buf.readUInt32BE(ptr + 4)
          };
        }
        return {
          entries
        };
      };
      exports.stts.encodingLength = function(box) {
        return 4 + box.entries.length * 8;
      };
      exports.ctts = {};
      exports.ctts.encode = function(box, buf, offset) {
        var entries = box.entries || [];
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.ctts.encodingLength(box));
        buf.writeUInt32BE(entries.length, 0);
        for (var i = 0; i < entries.length; i++) {
          var ptr = i * 8 + 4;
          buf.writeUInt32BE(entries[i].count || 0, ptr);
          buf.writeUInt32BE(entries[i].compositionOffset || 0, ptr + 4);
        }
        exports.ctts.encode.bytes = 4 + entries.length * 8;
        return buf;
      };
      exports.ctts.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var num = buf.readUInt32BE(0);
        var entries = new Array(num);
        for (var i = 0; i < num; i++) {
          var ptr = i * 8 + 4;
          entries[i] = {
            count: buf.readUInt32BE(ptr),
            compositionOffset: buf.readInt32BE(ptr + 4)
          };
        }
        return {
          entries
        };
      };
      exports.ctts.encodingLength = function(box) {
        return 4 + box.entries.length * 8;
      };
      exports.stsc = {};
      exports.stsc.encode = function(box, buf, offset) {
        var entries = box.entries || [];
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.stsc.encodingLength(box));
        buf.writeUInt32BE(entries.length, 0);
        for (var i = 0; i < entries.length; i++) {
          var ptr = i * 12 + 4;
          buf.writeUInt32BE(entries[i].firstChunk || 0, ptr);
          buf.writeUInt32BE(entries[i].samplesPerChunk || 0, ptr + 4);
          buf.writeUInt32BE(entries[i].sampleDescriptionId || 0, ptr + 8);
        }
        exports.stsc.encode.bytes = 4 + entries.length * 12;
        return buf;
      };
      exports.stsc.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var num = buf.readUInt32BE(0);
        var entries = new Array(num);
        for (var i = 0; i < num; i++) {
          var ptr = i * 12 + 4;
          entries[i] = {
            firstChunk: buf.readUInt32BE(ptr),
            samplesPerChunk: buf.readUInt32BE(ptr + 4),
            sampleDescriptionId: buf.readUInt32BE(ptr + 8)
          };
        }
        return {
          entries
        };
      };
      exports.stsc.encodingLength = function(box) {
        return 4 + box.entries.length * 12;
      };
      exports.dref = {};
      exports.dref.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.dref.encodingLength(box));
        var entries = box.entries || [];
        buf.writeUInt32BE(entries.length, 0);
        var ptr = 4;
        for (var i = 0; i < entries.length; i++) {
          var entry = entries[i];
          var size = (entry.buf ? entry.buf.length : 0) + 4 + 4;
          buf.writeUInt32BE(size, ptr);
          ptr += 4;
          buf.write(entry.type, ptr, 4, "ascii");
          ptr += 4;
          if (entry.buf) {
            entry.buf.copy(buf, ptr);
            ptr += entry.buf.length;
          }
        }
        exports.dref.encode.bytes = ptr;
        return buf;
      };
      exports.dref.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var num = buf.readUInt32BE(0);
        var entries = new Array(num);
        var ptr = 4;
        for (var i = 0; i < num; i++) {
          var size = buf.readUInt32BE(ptr);
          var type2 = buf.toString("ascii", ptr + 4, ptr + 8);
          var tmp = buf.slice(ptr + 8, ptr + size);
          ptr += size;
          entries[i] = {
            type: type2,
            buf: tmp
          };
        }
        return {
          entries
        };
      };
      exports.dref.encodingLength = function(box) {
        var totalSize = 4;
        if (!box.entries)
          return totalSize;
        for (var i = 0; i < box.entries.length; i++) {
          var buf = box.entries[i].buf;
          totalSize += (buf ? buf.length : 0) + 4 + 4;
        }
        return totalSize;
      };
      exports.elst = {};
      exports.elst.encode = function(box, buf, offset) {
        var entries = box.entries || [];
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.elst.encodingLength(box));
        buf.writeUInt32BE(entries.length, 0);
        for (var i = 0; i < entries.length; i++) {
          var ptr = i * 12 + 4;
          buf.writeUInt32BE(entries[i].trackDuration || 0, ptr);
          buf.writeUInt32BE(entries[i].mediaTime || 0, ptr + 4);
          writeFixed32(entries[i].mediaRate || 0, buf, ptr + 8);
        }
        exports.elst.encode.bytes = 4 + entries.length * 12;
        return buf;
      };
      exports.elst.decode = function(buf, offset) {
        buf = buf.slice(offset);
        var num = buf.readUInt32BE(0);
        var entries = new Array(num);
        for (var i = 0; i < num; i++) {
          var ptr = i * 12 + 4;
          entries[i] = {
            trackDuration: buf.readUInt32BE(ptr),
            mediaTime: buf.readInt32BE(ptr + 4),
            mediaRate: readFixed32(buf, ptr + 8)
          };
        }
        return {
          entries
        };
      };
      exports.elst.encodingLength = function(box) {
        return 4 + box.entries.length * 12;
      };
      exports.hdlr = {};
      exports.hdlr.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(exports.hdlr.encodingLength(box));
        var len = 21 + (box.name || "").length;
        buf.fill(0, 0, len);
        buf.write(box.handlerType || "", 4, 4, "ascii");
        writeString(box.name || "", buf, 20);
        exports.hdlr.encode.bytes = len;
        return buf;
      };
      exports.hdlr.decode = function(buf, offset, end) {
        buf = buf.slice(offset);
        return {
          handlerType: buf.toString("ascii", 4, 8),
          name: readString(buf, 20, end)
        };
      };
      exports.hdlr.encodingLength = function(box) {
        return 21 + (box.name || "").length;
      };
      exports.mehd = {};
      exports.mehd.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(4);
        buf.writeUInt32BE(box.fragmentDuration || 0, 0);
        exports.mehd.encode.bytes = 4;
        return buf;
      };
      exports.mehd.decode = function(buf, offset) {
        buf = buf.slice(offset);
        return {
          fragmentDuration: buf.readUInt32BE(0)
        };
      };
      exports.mehd.encodingLength = function(box) {
        return 4;
      };
      exports.trex = {};
      exports.trex.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(20);
        buf.writeUInt32BE(box.trackId || 0, 0);
        buf.writeUInt32BE(box.defaultSampleDescriptionIndex || 0, 4);
        buf.writeUInt32BE(box.defaultSampleDuration || 0, 8);
        buf.writeUInt32BE(box.defaultSampleSize || 0, 12);
        buf.writeUInt32BE(box.defaultSampleFlags || 0, 16);
        exports.trex.encode.bytes = 20;
        return buf;
      };
      exports.trex.decode = function(buf, offset) {
        buf = buf.slice(offset);
        return {
          trackId: buf.readUInt32BE(0),
          defaultSampleDescriptionIndex: buf.readUInt32BE(4),
          defaultSampleDuration: buf.readUInt32BE(8),
          defaultSampleSize: buf.readUInt32BE(12),
          defaultSampleFlags: buf.readUInt32BE(16)
        };
      };
      exports.trex.encodingLength = function(box) {
        return 20;
      };
      exports.mfhd = {};
      exports.mfhd.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(4);
        buf.writeUInt32BE(box.sequenceNumber || 0, 0);
        exports.mfhd.encode.bytes = 4;
        return buf;
      };
      exports.mfhd.decode = function(buf, offset) {
        return {
          sequenceNumber: buf.readUInt32BE(0)
        };
      };
      exports.mfhd.encodingLength = function(box) {
        return 4;
      };
      exports.tfhd = {};
      exports.tfhd.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(4);
        buf.writeUInt32BE(box.trackId, 0);
        exports.tfhd.encode.bytes = 4;
        return buf;
      };
      exports.tfhd.decode = function(buf, offset) {
      };
      exports.tfhd.encodingLength = function(box) {
        return 4;
      };
      exports.tfdt = {};
      exports.tfdt.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(4);
        buf.writeUInt32BE(box.baseMediaDecodeTime || 0, 0);
        exports.tfdt.encode.bytes = 4;
        return buf;
      };
      exports.tfdt.decode = function(buf, offset) {
      };
      exports.tfdt.encodingLength = function(box) {
        return 4;
      };
      exports.trun = {};
      exports.trun.encode = function(box, buf, offset) {
        buf = buf ? buf.slice(offset) : Buffer3.alloc(8 + box.entries.length * 16);
        buf.writeUInt32BE(box.entries.length, 0);
        buf.writeInt32BE(box.dataOffset, 4);
        var ptr = 8;
        for (var i = 0; i < box.entries.length; i++) {
          var entry = box.entries[i];
          buf.writeUInt32BE(entry.sampleDuration, ptr);
          ptr += 4;
          buf.writeUInt32BE(entry.sampleSize, ptr);
          ptr += 4;
          buf.writeUInt32BE(entry.sampleFlags, ptr);
          ptr += 4;
          if ((box.version || 0) === 0) {
            buf.writeUInt32BE(entry.sampleCompositionTimeOffset, ptr);
          } else {
            buf.writeInt32BE(entry.sampleCompositionTimeOffset, ptr);
          }
          ptr += 4;
        }
        exports.trun.encode.bytes = ptr;
      };
      exports.trun.decode = function(buf, offset) {
      };
      exports.trun.encodingLength = function(box) {
        return 8 + box.entries.length * 16;
      };
      exports.mdat = {};
      exports.mdat.encode = function(box, buf, offset) {
        if (box.buffer) {
          box.buffer.copy(buf, offset);
          exports.mdat.encode.bytes = box.buffer.length;
        } else {
          exports.mdat.encode.bytes = exports.mdat.encodingLength(box);
        }
      };
      exports.mdat.decode = function(buf, start, end) {
        return {
          buffer: Buffer3.from(buf.slice(start, end))
        };
      };
      exports.mdat.encodingLength = function(box) {
        return box.buffer ? box.buffer.length : box.contentLength;
      };
      function writeReserved(buf, offset, end) {
        for (var i = offset; i < end; i++)
          buf[i] = 0;
      }
      function writeDate(date, buf, offset) {
        buf.writeUInt32BE(Math.floor((date.getTime() + TIME_OFFSET) / 1e3), offset);
      }
      function writeDate64(date, buf, offset) {
        buf.writeUIntBE(Math.floor((date.getTime() + TIME_OFFSET) / 1e3), offset, 6);
      }
      function writeFixed32(num, buf, offset) {
        buf.writeUInt16BE(Math.floor(num) % (256 * 256), offset);
        buf.writeUInt16BE(Math.floor(num * 256 * 256) % (256 * 256), offset + 2);
      }
      function writeFixed16(num, buf, offset) {
        buf[offset] = Math.floor(num) % 256;
        buf[offset + 1] = Math.floor(num * 256) % 256;
      }
      function writeMatrix(list, buf, offset) {
        if (!list)
          list = [0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (var i = 0; i < list.length; i++) {
          writeFixed32(list[i], buf, offset + i * 4);
        }
      }
      function writeString(str, buf, offset) {
        var strBuffer = Buffer3.from(str, "utf8");
        strBuffer.copy(buf, offset);
        buf[offset + strBuffer.length] = 0;
      }
      function readMatrix(buf) {
        var list = new Array(buf.length / 4);
        for (var i = 0; i < list.length; i++)
          list[i] = readFixed32(buf, i * 4);
        return list;
      }
      function readDate64(buf, offset) {
        return new Date(buf.readUIntBE(offset, 6) * 1e3 - TIME_OFFSET);
      }
      function readDate(buf, offset) {
        return new Date(buf.readUInt32BE(offset) * 1e3 - TIME_OFFSET);
      }
      function readFixed32(buf, offset) {
        return buf.readUInt16BE(offset) + buf.readUInt16BE(offset + 2) / (256 * 256);
      }
      function readFixed16(buf, offset) {
        return buf[offset] + buf[offset + 1] / 256;
      }
      function readString(buf, offset, length) {
        var i;
        for (i = 0; i < length; i++) {
          if (buf[offset + i] === 0) {
            break;
          }
        }
        return buf.toString("utf8", offset, offset + i);
      }
    }
  });

  // node_modules/mp4-box-encoding/index.js
  var require_mp4_box_encoding = __commonJS({
    "node_modules/mp4-box-encoding/index.js"(exports) {
      init_esbuild_inject();
      var uint64be = require_uint64be();
      var boxes = require_boxes();
      var UINT32_MAX = 4294967295;
      var Box = exports;
      var containers = exports.containers = {
        "moov": ["mvhd", "meta", "traks", "mvex"],
        "trak": ["tkhd", "tref", "trgr", "edts", "meta", "mdia", "udta"],
        "edts": ["elst"],
        "mdia": ["mdhd", "hdlr", "elng", "minf"],
        "minf": ["vmhd", "smhd", "hmhd", "sthd", "nmhd", "dinf", "stbl"],
        "dinf": ["dref"],
        "stbl": ["stsd", "stts", "ctts", "cslg", "stsc", "stsz", "stz2", "stco", "co64", "stss", "stsh", "padb", "stdp", "sdtp", "sbgps", "sgpds", "subss", "saizs", "saios"],
        "mvex": ["mehd", "trexs", "leva"],
        "moof": ["mfhd", "meta", "trafs"],
        "traf": ["tfhd", "tfdt", "trun", "sbgps", "sgpds", "subss", "saizs", "saios", "meta"]
      };
      Box.encode = function(obj, buffer, offset) {
        Box.encodingLength(obj);
        offset = offset || 0;
        buffer = buffer || Buffer3.alloc(obj.length);
        return Box._encode(obj, buffer, offset);
      };
      Box._encode = function(obj, buffer, offset) {
        var type2 = obj.type;
        var len = obj.length;
        if (len > UINT32_MAX) {
          len = 1;
        }
        buffer.writeUInt32BE(len, offset);
        buffer.write(obj.type, offset + 4, 4, "ascii");
        var ptr = offset + 8;
        if (len === 1) {
          uint64be.encode(obj.length, buffer, ptr);
          ptr += 8;
        }
        if (boxes.fullBoxes[type2]) {
          buffer.writeUInt32BE(obj.flags || 0, ptr);
          buffer.writeUInt8(obj.version || 0, ptr);
          ptr += 4;
        }
        if (containers[type2]) {
          var contents = containers[type2];
          contents.forEach(function(childType) {
            if (childType.length === 5) {
              var entry = obj[childType] || [];
              childType = childType.substr(0, 4);
              entry.forEach(function(child) {
                Box._encode(child, buffer, ptr);
                ptr += Box.encode.bytes;
              });
            } else if (obj[childType]) {
              Box._encode(obj[childType], buffer, ptr);
              ptr += Box.encode.bytes;
            }
          });
          if (obj.otherBoxes) {
            obj.otherBoxes.forEach(function(child) {
              Box._encode(child, buffer, ptr);
              ptr += Box.encode.bytes;
            });
          }
        } else if (boxes[type2]) {
          var encode3 = boxes[type2].encode;
          encode3(obj, buffer, ptr);
          ptr += encode3.bytes;
        } else if (obj.buffer) {
          var buf = obj.buffer;
          buf.copy(buffer, ptr);
          ptr += obj.buffer.length;
        } else {
          throw new Error("Either `type` must be set to a known type (not'" + type2 + "') or `buffer` must be set");
        }
        Box.encode.bytes = ptr - offset;
        return buffer;
      };
      Box.readHeaders = function(buffer, start, end) {
        start = start || 0;
        end = end || buffer.length;
        if (end - start < 8) {
          return 8;
        }
        var len = buffer.readUInt32BE(start);
        var type2 = buffer.toString("ascii", start + 4, start + 8);
        var ptr = start + 8;
        if (len === 1) {
          if (end - start < 16) {
            return 16;
          }
          len = uint64be.decode(buffer, ptr);
          ptr += 8;
        }
        var version3;
        var flags;
        if (boxes.fullBoxes[type2]) {
          version3 = buffer.readUInt8(ptr);
          flags = buffer.readUInt32BE(ptr) & 16777215;
          ptr += 4;
        }
        return {
          length: len,
          headersLen: ptr - start,
          contentLen: len - (ptr - start),
          type: type2,
          version: version3,
          flags
        };
      };
      Box.decode = function(buffer, start, end) {
        start = start || 0;
        end = end || buffer.length;
        var headers = Box.readHeaders(buffer, start, end);
        if (!headers || headers.length > end - start) {
          throw new Error("Data too short");
        }
        return Box.decodeWithoutHeaders(headers, buffer, start + headers.headersLen, start + headers.length);
      };
      Box.decodeWithoutHeaders = function(headers, buffer, start, end) {
        start = start || 0;
        end = end || buffer.length;
        var type2 = headers.type;
        var obj = {};
        if (containers[type2]) {
          obj.otherBoxes = [];
          var contents = containers[type2];
          var ptr = start;
          while (end - ptr >= 8) {
            var child = Box.decode(buffer, ptr, end);
            ptr += child.length;
            if (contents.indexOf(child.type) >= 0) {
              obj[child.type] = child;
            } else if (contents.indexOf(child.type + "s") >= 0) {
              var childType = child.type + "s";
              var entry = obj[childType] = obj[childType] || [];
              entry.push(child);
            } else {
              obj.otherBoxes.push(child);
            }
          }
        } else if (boxes[type2]) {
          var decode2 = boxes[type2].decode;
          obj = decode2(buffer, start, end);
        } else {
          obj.buffer = Buffer3.from(buffer.slice(start, end));
        }
        obj.length = headers.length;
        obj.contentLen = headers.contentLen;
        obj.type = headers.type;
        obj.version = headers.version;
        obj.flags = headers.flags;
        return obj;
      };
      Box.encodingLength = function(obj) {
        var type2 = obj.type;
        var len = 8;
        if (boxes.fullBoxes[type2]) {
          len += 4;
        }
        if (containers[type2]) {
          var contents = containers[type2];
          contents.forEach(function(childType) {
            if (childType.length === 5) {
              var entry = obj[childType] || [];
              childType = childType.substr(0, 4);
              entry.forEach(function(child2) {
                child2.type = childType;
                len += Box.encodingLength(child2);
              });
            } else if (obj[childType]) {
              var child = obj[childType];
              child.type = childType;
              len += Box.encodingLength(child);
            }
          });
          if (obj.otherBoxes) {
            obj.otherBoxes.forEach(function(child) {
              len += Box.encodingLength(child);
            });
          }
        } else if (boxes[type2]) {
          len += boxes[type2].encodingLength(obj);
        } else if (obj.buffer) {
          len += obj.buffer.length;
        } else {
          throw new Error("Either `type` must be set to a known type (not'" + type2 + "') or `buffer` must be set");
        }
        if (len > UINT32_MAX) {
          len += 8;
        }
        obj.length = len;
        return len;
      };
    }
  });

  // node_modules/mp4-stream/decode.js
  var require_decode2 = __commonJS({
    "node_modules/mp4-stream/decode.js"(exports, module) {
      init_esbuild_inject();
      var stream = require_readable_browser9();
      var nextEvent = require_next_event();
      var Box = require_mp4_box_encoding();
      var EMPTY = Buffer3.alloc(0);
      var Decoder = class extends stream.Writable {
        constructor(opts) {
          super(opts);
          this.destroyed = false;
          this._pending = 0;
          this._missing = 0;
          this._ignoreEmpty = false;
          this._buf = null;
          this._str = null;
          this._cb = null;
          this._ondrain = null;
          this._writeBuffer = null;
          this._writeCb = null;
          this._ondrain = null;
          this._kick();
        }
        destroy(err) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          if (err)
            this.emit("error", err);
          this.emit("close");
        }
        _write(data, enc, next) {
          if (this.destroyed)
            return;
          var drained = !this._str || !this._str._writableState.needDrain;
          while (data.length && !this.destroyed) {
            if (!this._missing && !this._ignoreEmpty) {
              this._writeBuffer = data;
              this._writeCb = next;
              return;
            }
            var consumed = data.length < this._missing ? data.length : this._missing;
            if (this._buf)
              data.copy(this._buf, this._buf.length - this._missing);
            else if (this._str)
              drained = this._str.write(consumed === data.length ? data : data.slice(0, consumed));
            this._missing -= consumed;
            if (!this._missing) {
              var buf = this._buf;
              var cb = this._cb;
              var stream2 = this._str;
              this._buf = this._cb = this._str = this._ondrain = null;
              drained = true;
              this._ignoreEmpty = false;
              if (stream2)
                stream2.end();
              if (cb)
                cb(buf);
            }
            data = consumed === data.length ? EMPTY : data.slice(consumed);
          }
          if (this._pending && !this._missing) {
            this._writeBuffer = data;
            this._writeCb = next;
            return;
          }
          if (drained)
            next();
          else
            this._ondrain(next);
        }
        _buffer(size, cb) {
          this._missing = size;
          this._buf = Buffer3.alloc(size);
          this._cb = cb;
        }
        _stream(size, cb) {
          this._missing = size;
          this._str = new MediaData(this);
          this._ondrain = nextEvent(this._str, "drain");
          this._pending++;
          this._str.on("end", () => {
            this._pending--;
            this._kick();
          });
          this._cb = cb;
          return this._str;
        }
        _readBox() {
          const bufferHeaders = (len, buf) => {
            this._buffer(len, (additionalBuf) => {
              if (buf) {
                buf = Buffer3.concat([buf, additionalBuf]);
              } else {
                buf = additionalBuf;
              }
              var headers = Box.readHeaders(buf);
              if (typeof headers === "number") {
                bufferHeaders(headers - buf.length, buf);
              } else {
                this._pending++;
                this._headers = headers;
                this.emit("box", headers);
              }
            });
          };
          bufferHeaders(8);
        }
        stream() {
          if (!this._headers)
            throw new Error("this function can only be called once after 'box' is emitted");
          var headers = this._headers;
          this._headers = null;
          return this._stream(headers.contentLen, () => {
            this._pending--;
            this._kick();
          });
        }
        decode(cb) {
          if (!this._headers)
            throw new Error("this function can only be called once after 'box' is emitted");
          var headers = this._headers;
          this._headers = null;
          this._buffer(headers.contentLen, (buf) => {
            var box = Box.decodeWithoutHeaders(headers, buf);
            cb(box);
            this._pending--;
            this._kick();
          });
        }
        ignore() {
          if (!this._headers)
            throw new Error("this function can only be called once after 'box' is emitted");
          var headers = this._headers;
          this._headers = null;
          this._missing = headers.contentLen;
          if (this._missing === 0) {
            this._ignoreEmpty = true;
          }
          this._cb = () => {
            this._pending--;
            this._kick();
          };
        }
        _kick() {
          if (this._pending)
            return;
          if (!this._buf && !this._str)
            this._readBox();
          if (this._writeBuffer) {
            var next = this._writeCb;
            var buffer = this._writeBuffer;
            this._writeBuffer = null;
            this._writeCb = null;
            this._write(buffer, null, next);
          }
        }
      };
      var MediaData = class extends stream.PassThrough {
        constructor(parent) {
          super();
          this._parent = parent;
          this.destroyed = false;
        }
        destroy(err) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          this._parent.destroy(err);
          if (err)
            this.emit("error", err);
          this.emit("close");
        }
      };
      module.exports = Decoder;
    }
  });

  // node_modules/mp4-stream/encode.js
  var require_encode2 = __commonJS({
    "node_modules/mp4-stream/encode.js"(exports, module) {
      init_esbuild_inject();
      var stream = require_readable_browser9();
      var Box = require_mp4_box_encoding();
      var queueMicrotask2 = require_queue_microtask();
      function noop2() {
      }
      var Encoder = class extends stream.Readable {
        constructor(opts) {
          super(opts);
          this.destroyed = false;
          this._finalized = false;
          this._reading = false;
          this._stream = null;
          this._drain = null;
          this._want = false;
          this._onreadable = () => {
            if (!this._want)
              return;
            this._want = false;
            this._read();
          };
          this._onend = () => {
            this._stream = null;
          };
        }
        mdat(size, cb) {
          this.mediaData(size, cb);
        }
        mediaData(size, cb) {
          var stream2 = new MediaData(this);
          this.box({ type: "mdat", contentLength: size, encodeBufferLen: 8, stream: stream2 }, cb);
          return stream2;
        }
        box(box, cb) {
          if (!cb)
            cb = noop2;
          if (this.destroyed)
            return cb(new Error("Encoder is destroyed"));
          var buf;
          if (box.encodeBufferLen) {
            buf = Buffer3.alloc(box.encodeBufferLen);
          }
          if (box.stream) {
            box.buffer = null;
            buf = Box.encode(box, buf);
            this.push(buf);
            this._stream = box.stream;
            this._stream.on("readable", this._onreadable);
            this._stream.on("end", this._onend);
            this._stream.on("end", cb);
            this._forward();
          } else {
            buf = Box.encode(box, buf);
            var drained = this.push(buf);
            if (drained)
              return queueMicrotask2(cb);
            this._drain = cb;
          }
        }
        destroy(err) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          if (this._stream && this._stream.destroy)
            this._stream.destroy();
          this._stream = null;
          if (this._drain) {
            var cb = this._drain;
            this._drain = null;
            cb(err);
          }
          if (err)
            this.emit("error", err);
          this.emit("close");
        }
        finalize() {
          this._finalized = true;
          if (!this._stream && !this._drain) {
            this.push(null);
          }
        }
        _forward() {
          if (!this._stream)
            return;
          while (!this.destroyed) {
            var buf = this._stream.read();
            if (!buf) {
              this._want = !!this._stream;
              return;
            }
            if (!this.push(buf))
              return;
          }
        }
        _read() {
          if (this._reading || this.destroyed)
            return;
          this._reading = true;
          if (this._stream)
            this._forward();
          if (this._drain) {
            var drain = this._drain;
            this._drain = null;
            drain();
          }
          this._reading = false;
          if (this._finalized) {
            this.push(null);
          }
        }
      };
      var MediaData = class extends stream.PassThrough {
        constructor(parent) {
          super();
          this._parent = parent;
          this.destroyed = false;
        }
        destroy(err) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          this._parent.destroy(err);
          if (err)
            this.emit("error", err);
          this.emit("close");
        }
      };
      module.exports = Encoder;
    }
  });

  // node_modules/mp4-stream/index.js
  var require_mp4_stream = __commonJS({
    "node_modules/mp4-stream/index.js"(exports) {
      init_esbuild_inject();
      var Decoder = require_decode2();
      var Encoder = require_encode2();
      exports.decode = (opts) => new Decoder(opts);
      exports.encode = (opts) => new Encoder(opts);
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/errors-browser.js
  var require_errors_browser10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser10().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser10();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy10();
      var _require = require_state10();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser10().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex10();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex10();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable10();
      var Writable2 = require_stream_writable10();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream11 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser10().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream11();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser10();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list10();
      var destroyImpl = require_destroy10();
      var _require = require_state10();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser10().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex10();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex10();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator10();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser10();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser10().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex10();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform10();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser10().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream11();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/range-slice-stream/node_modules/readable-stream/readable-browser.js
  var require_readable_browser10 = __commonJS({
    "node_modules/range-slice-stream/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable10();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable10();
      exports.Duplex = require_stream_duplex10();
      exports.Transform = require_stream_transform10();
      exports.PassThrough = require_stream_passthrough10();
      exports.finished = require_end_of_stream11();
      exports.pipeline = require_pipeline10();
    }
  });

  // node_modules/range-slice-stream/index.js
  var require_range_slice_stream = __commonJS({
    "node_modules/range-slice-stream/index.js"(exports, module) {
      init_esbuild_inject();
      var { Writable: Writable2, PassThrough: PassThrough2 } = require_readable_browser10();
      var RangeSliceStream = class extends Writable2 {
        constructor(offset, opts = {}) {
          super(opts);
          this.destroyed = false;
          this._queue = [];
          this._position = offset || 0;
          this._cb = null;
          this._buffer = null;
          this._out = null;
        }
        _write(chunk, encoding, cb) {
          let drained = true;
          while (true) {
            if (this.destroyed) {
              return;
            }
            if (this._queue.length === 0) {
              this._buffer = chunk;
              this._cb = cb;
              return;
            }
            this._buffer = null;
            var currRange = this._queue[0];
            const writeStart = Math.max(currRange.start - this._position, 0);
            const writeEnd = currRange.end - this._position;
            if (writeStart >= chunk.length) {
              this._position += chunk.length;
              return cb(null);
            }
            let toWrite;
            if (writeEnd > chunk.length) {
              this._position += chunk.length;
              if (writeStart === 0) {
                toWrite = chunk;
              } else {
                toWrite = chunk.slice(writeStart);
              }
              drained = currRange.stream.write(toWrite) && drained;
              break;
            }
            this._position += writeEnd;
            toWrite = writeStart === 0 && writeEnd === chunk.length ? chunk : chunk.slice(writeStart, writeEnd);
            drained = currRange.stream.write(toWrite) && drained;
            if (currRange.last) {
              currRange.stream.end();
            }
            chunk = chunk.slice(writeEnd);
            this._queue.shift();
          }
          if (drained) {
            cb(null);
          } else {
            currRange.stream.once("drain", cb.bind(null, null));
          }
        }
        slice(ranges) {
          if (this.destroyed)
            return null;
          if (!Array.isArray(ranges))
            ranges = [ranges];
          const str = new PassThrough2();
          ranges.forEach((range, i) => {
            this._queue.push({
              start: range.start,
              end: range.end,
              stream: str,
              last: i === ranges.length - 1
            });
          });
          if (this._buffer) {
            this._write(this._buffer, null, this._cb);
          }
          return str;
        }
        destroy(err) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          if (err)
            this.emit("error", err);
        }
      };
      module.exports = RangeSliceStream;
    }
  });

  // node_modules/videostream/mp4-remuxer.js
  var require_mp4_remuxer = __commonJS({
    "node_modules/videostream/mp4-remuxer.js"(exports, module) {
      init_esbuild_inject();
      var bs = require_binary_search();
      var EventEmitter2 = require_events();
      var mp4 = require_mp4_stream();
      var Box = require_mp4_box_encoding();
      var RangeSliceStream = require_range_slice_stream();
      var FIND_MOOV_SEEK_SIZE = 4096;
      var MP4Remuxer = class extends EventEmitter2 {
        constructor(file) {
          super();
          this._tracks = [];
          this._file = file;
          this._decoder = null;
          this._findMoov(0);
        }
        _findMoov(offset) {
          if (this._decoder) {
            this._decoder.destroy();
          }
          let toSkip = 0;
          this._decoder = mp4.decode();
          const fileStream = this._file.createReadStream({
            start: offset
          });
          fileStream.pipe(this._decoder);
          const boxHandler = (headers) => {
            if (headers.type === "moov") {
              this._decoder.removeListener("box", boxHandler);
              this._decoder.decode((moov) => {
                fileStream.destroy();
                try {
                  this._processMoov(moov);
                } catch (err) {
                  err.message = `Cannot parse mp4 file: ${err.message}`;
                  this.emit("error", err);
                }
              });
            } else if (headers.length < FIND_MOOV_SEEK_SIZE) {
              toSkip += headers.length;
              this._decoder.ignore();
            } else {
              this._decoder.removeListener("box", boxHandler);
              toSkip += headers.length;
              fileStream.destroy();
              this._decoder.destroy();
              this._findMoov(offset + toSkip);
            }
          };
          this._decoder.on("box", boxHandler);
        }
        _processMoov(moov) {
          const traks = moov.traks;
          this._tracks = [];
          this._hasVideo = false;
          this._hasAudio = false;
          for (let i = 0; i < traks.length; i++) {
            const trak = traks[i];
            const stbl = trak.mdia.minf.stbl;
            const stsdEntry = stbl.stsd.entries[0];
            const handlerType = trak.mdia.hdlr.handlerType;
            let codec;
            let mime;
            if (handlerType === "vide" && stsdEntry.type === "avc1") {
              if (this._hasVideo) {
                continue;
              }
              this._hasVideo = true;
              codec = "avc1";
              if (stsdEntry.avcC) {
                codec += `.${stsdEntry.avcC.mimeCodec}`;
              }
              mime = `video/mp4; codecs="${codec}"`;
            } else if (handlerType === "soun" && stsdEntry.type === "mp4a") {
              if (this._hasAudio) {
                continue;
              }
              this._hasAudio = true;
              codec = "mp4a";
              if (stsdEntry.esds && stsdEntry.esds.mimeCodec) {
                codec += `.${stsdEntry.esds.mimeCodec}`;
              }
              mime = `audio/mp4; codecs="${codec}"`;
            } else {
              continue;
            }
            const samples = [];
            let sample = 0;
            let sampleInChunk = 0;
            let chunk = 0;
            let offsetInChunk = 0;
            let sampleToChunkIndex = 0;
            let dts = 0;
            const decodingTimeEntry = new RunLengthIndex(stbl.stts.entries);
            let presentationOffsetEntry = null;
            if (stbl.ctts) {
              presentationOffsetEntry = new RunLengthIndex(stbl.ctts.entries);
            }
            let syncSampleIndex = 0;
            while (true) {
              var currChunkEntry = stbl.stsc.entries[sampleToChunkIndex];
              const size = stbl.stsz.entries[sample];
              const duration = decodingTimeEntry.value.duration;
              const presentationOffset = presentationOffsetEntry ? presentationOffsetEntry.value.compositionOffset : 0;
              let sync = true;
              if (stbl.stss) {
                sync = stbl.stss.entries[syncSampleIndex] === sample + 1;
              }
              const chunkOffsetTable = stbl.stco || stbl.co64;
              samples.push({
                size,
                duration,
                dts,
                presentationOffset,
                sync,
                offset: offsetInChunk + chunkOffsetTable.entries[chunk]
              });
              sample++;
              if (sample >= stbl.stsz.entries.length) {
                break;
              }
              sampleInChunk++;
              offsetInChunk += size;
              if (sampleInChunk >= currChunkEntry.samplesPerChunk) {
                sampleInChunk = 0;
                offsetInChunk = 0;
                chunk++;
                const nextChunkEntry = stbl.stsc.entries[sampleToChunkIndex + 1];
                if (nextChunkEntry && chunk + 1 >= nextChunkEntry.firstChunk) {
                  sampleToChunkIndex++;
                }
              }
              dts += duration;
              decodingTimeEntry.inc();
              presentationOffsetEntry && presentationOffsetEntry.inc();
              if (sync) {
                syncSampleIndex++;
              }
            }
            trak.mdia.mdhd.duration = 0;
            trak.tkhd.duration = 0;
            const defaultSampleDescriptionIndex = currChunkEntry.sampleDescriptionId;
            const trackMoov = {
              type: "moov",
              mvhd: moov.mvhd,
              traks: [{
                tkhd: trak.tkhd,
                mdia: {
                  mdhd: trak.mdia.mdhd,
                  hdlr: trak.mdia.hdlr,
                  elng: trak.mdia.elng,
                  minf: {
                    vmhd: trak.mdia.minf.vmhd,
                    smhd: trak.mdia.minf.smhd,
                    dinf: trak.mdia.minf.dinf,
                    stbl: {
                      stsd: stbl.stsd,
                      stts: empty(),
                      ctts: empty(),
                      stsc: empty(),
                      stsz: empty(),
                      stco: empty(),
                      stss: empty()
                    }
                  }
                }
              }],
              mvex: {
                mehd: {
                  fragmentDuration: moov.mvhd.duration
                },
                trexs: [{
                  trackId: trak.tkhd.trackId,
                  defaultSampleDescriptionIndex,
                  defaultSampleDuration: 0,
                  defaultSampleSize: 0,
                  defaultSampleFlags: 0
                }]
              }
            };
            this._tracks.push({
              fragmentSequence: 1,
              trackId: trak.tkhd.trackId,
              timeScale: trak.mdia.mdhd.timeScale,
              samples,
              currSample: null,
              currTime: null,
              moov: trackMoov,
              mime
            });
          }
          if (this._tracks.length === 0) {
            this.emit("error", new Error("no playable tracks"));
            return;
          }
          moov.mvhd.duration = 0;
          this._ftyp = {
            type: "ftyp",
            brand: "iso5",
            brandVersion: 0,
            compatibleBrands: [
              "iso5"
            ]
          };
          const ftypBuf = Box.encode(this._ftyp);
          const data = this._tracks.map((track) => {
            const moovBuf = Box.encode(track.moov);
            return {
              mime: track.mime,
              init: Buffer3.concat([ftypBuf, moovBuf])
            };
          });
          this.emit("ready", data);
        }
        seek(time) {
          if (!this._tracks) {
            throw new Error("Not ready yet; wait for 'ready' event");
          }
          if (this._fileStream) {
            this._fileStream.destroy();
            this._fileStream = null;
          }
          let startOffset = -1;
          this._tracks.map((track, i) => {
            if (track.outStream) {
              track.outStream.destroy();
            }
            if (track.inStream) {
              track.inStream.destroy();
              track.inStream = null;
            }
            const outStream = track.outStream = mp4.encode();
            const fragment = this._generateFragment(i, time);
            if (!fragment) {
              return outStream.finalize();
            }
            if (startOffset === -1 || fragment.ranges[0].start < startOffset) {
              startOffset = fragment.ranges[0].start;
            }
            const writeFragment = (frag) => {
              if (outStream.destroyed)
                return;
              outStream.box(frag.moof, (err) => {
                if (err)
                  return this.emit("error", err);
                if (outStream.destroyed)
                  return;
                const slicedStream = track.inStream.slice(frag.ranges);
                slicedStream.pipe(outStream.mediaData(frag.length, (err2) => {
                  if (err2)
                    return this.emit("error", err2);
                  if (outStream.destroyed)
                    return;
                  const nextFrag = this._generateFragment(i);
                  if (!nextFrag) {
                    return outStream.finalize();
                  }
                  writeFragment(nextFrag);
                }));
              });
            };
            writeFragment(fragment);
          });
          if (startOffset >= 0) {
            const fileStream = this._fileStream = this._file.createReadStream({
              start: startOffset
            });
            this._tracks.forEach((track) => {
              track.inStream = new RangeSliceStream(startOffset, {
                highWaterMark: 1e7
              });
              fileStream.pipe(track.inStream);
            });
          }
          return this._tracks.map((track) => {
            return track.outStream;
          });
        }
        _findSampleBefore(trackInd, time) {
          const track = this._tracks[trackInd];
          const scaledTime = Math.floor(track.timeScale * time);
          let sample = bs(track.samples, scaledTime, (sample2, t) => {
            const pts = sample2.dts + sample2.presentationOffset;
            return pts - t;
          });
          if (sample === -1) {
            sample = 0;
          } else if (sample < 0) {
            sample = -sample - 2;
          }
          while (!track.samples[sample].sync) {
            sample--;
          }
          return sample;
        }
        _generateFragment(track, time) {
          const currTrack = this._tracks[track];
          let firstSample;
          if (time !== void 0) {
            firstSample = this._findSampleBefore(track, time);
          } else {
            firstSample = currTrack.currSample;
          }
          if (firstSample >= currTrack.samples.length) {
            return null;
          }
          const startDts = currTrack.samples[firstSample].dts;
          let totalLen = 0;
          const ranges = [];
          for (var currSample = firstSample; currSample < currTrack.samples.length; currSample++) {
            const sample = currTrack.samples[currSample];
            if (sample.sync && sample.dts - startDts >= currTrack.timeScale * MIN_FRAGMENT_DURATION) {
              break;
            }
            totalLen += sample.size;
            const currRange = ranges.length - 1;
            if (currRange < 0 || ranges[currRange].end !== sample.offset) {
              ranges.push({
                start: sample.offset,
                end: sample.offset + sample.size
              });
            } else {
              ranges[currRange].end += sample.size;
            }
          }
          currTrack.currSample = currSample;
          return {
            moof: this._generateMoof(track, firstSample, currSample),
            ranges,
            length: totalLen
          };
        }
        _generateMoof(track, firstSample, lastSample) {
          const currTrack = this._tracks[track];
          const entries = [];
          let trunVersion = 0;
          for (let j = firstSample; j < lastSample; j++) {
            const currSample = currTrack.samples[j];
            if (currSample.presentationOffset < 0) {
              trunVersion = 1;
            }
            entries.push({
              sampleDuration: currSample.duration,
              sampleSize: currSample.size,
              sampleFlags: currSample.sync ? 33554432 : 16842752,
              sampleCompositionTimeOffset: currSample.presentationOffset
            });
          }
          const moof = {
            type: "moof",
            mfhd: {
              sequenceNumber: currTrack.fragmentSequence++
            },
            trafs: [{
              tfhd: {
                flags: 131072,
                trackId: currTrack.trackId
              },
              tfdt: {
                baseMediaDecodeTime: currTrack.samples[firstSample].dts
              },
              trun: {
                flags: 3841,
                dataOffset: 8,
                entries,
                version: trunVersion
              }
            }]
          };
          moof.trafs[0].trun.dataOffset += Box.encodingLength(moof);
          return moof;
        }
      };
      var RunLengthIndex = class {
        constructor(entries, countName) {
          this._entries = entries;
          this._countName = countName || "count";
          this._index = 0;
          this._offset = 0;
          this.value = this._entries[0];
        }
        inc() {
          this._offset++;
          if (this._offset >= this._entries[this._index][this._countName]) {
            this._index++;
            this._offset = 0;
          }
          this.value = this._entries[this._index];
        }
      };
      function empty() {
        return {
          version: 0,
          flags: 0,
          entries: []
        };
      }
      var MIN_FRAGMENT_DURATION = 1;
      module.exports = MP4Remuxer;
    }
  });

  // node_modules/videostream/videostream.js
  var require_videostream = __commonJS({
    "node_modules/videostream/videostream.js"(exports, module) {
      init_esbuild_inject();
      var MediaElementWrapper = require_mediasource();
      var pump = require_pump();
      var MP4Remuxer = require_mp4_remuxer();
      function VideoStream(file, mediaElem, opts = {}) {
        if (!(this instanceof VideoStream)) {
          console.warn("Don't invoke VideoStream without the 'new' keyword.");
          return new VideoStream(file, mediaElem, opts);
        }
        this.detailedError = null;
        this._elem = mediaElem;
        this._elemWrapper = new MediaElementWrapper(mediaElem);
        this._waitingFired = false;
        this._trackMeta = null;
        this._file = file;
        this._tracks = null;
        if (this._elem.preload !== "none") {
          this._createMuxer();
        }
        this._onError = () => {
          this.detailedError = this._elemWrapper.detailedError;
          this.destroy();
        };
        this._onWaiting = () => {
          this._waitingFired = true;
          if (!this._muxer) {
            this._createMuxer();
          } else if (this._tracks) {
            this._pump();
          }
        };
        if (mediaElem.autoplay) {
          mediaElem.preload = "auto";
        }
        mediaElem.addEventListener("waiting", this._onWaiting);
        mediaElem.addEventListener("error", this._onError);
      }
      VideoStream.prototype = {
        _createMuxer() {
          this._muxer = new MP4Remuxer(this._file);
          this._muxer.on("ready", (data) => {
            this._tracks = data.map((trackData) => {
              const mediaSource = this._elemWrapper.createWriteStream(trackData.mime);
              mediaSource.on("error", (err) => {
                this._elemWrapper.error(err);
              });
              const track = {
                muxed: null,
                mediaSource,
                initFlushed: false,
                onInitFlushed: null
              };
              mediaSource.write(trackData.init, (err) => {
                track.initFlushed = true;
                if (track.onInitFlushed) {
                  track.onInitFlushed(err);
                }
              });
              return track;
            });
            if (this._waitingFired || this._elem.preload === "auto") {
              this._pump();
            }
          });
          this._muxer.on("error", (err) => {
            this._elemWrapper.error(err);
          });
        },
        _pump() {
          const muxed = this._muxer.seek(this._elem.currentTime, !this._tracks);
          this._tracks.forEach((track, i) => {
            const pumpTrack = () => {
              if (track.muxed) {
                track.muxed.destroy();
                track.mediaSource = this._elemWrapper.createWriteStream(track.mediaSource);
                track.mediaSource.on("error", (err) => {
                  this._elemWrapper.error(err);
                });
              }
              track.muxed = muxed[i];
              pump(track.muxed, track.mediaSource);
            };
            if (!track.initFlushed) {
              track.onInitFlushed = (err) => {
                if (err) {
                  this._elemWrapper.error(err);
                  return;
                }
                pumpTrack();
              };
            } else {
              pumpTrack();
            }
          });
        },
        destroy() {
          if (this.destroyed) {
            return;
          }
          this.destroyed = true;
          this._elem.removeEventListener("waiting", this._onWaiting);
          this._elem.removeEventListener("error", this._onError);
          if (this._tracks) {
            this._tracks.forEach((track) => {
              if (track.muxed) {
                track.muxed.destroy();
              }
            });
          }
          this._elem.src = "";
        }
      };
      module.exports = VideoStream;
    }
  });

  // node_modules/render-media/index.js
  var require_render_media = __commonJS({
    "node_modules/render-media/index.js"(exports) {
      init_esbuild_inject();
      exports.render = render;
      exports.append = append;
      exports.mime = require_mime();
      var debug2 = require_browser5()("render-media");
      var isAscii = require_is_ascii();
      var MediaElementWrapper = require_mediasource();
      var path = require_path();
      var streamToBlobURL = require_stream_to_blob_url();
      var VideoStream = require_videostream();
      var VIDEOSTREAM_EXTS = [
        ".m4a",
        ".m4b",
        ".m4p",
        ".m4v",
        ".mp4"
      ];
      var MEDIASOURCE_VIDEO_EXTS = [
        ".m4v",
        ".mkv",
        ".mp4",
        ".webm"
      ];
      var MEDIASOURCE_AUDIO_EXTS = [
        ".m4a",
        ".m4b",
        ".m4p",
        ".mp3"
      ];
      var MEDIASOURCE_EXTS = [].concat(MEDIASOURCE_VIDEO_EXTS, MEDIASOURCE_AUDIO_EXTS);
      var VIDEO_EXTS = [
        ".mov",
        ".ogv"
      ];
      var AUDIO_EXTS = [
        ".aac",
        ".oga",
        ".ogg",
        ".wav",
        ".flac"
      ];
      var IMAGE_EXTS = [
        ".bmp",
        ".gif",
        ".jpeg",
        ".jpg",
        ".png",
        ".svg"
      ];
      var IFRAME_EXTS = [
        ".css",
        ".html",
        ".js",
        ".md",
        ".pdf",
        ".srt",
        ".txt"
      ];
      var MAX_BLOB_LENGTH = 200 * 1e3 * 1e3;
      var MediaSource = typeof window !== "undefined" && window.MediaSource;
      function render(file, elem, opts, cb) {
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        if (!opts)
          opts = {};
        if (!cb)
          cb = () => {
          };
        validateFile(file);
        parseOpts(opts);
        if (typeof elem === "string")
          elem = document.querySelector(elem);
        renderMedia(file, (tagName) => {
          if (elem.nodeName !== tagName.toUpperCase()) {
            const extname2 = path.extname(file.name).toLowerCase();
            throw new Error(`Cannot render "${extname2}" inside a "${elem.nodeName.toLowerCase()}" element, expected "${tagName}"`);
          }
          if (tagName === "video" || tagName === "audio")
            setMediaOpts(elem, opts);
          return elem;
        }, opts, cb);
      }
      function append(file, rootElem, opts, cb) {
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        if (!opts)
          opts = {};
        if (!cb)
          cb = () => {
          };
        validateFile(file);
        parseOpts(opts);
        if (typeof rootElem === "string")
          rootElem = document.querySelector(rootElem);
        if (rootElem && (rootElem.nodeName === "VIDEO" || rootElem.nodeName === "AUDIO")) {
          throw new Error("Invalid video/audio node argument. Argument must be root element that video/audio tag will be appended to.");
        }
        renderMedia(file, getElem, opts, done2);
        function getElem(tagName) {
          if (tagName === "video" || tagName === "audio")
            return createMedia(tagName);
          else
            return createElem(tagName);
        }
        function createMedia(tagName) {
          const elem = createElem(tagName);
          setMediaOpts(elem, opts);
          rootElem.appendChild(elem);
          return elem;
        }
        function createElem(tagName) {
          const elem = document.createElement(tagName);
          rootElem.appendChild(elem);
          return elem;
        }
        function done2(err, elem) {
          if (err && elem)
            elem.remove();
          cb(err, elem);
        }
      }
      function renderMedia(file, getElem, opts, cb) {
        const extname2 = path.extname(file.name).toLowerCase();
        let currentTime = 0;
        let elem;
        if (MEDIASOURCE_EXTS.includes(extname2)) {
          renderMediaSource();
        } else if (VIDEO_EXTS.includes(extname2)) {
          renderMediaElement("video");
        } else if (AUDIO_EXTS.includes(extname2)) {
          renderMediaElement("audio");
        } else if (IMAGE_EXTS.includes(extname2)) {
          renderImage();
        } else if (IFRAME_EXTS.includes(extname2)) {
          renderIframe();
        } else {
          tryRenderIframe();
        }
        function renderMediaSource() {
          const tagName = MEDIASOURCE_VIDEO_EXTS.includes(extname2) ? "video" : "audio";
          if (MediaSource) {
            if (VIDEOSTREAM_EXTS.includes(extname2)) {
              useVideostream();
            } else {
              useMediaSource();
            }
          } else {
            useBlobURL();
          }
          function useVideostream() {
            debug2(`Use \`videostream\` package for ${file.name}`);
            prepareElem();
            elem.addEventListener("error", fallbackToMediaSource);
            elem.addEventListener("loadstart", onLoadStart);
            elem.addEventListener("loadedmetadata", onLoadedMetadata);
            new VideoStream(file, elem);
          }
          function useMediaSource() {
            debug2(`Use MediaSource API for ${file.name}`);
            prepareElem();
            elem.addEventListener("error", fallbackToBlobURL);
            elem.addEventListener("loadstart", onLoadStart);
            elem.addEventListener("loadedmetadata", onLoadedMetadata);
            const wrapper = new MediaElementWrapper(elem);
            const writable = wrapper.createWriteStream(getCodec(file.name));
            file.createReadStream().pipe(writable);
            if (currentTime)
              elem.currentTime = currentTime;
          }
          function useBlobURL() {
            debug2(`Use Blob URL for ${file.name}`);
            prepareElem();
            elem.addEventListener("error", fatalError);
            elem.addEventListener("loadstart", onLoadStart);
            elem.addEventListener("loadedmetadata", onLoadedMetadata);
            getBlobURL(file, (err, url) => {
              if (err)
                return fatalError(err);
              elem.src = url;
              if (currentTime)
                elem.currentTime = currentTime;
            });
          }
          function fallbackToMediaSource(err) {
            debug2("videostream error: fallback to MediaSource API: %o", err.message || err);
            elem.removeEventListener("error", fallbackToMediaSource);
            elem.removeEventListener("loadedmetadata", onLoadedMetadata);
            useMediaSource();
          }
          function fallbackToBlobURL(err) {
            debug2("MediaSource API error: fallback to Blob URL: %o", err.message || err);
            if (!checkBlobLength())
              return;
            elem.removeEventListener("error", fallbackToBlobURL);
            elem.removeEventListener("loadedmetadata", onLoadedMetadata);
            useBlobURL();
          }
          function prepareElem() {
            if (!elem) {
              elem = getElem(tagName);
              elem.addEventListener("progress", () => {
                currentTime = elem.currentTime;
              });
            }
          }
        }
        function checkBlobLength() {
          if (typeof file.length === "number" && file.length > opts.maxBlobLength) {
            debug2("File length too large for Blob URL approach: %d (max: %d)", file.length, opts.maxBlobLength);
            fatalError(new Error(`File length too large for Blob URL approach: ${file.length} (max: ${opts.maxBlobLength})`));
            return false;
          }
          return true;
        }
        function renderMediaElement(type2) {
          if (!checkBlobLength())
            return;
          elem = getElem(type2);
          getBlobURL(file, (err, url) => {
            if (err)
              return fatalError(err);
            elem.addEventListener("error", fatalError);
            elem.addEventListener("loadstart", onLoadStart);
            elem.addEventListener("loadedmetadata", onLoadedMetadata);
            elem.src = url;
          });
        }
        function onLoadStart() {
          elem.removeEventListener("loadstart", onLoadStart);
          if (opts.autoplay) {
            const playPromise = elem.play();
            if (typeof playPromise !== "undefined")
              playPromise.catch(fatalError);
          }
        }
        function onLoadedMetadata() {
          elem.removeEventListener("loadedmetadata", onLoadedMetadata);
          cb(null, elem);
        }
        function renderImage() {
          elem = getElem("img");
          getBlobURL(file, (err, url) => {
            if (err)
              return fatalError(err);
            elem.src = url;
            elem.alt = file.name;
            cb(null, elem);
          });
        }
        function renderIframe() {
          getBlobURL(file, (err, url) => {
            if (err)
              return fatalError(err);
            if (extname2 !== ".pdf") {
              elem = getElem("iframe");
              elem.sandbox = "allow-forms allow-scripts";
              elem.src = url;
            } else {
              elem = getElem("object");
              elem.setAttribute("typemustmatch", true);
              elem.setAttribute("type", "application/pdf");
              elem.setAttribute("data", url);
            }
            cb(null, elem);
          });
        }
        function tryRenderIframe() {
          debug2('Unknown file extension "%s" - will attempt to render into iframe', extname2);
          let str = "";
          file.createReadStream({ start: 0, end: 1e3 }).setEncoding("utf8").on("data", (chunk) => {
            str += chunk;
          }).on("end", done2).on("error", cb);
          function done2() {
            if (isAscii(str)) {
              debug2('File extension "%s" appears ascii, so will render.', extname2);
              renderIframe();
            } else {
              debug2('File extension "%s" appears non-ascii, will not render.', extname2);
              cb(new Error(`Unsupported file type "${extname2}": Cannot append to DOM`));
            }
          }
        }
        function fatalError(err) {
          err.message = `Error rendering file "${file.name}": ${err.message}`;
          debug2(err.message);
          cb(err);
        }
      }
      function getBlobURL(file, cb) {
        const extname2 = path.extname(file.name).toLowerCase();
        streamToBlobURL(file.createReadStream(), exports.mime[extname2]).then((blobUrl) => cb(null, blobUrl), (err) => cb(err));
      }
      function validateFile(file) {
        if (file == null) {
          throw new Error("file cannot be null or undefined");
        }
        if (typeof file.name !== "string") {
          throw new Error("missing or invalid file.name property");
        }
        if (typeof file.createReadStream !== "function") {
          throw new Error("missing or invalid file.createReadStream property");
        }
      }
      function getCodec(name) {
        const extname2 = path.extname(name).toLowerCase();
        return {
          ".m4a": 'audio/mp4; codecs="mp4a.40.5"',
          ".m4b": 'audio/mp4; codecs="mp4a.40.5"',
          ".m4p": 'audio/mp4; codecs="mp4a.40.5"',
          ".m4v": 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
          ".mkv": 'video/webm; codecs="avc1.640029, mp4a.40.5"',
          ".mp3": "audio/mpeg",
          ".mp4": 'video/mp4; codecs="avc1.640029, mp4a.40.5"',
          ".webm": 'video/webm; codecs="vorbis, vp8"'
        }[extname2];
      }
      function parseOpts(opts) {
        if (opts.autoplay == null)
          opts.autoplay = false;
        if (opts.muted == null)
          opts.muted = false;
        if (opts.controls == null)
          opts.controls = true;
        if (opts.maxBlobLength == null)
          opts.maxBlobLength = MAX_BLOB_LENGTH;
      }
      function setMediaOpts(elem, opts) {
        elem.autoplay = !!opts.autoplay;
        elem.muted = !!opts.muted;
        elem.controls = !!opts.controls;
      }
    }
  });

  // node_modules/stream-with-known-length-to-buffer/index.js
  var require_stream_with_known_length_to_buffer = __commonJS({
    "node_modules/stream-with-known-length-to-buffer/index.js"(exports, module) {
      init_esbuild_inject();
      var once3 = require_once();
      module.exports = function getBuffer(stream, length, cb) {
        cb = once3(cb);
        var buf = Buffer3.alloc(length);
        var offset = 0;
        stream.on("data", function(chunk) {
          chunk.copy(buf, offset);
          offset += chunk.length;
        }).on("end", function() {
          cb(null, buf);
        }).on("error", cb);
      };
    }
  });

  // node_modules/range-parser/index.js
  var require_range_parser = __commonJS({
    "node_modules/range-parser/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = rangeParser;
      function rangeParser(size, str, options) {
        if (typeof str !== "string") {
          throw new TypeError("argument str must be a string");
        }
        var index = str.indexOf("=");
        if (index === -1) {
          return -2;
        }
        var arr = str.slice(index + 1).split(",");
        var ranges = [];
        ranges.type = str.slice(0, index);
        for (var i = 0; i < arr.length; i++) {
          var range = arr[i].split("-");
          var start = parseInt(range[0], 10);
          var end = parseInt(range[1], 10);
          if (isNaN(start)) {
            start = size - end;
            end = size - 1;
          } else if (isNaN(end)) {
            end = size - 1;
          }
          if (end > size - 1) {
            end = size - 1;
          }
          if (isNaN(start) || isNaN(end) || start > end || start < 0) {
            continue;
          }
          ranges.push({
            start,
            end
          });
        }
        if (ranges.length < 1) {
          return -1;
        }
        return options && options.combine ? combineRanges(ranges) : ranges;
      }
      function combineRanges(ranges) {
        var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
        for (var j = 0, i = 1; i < ordered.length; i++) {
          var range = ordered[i];
          var current = ordered[j];
          if (range.start > current.end + 1) {
            ordered[++j] = range;
          } else if (range.end > current.end) {
            current.end = range.end;
            current.index = Math.min(current.index, range.index);
          }
        }
        ordered.length = j + 1;
        var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
        combined.type = ranges.type;
        return combined;
      }
      function mapWithIndex(range, index) {
        return {
          start: range.start,
          end: range.end,
          index
        };
      }
      function mapWithoutIndex(range) {
        return {
          start: range.start,
          end: range.end
        };
      }
      function sortByRangeIndex(a, b) {
        return a.index - b.index;
      }
      function sortByRangeStart(a, b) {
        return a.start - b.start;
      }
    }
  });

  // node_modules/mime/Mime.js
  var require_Mime = __commonJS({
    "node_modules/mime/Mime.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function Mime() {
        this._types = /* @__PURE__ */ Object.create(null);
        this._extensions = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < arguments.length; i++) {
          this.define(arguments[i]);
        }
        this.define = this.define.bind(this);
        this.getType = this.getType.bind(this);
        this.getExtension = this.getExtension.bind(this);
      }
      Mime.prototype.define = function(typeMap, force) {
        for (let type2 in typeMap) {
          let extensions = typeMap[type2].map(function(t) {
            return t.toLowerCase();
          });
          type2 = type2.toLowerCase();
          for (let i = 0; i < extensions.length; i++) {
            const ext = extensions[i];
            if (ext[0] === "*") {
              continue;
            }
            if (!force && ext in this._types) {
              throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type2 + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type2 + '".');
            }
            this._types[ext] = type2;
          }
          if (force || !this._extensions[type2]) {
            const ext = extensions[0];
            this._extensions[type2] = ext[0] !== "*" ? ext : ext.substr(1);
          }
        }
      };
      Mime.prototype.getType = function(path) {
        path = String(path);
        let last = path.replace(/^.*[/\\]/, "").toLowerCase();
        let ext = last.replace(/^.*\./, "").toLowerCase();
        let hasPath = last.length < path.length;
        let hasDot = ext.length < last.length - 1;
        return (hasDot || !hasPath) && this._types[ext] || null;
      };
      Mime.prototype.getExtension = function(type2) {
        type2 = /^\s*([^;\s]*)/.test(type2) && RegExp.$1;
        return type2 && this._extensions[type2.toLowerCase()] || null;
      };
      module.exports = Mime;
    }
  });

  // node_modules/mime/types/standard.js
  var require_standard = __commonJS({
    "node_modules/mime/types/standard.js"(exports, module) {
      init_esbuild_inject();
      module.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    }
  });

  // node_modules/mime/types/other.js
  var require_other = __commonJS({
    "node_modules/mime/types/other.js"(exports, module) {
      init_esbuild_inject();
      module.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
    }
  });

  // node_modules/mime/index.js
  var require_mime2 = __commonJS({
    "node_modules/mime/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var Mime = require_Mime();
      module.exports = new Mime(require_standard(), require_other());
    }
  });

  // node_modules/webtorrent/lib/file-stream.js
  var require_file_stream = __commonJS({
    "node_modules/webtorrent/lib/file-stream.js"(exports, module) {
      init_esbuild_inject();
      var stream = require_stream();
      var debugFactory = require_browser5();
      var eos = require_end_of_stream8();
      var debug2 = debugFactory("webtorrent:file-stream");
      var FileStream = class extends stream.Readable {
        constructor(file, opts) {
          super(opts);
          this._torrent = file._torrent;
          const start = opts && opts.start || 0;
          const end = opts && opts.end && opts.end < file.length ? opts.end : file.length - 1;
          const pieceLength = file._torrent.pieceLength;
          this._startPiece = (start + file.offset) / pieceLength | 0;
          this._endPiece = (end + file.offset) / pieceLength | 0;
          this._piece = this._startPiece;
          this._offset = start + file.offset - this._startPiece * pieceLength;
          this._missing = end - start + 1;
          this._reading = false;
          this._notifying = false;
          this._criticalLength = Math.min(1024 * 1024 / pieceLength | 0, 2);
          this._torrent.select(this._startPiece, this._endPiece, true, () => {
            this._notify();
          });
          eos(this, (err) => {
            this.destroy(err);
          });
        }
        _read() {
          if (this._reading)
            return;
          this._reading = true;
          this._notify();
        }
        _notify() {
          if (!this._reading || this._missing === 0)
            return;
          if (!this._torrent.bitfield.get(this._piece)) {
            return this._torrent.critical(this._piece, this._piece + this._criticalLength);
          }
          if (this._notifying)
            return;
          this._notifying = true;
          if (this._torrent.destroyed)
            return this.destroy(new Error("Torrent removed"));
          const p = this._piece;
          const getOpts = {};
          if (p === this._torrent.pieces.length - 1) {
            getOpts.length = this._torrent.lastPieceLength;
          }
          this._torrent.store.get(p, getOpts, (err, buffer) => {
            this._notifying = false;
            if (this.destroyed)
              return;
            debug2("read %s (length %s) (err %s)", p, buffer && buffer.length, err && err.message);
            if (err)
              return this.destroy(err);
            if (this._offset) {
              buffer = buffer.slice(this._offset);
              this._offset = 0;
            }
            if (this._missing < buffer.length) {
              buffer = buffer.slice(0, this._missing);
            }
            this._missing -= buffer.length;
            debug2("pushing buffer of length %s", buffer.length);
            this._reading = false;
            this.push(buffer);
            if (this._missing === 0)
              this.push(null);
          });
          this._piece += 1;
        }
        _destroy(err, cb) {
          if (!this._torrent.destroyed) {
            this._torrent.deselect(this._startPiece, this._endPiece, true);
          }
          cb(err);
        }
      };
      module.exports = FileStream;
    }
  });

  // node_modules/webtorrent/lib/file.js
  var require_file = __commonJS({
    "node_modules/webtorrent/lib/file.js"(exports, module) {
      init_esbuild_inject();
      var EventEmitter2 = require_events();
      var { PassThrough: PassThrough2 } = require_stream();
      var path = require_path();
      var render = require_render_media();
      var streamToBlob = require_stream_to_blob();
      var streamToBlobURL = require_stream_to_blob_url();
      var streamToBuffer = require_stream_with_known_length_to_buffer();
      var queueMicrotask2 = require_queue_microtask();
      var rangeParser = require_range_parser();
      var mime = require_mime2();
      var eos = require_end_of_stream8();
      var FileStream = require_file_stream();
      var File2 = class extends EventEmitter2 {
        constructor(torrent, file) {
          super();
          this._torrent = torrent;
          this._destroyed = false;
          this._fileStreams = /* @__PURE__ */ new Set();
          this.name = file.name;
          this.path = file.path;
          this.length = file.length;
          this.offset = file.offset;
          this.done = false;
          const start = file.offset;
          const end = start + file.length - 1;
          this._startPiece = start / this._torrent.pieceLength | 0;
          this._endPiece = end / this._torrent.pieceLength | 0;
          if (this.length === 0) {
            this.done = true;
            this.emit("done");
          }
          this._serviceWorker = torrent.client.serviceWorker;
        }
        get downloaded() {
          if (this._destroyed || !this._torrent.bitfield)
            return 0;
          const { pieces, bitfield, pieceLength, lastPieceLength } = this._torrent;
          const { _startPiece: start, _endPiece: end } = this;
          const getPieceLength = (pieceIndex) => pieceIndex === pieces.length - 1 ? lastPieceLength : pieceLength;
          const getPieceDownloaded = (pieceIndex) => {
            const len = pieceIndex === pieces.length - 1 ? lastPieceLength : pieceLength;
            if (bitfield.get(pieceIndex)) {
              return len;
            } else {
              return len - pieces[pieceIndex].missing;
            }
          };
          let downloaded = 0;
          for (let index = start; index <= end; index += 1) {
            const pieceDownloaded = getPieceDownloaded(index);
            downloaded += pieceDownloaded;
            if (index === start) {
              const irrelevantFirstPieceBytes = this.offset % pieceLength;
              downloaded -= Math.min(irrelevantFirstPieceBytes, pieceDownloaded);
            }
            if (index === end) {
              const irrelevantLastPieceBytes = getPieceLength(end) - (this.offset + this.length) % pieceLength;
              downloaded -= Math.min(irrelevantLastPieceBytes, pieceDownloaded);
            }
          }
          return downloaded;
        }
        get progress() {
          return this.length ? this.downloaded / this.length : 0;
        }
        select(priority) {
          if (this.length === 0)
            return;
          this._torrent.select(this._startPiece, this._endPiece, priority);
        }
        deselect() {
          if (this.length === 0)
            return;
          this._torrent.deselect(this._startPiece, this._endPiece, false);
        }
        createReadStream(opts) {
          if (this.length === 0) {
            const empty = new PassThrough2();
            queueMicrotask2(() => {
              empty.end();
            });
            return empty;
          }
          const fileStream = new FileStream(this, opts);
          this._fileStreams.add(fileStream);
          fileStream.once("close", () => {
            this._fileStreams.delete(fileStream);
          });
          return fileStream;
        }
        getBuffer(cb) {
          streamToBuffer(this.createReadStream(), this.length, cb);
        }
        getBlob(cb) {
          if (typeof window === "undefined")
            throw new Error("browser-only method");
          streamToBlob(this.createReadStream(), this._getMimeType()).then((blob) => cb(null, blob), (err) => cb(err));
        }
        getBlobURL(cb) {
          if (typeof window === "undefined")
            throw new Error("browser-only method");
          streamToBlobURL(this.createReadStream(), this._getMimeType()).then((blobUrl) => cb(null, blobUrl), (err) => cb(err));
        }
        appendTo(elem, opts, cb) {
          if (typeof window === "undefined")
            throw new Error("browser-only method");
          render.append(this, elem, opts, cb);
        }
        renderTo(elem, opts, cb) {
          if (typeof window === "undefined")
            throw new Error("browser-only method");
          render.render(this, elem, opts, cb);
        }
        _serve(req) {
          const res = {
            status: 200,
            headers: {
              "Accept-Ranges": "bytes",
              "Content-Type": mime.getType(this.name),
              "Cache-Control": "no-cache, no-store, must-revalidate, max-age=0",
              Expires: "0"
            },
            body: req.method === "HEAD" ? "" : "STREAM"
          };
          if (req.destination === "document") {
            res.headers["Content-Type"] = "application/octet-stream";
            res.headers["Content-Disposition"] = "attachment";
            res.body = "DOWNLOAD";
          }
          let range = rangeParser(this.length, req.headers.range || "");
          if (range.constructor === Array) {
            res.status = 206;
            range = range[0];
            res.headers["Content-Range"] = `bytes ${range.start}-${range.end}/${this.length}`;
            res.headers["Content-Length"] = `${range.end - range.start + 1}`;
          } else {
            res.headers["Content-Length"] = this.length;
          }
          const stream = req.method === "GET" && this.createReadStream(range);
          let pipe = null;
          if (stream) {
            this.emit("stream", { stream, req, file: this }, (piped) => {
              pipe = piped;
              eos(piped, () => {
                if (piped)
                  piped.destroy();
                stream.destroy();
              });
            });
          }
          return [res, pipe || stream, pipe && stream];
        }
        getStreamURL(cb = () => {
        }) {
          if (typeof window === "undefined")
            throw new Error("browser-only method");
          if (!this._serviceWorker)
            throw new Error("No worker registered");
          if (this._serviceWorker.state !== "activated")
            throw new Error("Worker isn't activated");
          const workerPath = this._serviceWorker.scriptURL.slice(0, this._serviceWorker.scriptURL.lastIndexOf("/") + 1).slice(window.location.origin.length);
          const url = `${workerPath}webtorrent/${this._torrent.infoHash}/${encodeURI(this.path)}`;
          cb(null, url);
        }
        streamTo(elem, cb = () => {
        }) {
          if (typeof window === "undefined")
            throw new Error("browser-only method");
          if (!this._serviceWorker)
            throw new Error("No worker registered");
          if (this._serviceWorker.state !== "activated")
            throw new Error("Worker isn't activated");
          const workerPath = this._serviceWorker.scriptURL.slice(0, this._serviceWorker.scriptURL.lastIndexOf("/") + 1).slice(window.location.origin.length);
          elem.src = `${workerPath}webtorrent/${this._torrent.infoHash}/${encodeURI(this.path)}`;
          cb(null, elem);
        }
        _getMimeType() {
          return render.mime[path.extname(this.name).toLowerCase()];
        }
        _destroy() {
          this._destroyed = true;
          this._torrent = null;
          for (const fileStream of this._fileStreams) {
            fileStream.destroy();
          }
          this._fileStreams.clear();
        }
      };
      module.exports = File2;
    }
  });

  // node-modules-polyfills:crypto
  var crypto_exports = {};
  __export(crypto_exports, {
    default: () => crypto_default
  });
  var crypto_default;
  var init_crypto = __esm({
    "node-modules-polyfills:crypto"() {
      init_esbuild_inject();
      crypto_default = {};
    }
  });

  // node-modules-polyfills-commonjs:crypto
  var require_crypto = __commonJS({
    "node-modules-polyfills-commonjs:crypto"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_crypto(), __toCommonJS(crypto_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node_modules/speedometer/index.js
  var require_speedometer = __commonJS({
    "node_modules/speedometer/index.js"(exports, module) {
      init_esbuild_inject();
      var tick = 1;
      var maxTick = 65535;
      var resolution = 4;
      var timer;
      var inc = function() {
        tick = tick + 1 & maxTick;
      };
      module.exports = function(seconds) {
        if (!timer) {
          timer = setInterval(inc, 1e3 / resolution | 0);
          if (timer.unref)
            timer.unref();
        }
        var size = resolution * (seconds || 5);
        var buffer = [0];
        var pointer = 1;
        var last = tick - 1 & maxTick;
        return function(delta) {
          var dist = tick - last & maxTick;
          if (dist > size)
            dist = size;
          last = tick;
          while (dist--) {
            if (pointer === size)
              pointer = 0;
            buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
            pointer++;
          }
          if (delta)
            buffer[pointer - 1] += delta;
          var top = buffer[pointer - 1];
          var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
          return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
        };
      };
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/errors-browser.js
  var require_errors_browser11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser11().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser11();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy11();
      var _require = require_state11();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser11().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex11();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex11();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable11();
      var Writable2 = require_stream_writable11();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream12 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser11().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream12();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser11();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list11();
      var destroyImpl = require_destroy11();
      var _require = require_state11();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser11().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex11();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex11();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator11();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser11();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser11().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex11();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform11();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser11().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream12();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/bittorrent-protocol/node_modules/readable-stream/readable-browser.js
  var require_readable_browser11 = __commonJS({
    "node_modules/bittorrent-protocol/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable11();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable11();
      exports.Duplex = require_stream_duplex11();
      exports.Transform = require_stream_transform11();
      exports.PassThrough = require_stream_passthrough11();
      exports.finished = require_end_of_stream12();
      exports.pipeline = require_pipeline11();
    }
  });

  // node_modules/rc4/rc4.js
  var require_rc4 = __commonJS({
    "node_modules/rc4/rc4.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function isInteger(n) {
        return parseInt(n, 10) === n;
      }
      function createRC4(N) {
        function identityPermutation() {
          var s = new Array(N);
          for (var i = 0; i < N; i++) {
            s[i] = i;
          }
          return s;
        }
        function seed(key) {
          if (key === void 0) {
            key = new Array(N);
            for (var k = 0; k < N; k++) {
              key[k] = Math.floor(Math.random() * N);
            }
          } else if (typeof key === "string") {
            key = "" + key;
            key = key.split("").map(function(c) {
              return c.charCodeAt(0) % N;
            });
          } else if (Array.isArray(key)) {
            if (!key.every(function(v) {
              return typeof v === "number" && v === (v | 0);
            })) {
              throw new TypeError("invalid seed key specified: not array of integers");
            }
          } else {
            throw new TypeError("invalid seed key specified");
          }
          var keylen = key.length;
          var s = identityPermutation();
          var j = 0;
          for (var i = 0; i < N; i++) {
            j = (j + s[i] + key[i % keylen]) % N;
            var tmp = s[i];
            s[i] = s[j];
            s[j] = tmp;
          }
          return s;
        }
        function RC42(key) {
          this.s = seed(key);
          this.i = 0;
          this.j = 0;
        }
        RC42.prototype.randomNative = function() {
          this.i = (this.i + 1) % N;
          this.j = (this.j + this.s[this.i]) % N;
          var tmp = this.s[this.i];
          this.s[this.i] = this.s[this.j];
          this.s[this.j] = tmp;
          var k = this.s[(this.s[this.i] + this.s[this.j]) % N];
          return k;
        };
        RC42.prototype.randomUInt32 = function() {
          var a = this.randomByte();
          var b = this.randomByte();
          var c = this.randomByte();
          var d = this.randomByte();
          return ((a * 256 + b) * 256 + c) * 256 + d;
        };
        RC42.prototype.randomFloat = function() {
          return this.randomUInt32() / 4294967296;
        };
        RC42.prototype.random = function() {
          var a;
          var b;
          if (arguments.length === 1) {
            a = 0;
            b = arguments[0];
          } else if (arguments.length === 2) {
            a = arguments[0];
            b = arguments[1];
          } else {
            throw new TypeError("random takes one or two integer arguments");
          }
          if (!isInteger(a) || !isInteger(b)) {
            throw new TypeError("random takes one or two integer arguments");
          }
          return a + this.randomUInt32() % (b - a + 1);
        };
        RC42.prototype.currentState = function() {
          return {
            i: this.i,
            j: this.j,
            s: this.s.slice()
          };
        };
        RC42.prototype.setState = function(state) {
          var s = state.s;
          var i = state.i;
          var j = state.j;
          if (!(i === (i | 0) && 0 <= i && i < N)) {
            throw new Error("state.i should be integer [0, " + (N - 1) + "]");
          }
          if (!(j === (j | 0) && 0 <= j && j < N)) {
            throw new Error("state.j should be integer [0, " + (N - 1) + "]");
          }
          if (!Array.isArray(s) || s.length !== N) {
            throw new Error("state should be array of length " + N);
          }
          for (var k = 0; k < N; k++) {
            if (s.indexOf(k) === -1) {
              throw new Error("state should be permutation of 0.." + (N - 1) + ": " + k + " is missing");
            }
          }
          this.i = i;
          this.j = j;
          this.s = s.slice();
        };
        return RC42;
      }
      var RC4 = createRC4(256);
      RC4.prototype.randomByte = RC4.prototype.randomNative;
      var RC4small = createRC4(16);
      RC4small.prototype.randomByte = function() {
        var a = this.randomNative();
        var b = this.randomNative();
        return a * 16 + b;
      };
      var ordA = "a".charCodeAt(0);
      var ord0 = "0".charCodeAt(0);
      function toHex2(n) {
        return n < 10 ? String.fromCharCode(ord0 + n) : String.fromCharCode(ordA + n - 10);
      }
      function fromHex(c) {
        return parseInt(c, 16);
      }
      RC4small.prototype.currentStateString = function() {
        var state = this.currentState();
        var i = toHex2(state.i);
        var j = toHex2(state.j);
        var res = i + j + state.s.map(toHex2).join("");
        return res;
      };
      RC4small.prototype.setStateString = function(stateString) {
        if (!stateString.match(/^[0-9a-f]{18}$/)) {
          throw new TypeError("RC4small stateString should be 18 hex character string");
        }
        var i = fromHex(stateString[0]);
        var j = fromHex(stateString[1]);
        var s = stateString.split("").slice(2).map(fromHex);
        this.setState({
          i,
          j,
          s
        });
      };
      RC4.RC4small = RC4small;
      module.exports = RC4;
    }
  });

  // node_modules/bittorrent-protocol/index.js
  var require_bittorrent_protocol = __commonJS({
    "node_modules/bittorrent-protocol/index.js"(exports, module) {
      init_esbuild_inject();
      var arrayRemove = require_unordered_array_remove();
      var bencode = require_lib();
      var BitField = require_lib2().default;
      var crypto = require_crypto();
      var debug2 = require_browser5()("bittorrent-protocol");
      var randombytes = require_browser6();
      var sha1 = require_browser4();
      var speedometer = require_speedometer();
      var stream = require_readable_browser11();
      var RC4 = require_rc4();
      var BITFIELD_GROW = 4e5;
      var KEEP_ALIVE_TIMEOUT = 55e3;
      var ALLOWED_FAST_SET_MAX_LENGTH = 100;
      var MESSAGE_PROTOCOL = Buffer3.from("BitTorrent protocol");
      var MESSAGE_KEEP_ALIVE = Buffer3.from([0, 0, 0, 0]);
      var MESSAGE_CHOKE = Buffer3.from([0, 0, 0, 1, 0]);
      var MESSAGE_UNCHOKE = Buffer3.from([0, 0, 0, 1, 1]);
      var MESSAGE_INTERESTED = Buffer3.from([0, 0, 0, 1, 2]);
      var MESSAGE_UNINTERESTED = Buffer3.from([0, 0, 0, 1, 3]);
      var MESSAGE_RESERVED = [0, 0, 0, 0, 0, 0, 0, 0];
      var MESSAGE_PORT = [0, 0, 0, 3, 9, 0, 0];
      var MESSAGE_HAVE_ALL = Buffer3.from([0, 0, 0, 1, 14]);
      var MESSAGE_HAVE_NONE = Buffer3.from([0, 0, 0, 1, 15]);
      var DH_PRIME = "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a36210000000000090563";
      var DH_GENERATOR = 2;
      var VC = Buffer3.from([0, 0, 0, 0, 0, 0, 0, 0]);
      var CRYPTO_PROVIDE = Buffer3.from([0, 0, 1, 2]);
      var CRYPTO_SELECT = Buffer3.from([0, 0, 0, 2]);
      function xor(a, b) {
        for (let len = a.length; len--; )
          a[len] ^= b[len];
        return a;
      }
      var Request = class {
        constructor(piece, offset, length, callback) {
          this.piece = piece;
          this.offset = offset;
          this.length = length;
          this.callback = callback;
        }
      };
      var HaveAllBitField = class {
        constructor() {
          this.buffer = new Uint8Array();
        }
        get(index) {
          return true;
        }
        set(index) {
        }
      };
      var Wire = class extends stream.Duplex {
        constructor(type2 = null, retries = 0, peEnabled = false) {
          super();
          this._debugId = randombytes(4).toString("hex");
          this._debug("new wire");
          this.peerId = null;
          this.peerIdBuffer = null;
          this.type = type2;
          this.amChoking = true;
          this.amInterested = false;
          this.peerChoking = true;
          this.peerInterested = false;
          this.peerPieces = new BitField(0, { grow: BITFIELD_GROW });
          this.extensions = {};
          this.peerExtensions = {};
          this.requests = [];
          this.peerRequests = [];
          this.extendedMapping = {};
          this.peerExtendedMapping = {};
          this.extendedHandshake = {};
          this.peerExtendedHandshake = {};
          this.hasFast = false;
          this.allowedFastSet = [];
          this.peerAllowedFastSet = [];
          this._ext = {};
          this._nextExt = 1;
          this.uploaded = 0;
          this.downloaded = 0;
          this.uploadSpeed = speedometer();
          this.downloadSpeed = speedometer();
          this._keepAliveInterval = null;
          this._timeout = null;
          this._timeoutMs = 0;
          this._timeoutExpiresAt = null;
          this.destroyed = false;
          this._finished = false;
          this._parserSize = 0;
          this._parser = null;
          this._buffer = [];
          this._bufferSize = 0;
          this._peEnabled = peEnabled;
          if (peEnabled) {
            this._dh = crypto.createDiffieHellman(DH_PRIME, "hex", DH_GENERATOR);
            this._myPubKey = this._dh.generateKeys("hex");
          } else {
            this._myPubKey = null;
          }
          this._peerPubKey = null;
          this._sharedSecret = null;
          this._peerCryptoProvide = [];
          this._cryptoHandshakeDone = false;
          this._cryptoSyncPattern = null;
          this._waitMaxBytes = null;
          this._encryptionMethod = null;
          this._encryptGenerator = null;
          this._decryptGenerator = null;
          this._setGenerators = false;
          this.once("finish", () => this._onFinish());
          this.on("finish", this._onFinish);
          this._debug("type:", this.type);
          if (this.type === "tcpIncoming" && this._peEnabled) {
            this._determineHandshakeType();
          } else if (this.type === "tcpOutgoing" && this._peEnabled && retries === 0) {
            this._parsePe2();
          } else {
            this._parseHandshake(null);
          }
        }
        setKeepAlive(enable) {
          this._debug("setKeepAlive %s", enable);
          clearInterval(this._keepAliveInterval);
          if (enable === false)
            return;
          this._keepAliveInterval = setInterval(() => {
            this.keepAlive();
          }, KEEP_ALIVE_TIMEOUT);
        }
        setTimeout(ms, unref) {
          this._debug("setTimeout ms=%d unref=%s", ms, unref);
          this._timeoutMs = ms;
          this._timeoutUnref = !!unref;
          this._resetTimeout(true);
        }
        destroy() {
          if (this.destroyed)
            return;
          this.destroyed = true;
          this._debug("destroy");
          this.emit("close");
          this.end();
          return this;
        }
        end(...args) {
          this._debug("end");
          this._onUninterested();
          this._onChoke();
          return super.end(...args);
        }
        use(Extension) {
          const name = Extension.prototype.name;
          if (!name) {
            throw new Error('Extension class requires a "name" property on the prototype');
          }
          this._debug("use extension.name=%s", name);
          const ext = this._nextExt;
          const handler = new Extension(this);
          function noop2() {
          }
          if (typeof handler.onHandshake !== "function") {
            handler.onHandshake = noop2;
          }
          if (typeof handler.onExtendedHandshake !== "function") {
            handler.onExtendedHandshake = noop2;
          }
          if (typeof handler.onMessage !== "function") {
            handler.onMessage = noop2;
          }
          this.extendedMapping[ext] = name;
          this._ext[name] = handler;
          this[name] = handler;
          this._nextExt += 1;
        }
        keepAlive() {
          this._debug("keep-alive");
          this._push(MESSAGE_KEEP_ALIVE);
        }
        sendPe1() {
          if (this._peEnabled) {
            const padALen = Math.floor(Math.random() * 513);
            const padA = randombytes(padALen);
            this._push(Buffer3.concat([Buffer3.from(this._myPubKey, "hex"), padA]));
          }
        }
        sendPe2() {
          const padBLen = Math.floor(Math.random() * 513);
          const padB = randombytes(padBLen);
          this._push(Buffer3.concat([Buffer3.from(this._myPubKey, "hex"), padB]));
        }
        sendPe3(infoHash) {
          this.setEncrypt(this._sharedSecret, infoHash);
          const hash1Buffer = Buffer3.from(sha1.sync(Buffer3.from(this._utfToHex("req1") + this._sharedSecret, "hex")), "hex");
          const hash2Buffer = Buffer3.from(sha1.sync(Buffer3.from(this._utfToHex("req2") + infoHash, "hex")), "hex");
          const hash3Buffer = Buffer3.from(sha1.sync(Buffer3.from(this._utfToHex("req3") + this._sharedSecret, "hex")), "hex");
          const hashesXorBuffer = xor(hash2Buffer, hash3Buffer);
          const padCLen = randombytes(2).readUInt16BE(0) % 512;
          const padCBuffer = randombytes(padCLen);
          let vcAndProvideBuffer = Buffer3.alloc(8 + 4 + 2 + padCLen + 2);
          VC.copy(vcAndProvideBuffer);
          CRYPTO_PROVIDE.copy(vcAndProvideBuffer, 8);
          vcAndProvideBuffer.writeInt16BE(padCLen, 12);
          padCBuffer.copy(vcAndProvideBuffer, 14);
          vcAndProvideBuffer.writeInt16BE(0, 14 + padCLen);
          vcAndProvideBuffer = this._encryptHandshake(vcAndProvideBuffer);
          this._push(Buffer3.concat([hash1Buffer, hashesXorBuffer, vcAndProvideBuffer]));
        }
        sendPe4(infoHash) {
          this.setEncrypt(this._sharedSecret, infoHash);
          const padDLen = randombytes(2).readUInt16BE(0) % 512;
          const padDBuffer = randombytes(padDLen);
          let vcAndSelectBuffer = Buffer3.alloc(8 + 4 + 2 + padDLen);
          VC.copy(vcAndSelectBuffer);
          CRYPTO_SELECT.copy(vcAndSelectBuffer, 8);
          vcAndSelectBuffer.writeInt16BE(padDLen, 12);
          padDBuffer.copy(vcAndSelectBuffer, 14);
          vcAndSelectBuffer = this._encryptHandshake(vcAndSelectBuffer);
          this._push(vcAndSelectBuffer);
          this._cryptoHandshakeDone = true;
          this._debug("completed crypto handshake");
        }
        handshake(infoHash, peerId, extensions) {
          let infoHashBuffer;
          let peerIdBuffer;
          if (typeof infoHash === "string") {
            infoHash = infoHash.toLowerCase();
            infoHashBuffer = Buffer3.from(infoHash, "hex");
          } else {
            infoHashBuffer = infoHash;
            infoHash = infoHashBuffer.toString("hex");
          }
          if (typeof peerId === "string") {
            peerIdBuffer = Buffer3.from(peerId, "hex");
          } else {
            peerIdBuffer = peerId;
            peerId = peerIdBuffer.toString("hex");
          }
          this._infoHash = infoHashBuffer;
          if (infoHashBuffer.length !== 20 || peerIdBuffer.length !== 20) {
            throw new Error("infoHash and peerId MUST have length 20");
          }
          this._debug("handshake i=%s p=%s exts=%o", infoHash, peerId, extensions);
          const reserved = Buffer3.from(MESSAGE_RESERVED);
          this.extensions = {
            extended: true,
            dht: !!(extensions && extensions.dht),
            fast: !!(extensions && extensions.fast)
          };
          reserved[5] |= 16;
          if (this.extensions.dht)
            reserved[7] |= 1;
          if (this.extensions.fast)
            reserved[7] |= 4;
          if (this.extensions.fast && this.peerExtensions.fast) {
            this._debug("fast extension is enabled");
            this.hasFast = true;
          }
          this._push(Buffer3.concat([MESSAGE_PROTOCOL, reserved, infoHashBuffer, peerIdBuffer]));
          this._handshakeSent = true;
          if (this.peerExtensions.extended && !this._extendedHandshakeSent) {
            this._sendExtendedHandshake();
          }
        }
        _sendExtendedHandshake() {
          const msg = Object.assign({}, this.extendedHandshake);
          msg.m = {};
          for (const ext in this.extendedMapping) {
            const name = this.extendedMapping[ext];
            msg.m[name] = Number(ext);
          }
          this.extended(0, bencode.encode(msg));
          this._extendedHandshakeSent = true;
        }
        choke() {
          if (this.amChoking)
            return;
          this.amChoking = true;
          this._debug("choke");
          this._push(MESSAGE_CHOKE);
          if (this.hasFast) {
            let allowedCount = 0;
            while (this.peerRequests.length > allowedCount) {
              const request3 = this.peerRequests[allowedCount];
              if (this.allowedFastSet.includes(request3.piece)) {
                ++allowedCount;
              } else {
                this.reject(request3.piece, request3.offset, request3.length);
              }
            }
          } else {
            while (this.peerRequests.length) {
              this.peerRequests.pop();
            }
          }
        }
        unchoke() {
          if (!this.amChoking)
            return;
          this.amChoking = false;
          this._debug("unchoke");
          this._push(MESSAGE_UNCHOKE);
        }
        interested() {
          if (this.amInterested)
            return;
          this.amInterested = true;
          this._debug("interested");
          this._push(MESSAGE_INTERESTED);
        }
        uninterested() {
          if (!this.amInterested)
            return;
          this.amInterested = false;
          this._debug("uninterested");
          this._push(MESSAGE_UNINTERESTED);
        }
        have(index) {
          this._debug("have %d", index);
          this._message(4, [index], null);
        }
        bitfield(bitfield) {
          this._debug("bitfield");
          if (!Buffer3.isBuffer(bitfield))
            bitfield = bitfield.buffer;
          this._message(5, [], bitfield);
        }
        request(index, offset, length, cb) {
          if (!cb)
            cb = () => {
            };
          if (this._finished)
            return cb(new Error("wire is closed"));
          if (this.peerChoking && !(this.hasFast && this.peerAllowedFastSet.includes(index))) {
            return cb(new Error("peer is choking"));
          }
          this._debug("request index=%d offset=%d length=%d", index, offset, length);
          this.requests.push(new Request(index, offset, length, cb));
          if (!this._timeout) {
            this._resetTimeout(true);
          }
          this._message(6, [index, offset, length], null);
        }
        piece(index, offset, buffer) {
          this._debug("piece index=%d offset=%d", index, offset);
          this._message(7, [index, offset], buffer);
          this.uploaded += buffer.length;
          this.uploadSpeed(buffer.length);
          this.emit("upload", buffer.length);
        }
        cancel(index, offset, length) {
          this._debug("cancel index=%d offset=%d length=%d", index, offset, length);
          this._callback(this._pull(this.requests, index, offset, length), new Error("request was cancelled"), null);
          this._message(8, [index, offset, length], null);
        }
        port(port) {
          this._debug("port %d", port);
          const message = Buffer3.from(MESSAGE_PORT);
          message.writeUInt16BE(port, 5);
          this._push(message);
        }
        suggest(index) {
          if (!this.hasFast)
            throw Error("fast extension is disabled");
          this._debug("suggest %d", index);
          this._message(13, [index], null);
        }
        haveAll() {
          if (!this.hasFast)
            throw Error("fast extension is disabled");
          this._debug("have-all");
          this._push(MESSAGE_HAVE_ALL);
        }
        haveNone() {
          if (!this.hasFast)
            throw Error("fast extension is disabled");
          this._debug("have-none");
          this._push(MESSAGE_HAVE_NONE);
        }
        reject(index, offset, length) {
          if (!this.hasFast)
            throw Error("fast extension is disabled");
          this._debug("reject index=%d offset=%d length=%d", index, offset, length);
          this._pull(this.peerRequests, index, offset, length);
          this._message(16, [index, offset, length], null);
        }
        allowedFast(index) {
          if (!this.hasFast)
            throw Error("fast extension is disabled");
          this._debug("allowed-fast %d", index);
          if (!this.allowedFastSet.includes(index))
            this.allowedFastSet.push(index);
          this._message(17, [index], null);
        }
        extended(ext, obj) {
          this._debug("extended ext=%s", ext);
          if (typeof ext === "string" && this.peerExtendedMapping[ext]) {
            ext = this.peerExtendedMapping[ext];
          }
          if (typeof ext === "number") {
            const extId = Buffer3.from([ext]);
            const buf = Buffer3.isBuffer(obj) ? obj : bencode.encode(obj);
            this._message(20, [], Buffer3.concat([extId, buf]));
          } else {
            throw new Error(`Unrecognized extension: ${ext}`);
          }
        }
        setEncrypt(sharedSecret, infoHash) {
          let encryptKey;
          let decryptKey;
          let encryptKeyBuf;
          let encryptKeyIntArray;
          let decryptKeyBuf;
          let decryptKeyIntArray;
          switch (this.type) {
            case "tcpIncoming":
              encryptKey = sha1.sync(Buffer3.from(this._utfToHex("keyB") + sharedSecret + infoHash, "hex"));
              decryptKey = sha1.sync(Buffer3.from(this._utfToHex("keyA") + sharedSecret + infoHash, "hex"));
              encryptKeyBuf = Buffer3.from(encryptKey, "hex");
              encryptKeyIntArray = [];
              for (const value of encryptKeyBuf.values()) {
                encryptKeyIntArray.push(value);
              }
              decryptKeyBuf = Buffer3.from(decryptKey, "hex");
              decryptKeyIntArray = [];
              for (const value of decryptKeyBuf.values()) {
                decryptKeyIntArray.push(value);
              }
              this._encryptGenerator = new RC4(encryptKeyIntArray);
              this._decryptGenerator = new RC4(decryptKeyIntArray);
              break;
            case "tcpOutgoing":
              encryptKey = sha1.sync(Buffer3.from(this._utfToHex("keyA") + sharedSecret + infoHash, "hex"));
              decryptKey = sha1.sync(Buffer3.from(this._utfToHex("keyB") + sharedSecret + infoHash, "hex"));
              encryptKeyBuf = Buffer3.from(encryptKey, "hex");
              encryptKeyIntArray = [];
              for (const value of encryptKeyBuf.values()) {
                encryptKeyIntArray.push(value);
              }
              decryptKeyBuf = Buffer3.from(decryptKey, "hex");
              decryptKeyIntArray = [];
              for (const value of decryptKeyBuf.values()) {
                decryptKeyIntArray.push(value);
              }
              this._encryptGenerator = new RC4(encryptKeyIntArray);
              this._decryptGenerator = new RC4(decryptKeyIntArray);
              break;
            default:
              return false;
          }
          for (let i = 0; i < 1024; i++) {
            this._encryptGenerator.randomByte();
            this._decryptGenerator.randomByte();
          }
          this._setGenerators = true;
          return true;
        }
        _read() {
        }
        _message(id, numbers, data) {
          const dataLength = data ? data.length : 0;
          const buffer = Buffer3.allocUnsafe(5 + 4 * numbers.length);
          buffer.writeUInt32BE(buffer.length + dataLength - 4, 0);
          buffer[4] = id;
          for (let i = 0; i < numbers.length; i++) {
            buffer.writeUInt32BE(numbers[i], 5 + 4 * i);
          }
          this._push(buffer);
          if (data)
            this._push(data);
        }
        _push(data) {
          if (this._finished)
            return;
          if (this._encryptionMethod === 2 && this._cryptoHandshakeDone) {
            data = this._encrypt(data);
          }
          return this.push(data);
        }
        _onKeepAlive() {
          this._debug("got keep-alive");
          this.emit("keep-alive");
        }
        _onPe1(pubKeyBuffer) {
          this._peerPubKey = pubKeyBuffer.toString("hex");
          this._sharedSecret = this._dh.computeSecret(this._peerPubKey, "hex", "hex");
          this.emit("pe1");
        }
        _onPe2(pubKeyBuffer) {
          this._peerPubKey = pubKeyBuffer.toString("hex");
          this._sharedSecret = this._dh.computeSecret(this._peerPubKey, "hex", "hex");
          this.emit("pe2");
        }
        _onPe3(hashesXorBuffer) {
          const hash3 = sha1.sync(Buffer3.from(this._utfToHex("req3") + this._sharedSecret, "hex"));
          const sKeyHash = xor(Buffer3.from(hash3, "hex"), hashesXorBuffer).toString("hex");
          this.emit("pe3", sKeyHash);
        }
        _onPe3Encrypted(vcBuffer, peerProvideBuffer) {
          if (!vcBuffer.equals(VC)) {
            this._debug("Error: verification constant did not match");
            this.destroy();
            return;
          }
          for (const provideByte of peerProvideBuffer.values()) {
            if (provideByte !== 0) {
              this._peerCryptoProvide.push(provideByte);
            }
          }
          if (this._peerCryptoProvide.includes(2)) {
            this._encryptionMethod = 2;
          } else {
            this._debug("Error: RC4 encryption method not provided by peer");
            this.destroy();
          }
        }
        _onPe4(peerSelectBuffer) {
          this._encryptionMethod = peerSelectBuffer.readUInt8(3);
          if (!CRYPTO_PROVIDE.includes(this._encryptionMethod)) {
            this._debug("Error: peer selected invalid crypto method");
            this.destroy();
          }
          this._cryptoHandshakeDone = true;
          this._debug("crypto handshake done");
          this.emit("pe4");
        }
        _onHandshake(infoHashBuffer, peerIdBuffer, extensions) {
          const infoHash = infoHashBuffer.toString("hex");
          const peerId = peerIdBuffer.toString("hex");
          this._debug("got handshake i=%s p=%s exts=%o", infoHash, peerId, extensions);
          this.peerId = peerId;
          this.peerIdBuffer = peerIdBuffer;
          this.peerExtensions = extensions;
          if (this.extensions.fast && this.peerExtensions.fast) {
            this._debug("fast extension is enabled");
            this.hasFast = true;
          }
          this.emit("handshake", infoHash, peerId, extensions);
          for (const name in this._ext) {
            this._ext[name].onHandshake(infoHash, peerId, extensions);
          }
          if (extensions.extended && this._handshakeSent && !this._extendedHandshakeSent) {
            this._sendExtendedHandshake();
          }
        }
        _onChoke() {
          this.peerChoking = true;
          this._debug("got choke");
          this.emit("choke");
          if (!this.hasFast) {
            while (this.requests.length) {
              this._callback(this.requests.pop(), new Error("peer is choking"), null);
            }
          }
        }
        _onUnchoke() {
          this.peerChoking = false;
          this._debug("got unchoke");
          this.emit("unchoke");
        }
        _onInterested() {
          this.peerInterested = true;
          this._debug("got interested");
          this.emit("interested");
        }
        _onUninterested() {
          this.peerInterested = false;
          this._debug("got uninterested");
          this.emit("uninterested");
        }
        _onHave(index) {
          if (this.peerPieces.get(index))
            return;
          this._debug("got have %d", index);
          this.peerPieces.set(index, true);
          this.emit("have", index);
        }
        _onBitField(buffer) {
          this.peerPieces = new BitField(buffer);
          this._debug("got bitfield");
          this.emit("bitfield", this.peerPieces);
        }
        _onRequest(index, offset, length) {
          if (this.amChoking && !(this.hasFast && this.allowedFastSet.includes(index))) {
            if (this.hasFast)
              this.reject(index, offset, length);
            return;
          }
          this._debug("got request index=%d offset=%d length=%d", index, offset, length);
          const respond = (err, buffer) => {
            if (request3 !== this._pull(this.peerRequests, index, offset, length))
              return;
            if (err) {
              this._debug("error satisfying request index=%d offset=%d length=%d (%s)", index, offset, length, err.message);
              if (this.hasFast)
                this.reject(index, offset, length);
              return;
            }
            this.piece(index, offset, buffer);
          };
          const request3 = new Request(index, offset, length, respond);
          this.peerRequests.push(request3);
          this.emit("request", index, offset, length, respond);
        }
        _onPiece(index, offset, buffer) {
          this._debug("got piece index=%d offset=%d", index, offset);
          this._callback(this._pull(this.requests, index, offset, buffer.length), null, buffer);
          this.downloaded += buffer.length;
          this.downloadSpeed(buffer.length);
          this.emit("download", buffer.length);
          this.emit("piece", index, offset, buffer);
        }
        _onCancel(index, offset, length) {
          this._debug("got cancel index=%d offset=%d length=%d", index, offset, length);
          this._pull(this.peerRequests, index, offset, length);
          this.emit("cancel", index, offset, length);
        }
        _onPort(port) {
          this._debug("got port %d", port);
          this.emit("port", port);
        }
        _onSuggest(index) {
          if (!this.hasFast) {
            this._debug("Error: got suggest whereas fast extension is disabled");
            this.destroy();
            return;
          }
          this._debug("got suggest %d", index);
          this.emit("suggest", index);
        }
        _onHaveAll() {
          if (!this.hasFast) {
            this._debug("Error: got have-all whereas fast extension is disabled");
            this.destroy();
            return;
          }
          this._debug("got have-all");
          this.peerPieces = new HaveAllBitField();
          this.emit("have-all");
        }
        _onHaveNone() {
          if (!this.hasFast) {
            this._debug("Error: got have-none whereas fast extension is disabled");
            this.destroy();
            return;
          }
          this._debug("got have-none");
          this.emit("have-none");
        }
        _onReject(index, offset, length) {
          if (!this.hasFast) {
            this._debug("Error: got reject whereas fast extension is disabled");
            this.destroy();
            return;
          }
          this._debug("got reject index=%d offset=%d length=%d", index, offset, length);
          this._callback(this._pull(this.requests, index, offset, length), new Error("request was rejected"), null);
          this.emit("reject", index, offset, length);
        }
        _onAllowedFast(index) {
          if (!this.hasFast) {
            this._debug("Error: got allowed-fast whereas fast extension is disabled");
            this.destroy();
            return;
          }
          this._debug("got allowed-fast %d", index);
          if (!this.peerAllowedFastSet.includes(index))
            this.peerAllowedFastSet.push(index);
          if (this.peerAllowedFastSet.length > ALLOWED_FAST_SET_MAX_LENGTH)
            this.peerAllowedFastSet.shift();
          this.emit("allowed-fast", index);
        }
        _onExtended(ext, buf) {
          if (ext === 0) {
            let info;
            try {
              info = bencode.decode(buf);
            } catch (err) {
              this._debug("ignoring invalid extended handshake: %s", err.message || err);
            }
            if (!info)
              return;
            this.peerExtendedHandshake = info;
            if (typeof info.m === "object") {
              for (const name in info.m) {
                this.peerExtendedMapping[name] = Number(info.m[name].toString());
              }
            }
            for (const name in this._ext) {
              if (this.peerExtendedMapping[name]) {
                this._ext[name].onExtendedHandshake(this.peerExtendedHandshake);
              }
            }
            this._debug("got extended handshake");
            this.emit("extended", "handshake", this.peerExtendedHandshake);
          } else {
            if (this.extendedMapping[ext]) {
              ext = this.extendedMapping[ext];
              if (this._ext[ext]) {
                this._ext[ext].onMessage(buf);
              }
            }
            this._debug("got extended message ext=%s", ext);
            this.emit("extended", ext, buf);
          }
        }
        _onTimeout() {
          this._debug("request timed out");
          this._callback(this.requests.shift(), new Error("request has timed out"), null);
          this.emit("timeout");
        }
        _write(data, encoding, cb) {
          if (this._encryptionMethod === 2 && this._cryptoHandshakeDone) {
            data = this._decrypt(data);
          }
          this._bufferSize += data.length;
          this._buffer.push(data);
          if (this._buffer.length > 1) {
            this._buffer = [Buffer3.concat(this._buffer, this._bufferSize)];
          }
          if (this._cryptoSyncPattern) {
            const index = this._buffer[0].indexOf(this._cryptoSyncPattern);
            if (index !== -1) {
              this._buffer[0] = this._buffer[0].slice(index + this._cryptoSyncPattern.length);
              this._bufferSize -= index + this._cryptoSyncPattern.length;
              this._cryptoSyncPattern = null;
            } else if (this._bufferSize + data.length > this._waitMaxBytes + this._cryptoSyncPattern.length) {
              this._debug("Error: could not resynchronize");
              this.destroy();
              return;
            }
          }
          while (this._bufferSize >= this._parserSize && !this._cryptoSyncPattern) {
            if (this._parserSize === 0) {
              this._parser(Buffer3.from([]));
            } else {
              const buffer = this._buffer[0];
              this._bufferSize -= this._parserSize;
              this._buffer = this._bufferSize ? [buffer.slice(this._parserSize)] : [];
              this._parser(buffer.slice(0, this._parserSize));
            }
          }
          cb(null);
        }
        _callback(request3, err, buffer) {
          if (!request3)
            return;
          this._resetTimeout(!this.peerChoking && !this._finished);
          request3.callback(err, buffer);
        }
        _resetTimeout(setAgain) {
          if (!setAgain || !this._timeoutMs || !this.requests.length) {
            clearTimeout(this._timeout);
            this._timeout = null;
            this._timeoutExpiresAt = null;
            return;
          }
          const timeoutExpiresAt = Date.now() + this._timeoutMs;
          if (this._timeout) {
            if (timeoutExpiresAt - this._timeoutExpiresAt < this._timeoutMs * 0.05) {
              return;
            }
            clearTimeout(this._timeout);
          }
          this._timeoutExpiresAt = timeoutExpiresAt;
          this._timeout = setTimeout(() => this._onTimeout(), this._timeoutMs);
          if (this._timeoutUnref && this._timeout.unref)
            this._timeout.unref();
        }
        _parse(size, parser) {
          this._parserSize = size;
          this._parser = parser;
        }
        _parseUntil(pattern, maxBytes) {
          this._cryptoSyncPattern = pattern;
          this._waitMaxBytes = maxBytes;
        }
        _onMessageLength(buffer) {
          const length = buffer.readUInt32BE(0);
          if (length > 0) {
            this._parse(length, this._onMessage);
          } else {
            this._onKeepAlive();
            this._parse(4, this._onMessageLength);
          }
        }
        _onMessage(buffer) {
          this._parse(4, this._onMessageLength);
          switch (buffer[0]) {
            case 0:
              return this._onChoke();
            case 1:
              return this._onUnchoke();
            case 2:
              return this._onInterested();
            case 3:
              return this._onUninterested();
            case 4:
              return this._onHave(buffer.readUInt32BE(1));
            case 5:
              return this._onBitField(buffer.slice(1));
            case 6:
              return this._onRequest(buffer.readUInt32BE(1), buffer.readUInt32BE(5), buffer.readUInt32BE(9));
            case 7:
              return this._onPiece(buffer.readUInt32BE(1), buffer.readUInt32BE(5), buffer.slice(9));
            case 8:
              return this._onCancel(buffer.readUInt32BE(1), buffer.readUInt32BE(5), buffer.readUInt32BE(9));
            case 9:
              return this._onPort(buffer.readUInt16BE(1));
            case 13:
              return this._onSuggest(buffer.readUInt32BE(1));
            case 14:
              return this._onHaveAll();
            case 15:
              return this._onHaveNone();
            case 16:
              return this._onReject(buffer.readUInt32BE(1), buffer.readUInt32BE(5), buffer.readUInt32BE(9));
            case 17:
              return this._onAllowedFast(buffer.readUInt32BE(1));
            case 20:
              return this._onExtended(buffer.readUInt8(1), buffer.slice(2));
            default:
              this._debug("got unknown message");
              return this.emit("unknownmessage", buffer);
          }
        }
        _determineHandshakeType() {
          this._parse(1, (pstrLenBuffer) => {
            const pstrlen = pstrLenBuffer.readUInt8(0);
            if (pstrlen === 19) {
              this._parse(pstrlen + 48, this._onHandshakeBuffer);
            } else {
              this._parsePe1(pstrLenBuffer);
            }
          });
        }
        _parsePe1(pubKeyPrefix) {
          this._parse(95, (pubKeySuffix) => {
            this._onPe1(Buffer3.concat([pubKeyPrefix, pubKeySuffix]));
            this._parsePe3();
          });
        }
        _parsePe2() {
          this._parse(96, (pubKey) => {
            this._onPe2(pubKey);
            while (!this._setGenerators) {
            }
            this._parsePe4();
          });
        }
        _parsePe3() {
          const hash1Buffer = Buffer3.from(sha1.sync(Buffer3.from(this._utfToHex("req1") + this._sharedSecret, "hex")), "hex");
          this._parseUntil(hash1Buffer, 512);
          this._parse(20, (buffer) => {
            this._onPe3(buffer);
            while (!this._setGenerators) {
            }
            this._parsePe3Encrypted();
          });
        }
        _parsePe3Encrypted() {
          this._parse(14, (buffer) => {
            const vcBuffer = this._decryptHandshake(buffer.slice(0, 8));
            const peerProvideBuffer = this._decryptHandshake(buffer.slice(8, 12));
            const padCLen = this._decryptHandshake(buffer.slice(12, 14)).readUInt16BE(0);
            this._parse(padCLen, (padCBuffer) => {
              padCBuffer = this._decryptHandshake(padCBuffer);
              this._parse(2, (iaLenBuf) => {
                const iaLen = this._decryptHandshake(iaLenBuf).readUInt16BE(0);
                this._parse(iaLen, (iaBuffer) => {
                  iaBuffer = this._decryptHandshake(iaBuffer);
                  this._onPe3Encrypted(vcBuffer, peerProvideBuffer, padCBuffer, iaBuffer);
                  const pstrlen = iaLen ? iaBuffer.readUInt8(0) : null;
                  const protocol = iaLen ? iaBuffer.slice(1, 20) : null;
                  if (pstrlen === 19 && protocol.toString() === "BitTorrent protocol") {
                    this._onHandshakeBuffer(iaBuffer.slice(1));
                  } else {
                    this._parseHandshake();
                  }
                });
              });
            });
          });
        }
        _parsePe4() {
          const vcBufferEncrypted = this._decryptHandshake(VC);
          this._parseUntil(vcBufferEncrypted, 512);
          this._parse(6, (buffer) => {
            const peerSelectBuffer = this._decryptHandshake(buffer.slice(0, 4));
            const padDLen = this._decryptHandshake(buffer.slice(4, 6)).readUInt16BE(0);
            this._parse(padDLen, (padDBuf) => {
              this._decryptHandshake(padDBuf);
              this._onPe4(peerSelectBuffer);
              this._parseHandshake(null);
            });
          });
        }
        _parseHandshake() {
          this._parse(1, (buffer) => {
            const pstrlen = buffer.readUInt8(0);
            if (pstrlen !== 19) {
              this._debug("Error: wire not speaking BitTorrent protocol (%s)", pstrlen.toString());
              this.end();
              return;
            }
            this._parse(pstrlen + 48, this._onHandshakeBuffer);
          });
        }
        _onHandshakeBuffer(handshake) {
          const protocol = handshake.slice(0, 19);
          if (protocol.toString() !== "BitTorrent protocol") {
            this._debug("Error: wire not speaking BitTorrent protocol (%s)", protocol.toString());
            this.end();
            return;
          }
          handshake = handshake.slice(19);
          this._onHandshake(handshake.slice(8, 28), handshake.slice(28, 48), {
            dht: !!(handshake[7] & 1),
            fast: !!(handshake[7] & 4),
            extended: !!(handshake[5] & 16)
          });
          this._parse(4, this._onMessageLength);
        }
        _onFinish() {
          this._finished = true;
          this.push(null);
          while (this.read()) {
          }
          clearInterval(this._keepAliveInterval);
          this._parse(Number.MAX_VALUE, () => {
          });
          while (this.peerRequests.length) {
            this.peerRequests.pop();
          }
          while (this.requests.length) {
            this._callback(this.requests.pop(), new Error("wire was closed"), null);
          }
        }
        _debug(...args) {
          args[0] = `[${this._debugId}] ${args[0]}`;
          debug2(...args);
        }
        _pull(requests, piece, offset, length) {
          for (let i = 0; i < requests.length; i++) {
            const req = requests[i];
            if (req.piece === piece && req.offset === offset && req.length === length) {
              arrayRemove(requests, i);
              return req;
            }
          }
          return null;
        }
        _encryptHandshake(buf) {
          const crypt = Buffer3.from(buf);
          if (!this._encryptGenerator) {
            this._debug("Warning: Encrypting without any generator");
            return crypt;
          }
          for (let i = 0; i < buf.length; i++) {
            const keystream = this._encryptGenerator.randomByte();
            crypt[i] = crypt[i] ^ keystream;
          }
          return crypt;
        }
        _encrypt(buf) {
          const crypt = Buffer3.from(buf);
          if (!this._encryptGenerator || this._encryptionMethod !== 2) {
            return crypt;
          }
          for (let i = 0; i < buf.length; i++) {
            const keystream = this._encryptGenerator.randomByte();
            crypt[i] = crypt[i] ^ keystream;
          }
          return crypt;
        }
        _decryptHandshake(buf) {
          const decrypt = Buffer3.from(buf);
          if (!this._decryptGenerator) {
            this._debug("Warning: Decrypting without any generator");
            return decrypt;
          }
          for (let i = 0; i < buf.length; i++) {
            const keystream = this._decryptGenerator.randomByte();
            decrypt[i] = decrypt[i] ^ keystream;
          }
          return decrypt;
        }
        _decrypt(buf) {
          const decrypt = Buffer3.from(buf);
          if (!this._decryptGenerator || this._encryptionMethod !== 2) {
            return decrypt;
          }
          for (let i = 0; i < buf.length; i++) {
            const keystream = this._decryptGenerator.randomByte();
            decrypt[i] = decrypt[i] ^ keystream;
          }
          return decrypt;
        }
        _utfToHex(str) {
          return Buffer3.from(str, "utf8").toString("hex");
        }
      };
      module.exports = Wire;
    }
  });

  // node_modules/webtorrent/lib/peer.js
  var require_peer = __commonJS({
    "node_modules/webtorrent/lib/peer.js"(exports) {
      init_esbuild_inject();
      var EventEmitter2 = require_events();
      var { Transform: Transform2 } = require_stream();
      var arrayRemove = require_unordered_array_remove();
      var debugFactory = require_browser5();
      var Wire = require_bittorrent_protocol();
      var CONNECT_TIMEOUT_TCP = 5e3;
      var CONNECT_TIMEOUT_UTP = 5e3;
      var CONNECT_TIMEOUT_WEBRTC = 25e3;
      var HANDSHAKE_TIMEOUT = 25e3;
      var debug2 = debugFactory("webtorrent:peer");
      var secure = false;
      exports.enableSecure = () => {
        secure = true;
      };
      exports.createWebRTCPeer = (conn, swarm, throttleGroups) => {
        const peer = new Peer(conn.id, "webrtc");
        peer.conn = conn;
        peer.swarm = swarm;
        peer.throttleGroups = throttleGroups;
        if (peer.conn.connected) {
          peer.onConnect();
        } else {
          const cleanup = () => {
            peer.conn.removeListener("connect", onConnect);
            peer.conn.removeListener("error", onError);
          };
          const onConnect = () => {
            cleanup();
            peer.onConnect();
          };
          const onError = (err) => {
            cleanup();
            peer.destroy(err);
          };
          peer.conn.once("connect", onConnect);
          peer.conn.once("error", onError);
          peer.startConnectTimeout();
        }
        return peer;
      };
      exports.createTCPIncomingPeer = (conn, throttleGroups) => {
        return _createIncomingPeer(conn, "tcpIncoming", throttleGroups);
      };
      exports.createUTPIncomingPeer = (conn, throttleGroups) => {
        return _createIncomingPeer(conn, "utpIncoming", throttleGroups);
      };
      exports.createTCPOutgoingPeer = (addr, swarm, throttleGroups) => {
        return _createOutgoingPeer(addr, swarm, "tcpOutgoing", throttleGroups);
      };
      exports.createUTPOutgoingPeer = (addr, swarm, throttleGroups) => {
        return _createOutgoingPeer(addr, swarm, "utpOutgoing", throttleGroups);
      };
      var _createIncomingPeer = (conn, type2, throttleGroups) => {
        const addr = `${conn.remoteAddress}:${conn.remotePort}`;
        const peer = new Peer(addr, type2);
        peer.conn = conn;
        peer.addr = addr;
        peer.throttleGroups = throttleGroups;
        peer.onConnect();
        return peer;
      };
      var _createOutgoingPeer = (addr, swarm, type2, throttleGroups) => {
        const peer = new Peer(addr, type2);
        peer.addr = addr;
        peer.swarm = swarm;
        peer.throttleGroups = throttleGroups;
        return peer;
      };
      exports.createWebSeedPeer = (conn, id, swarm, throttleGroups) => {
        const peer = new Peer(id, "webSeed");
        peer.swarm = swarm;
        peer.conn = conn;
        peer.throttleGroups = throttleGroups;
        peer.onConnect();
        return peer;
      };
      var Peer = class extends EventEmitter2 {
        constructor(id, type2) {
          super();
          this.id = id;
          this.type = type2;
          debug2("new %s Peer %s", type2, id);
          this.addr = null;
          this.conn = null;
          this.swarm = null;
          this.wire = null;
          this.connected = false;
          this.destroyed = false;
          this.timeout = null;
          this.retries = 0;
          this.sentPe1 = false;
          this.sentPe2 = false;
          this.sentPe3 = false;
          this.sentPe4 = false;
          this.sentHandshake = false;
        }
        onConnect() {
          if (this.destroyed)
            return;
          this.connected = true;
          debug2("Peer %s connected", this.id);
          clearTimeout(this.connectTimeout);
          const conn = this.conn;
          conn.once("end", () => {
            this.destroy();
          });
          conn.once("close", () => {
            this.destroy();
          });
          conn.once("finish", () => {
            this.destroy();
          });
          conn.once("error", (err) => {
            this.destroy(err);
          });
          const wire = this.wire = new Wire(this.type, this.retries, secure);
          wire.once("end", () => {
            this.destroy();
          });
          wire.once("close", () => {
            this.destroy();
          });
          wire.once("finish", () => {
            this.destroy();
          });
          wire.once("error", (err) => {
            this.destroy(err);
          });
          wire.once("pe1", () => {
            this.onPe1();
          });
          wire.once("pe2", () => {
            this.onPe2();
          });
          wire.once("pe3", () => {
            this.onPe3();
          });
          wire.once("pe4", () => {
            this.onPe4();
          });
          wire.once("handshake", (infoHash, peerId) => {
            this.onHandshake(infoHash, peerId);
          });
          this.startHandshakeTimeout();
          this.setThrottlePipes();
          if (this.swarm) {
            if (this.type === "tcpOutgoing") {
              if (secure && this.retries === 0 && !this.sentPe1)
                this.sendPe1();
              else if (!this.sentHandshake)
                this.handshake();
            } else if (this.type !== "tcpIncoming" && !this.sentHandshake)
              this.handshake();
          }
        }
        sendPe1() {
          this.wire.sendPe1();
          this.sentPe1 = true;
        }
        onPe1() {
          this.sendPe2();
        }
        sendPe2() {
          this.wire.sendPe2();
          this.sentPe2 = true;
        }
        onPe2() {
          this.sendPe3();
        }
        sendPe3() {
          this.wire.sendPe3(this.swarm.infoHash);
          this.sentPe3 = true;
        }
        onPe3(infoHashHash) {
          if (this.swarm) {
            if (this.swarm.infoHashHash !== infoHashHash) {
              this.destroy(new Error("unexpected crypto handshake info hash for this swarm"));
            }
            this.sendPe4();
          }
        }
        sendPe4() {
          this.wire.sendPe4(this.swarm.infoHash);
          this.sentPe4 = true;
        }
        onPe4() {
          if (!this.sentHandshake)
            this.handshake();
        }
        clearPipes() {
          this.conn.unpipe();
          this.wire.unpipe();
        }
        setThrottlePipes() {
          const self2 = this;
          this.conn.pipe(this.throttleGroups.down.throttle()).pipe(new Transform2({
            transform(chunk, _, callback) {
              self2.emit("download", chunk.length);
              if (self2.destroyed)
                return;
              callback(null, chunk);
            }
          })).pipe(this.wire).pipe(this.throttleGroups.up.throttle()).pipe(new Transform2({
            transform(chunk, _, callback) {
              self2.emit("upload", chunk.length);
              if (self2.destroyed)
                return;
              callback(null, chunk);
            }
          })).pipe(this.conn);
        }
        onHandshake(infoHash, peerId) {
          if (!this.swarm)
            return;
          if (this.destroyed)
            return;
          if (this.swarm.destroyed) {
            return this.destroy(new Error("swarm already destroyed"));
          }
          if (infoHash !== this.swarm.infoHash) {
            return this.destroy(new Error("unexpected handshake info hash for this swarm"));
          }
          if (peerId === this.swarm.peerId) {
            return this.destroy(new Error("refusing to connect to ourselves"));
          }
          debug2("Peer %s got handshake %s", this.id, infoHash);
          clearTimeout(this.handshakeTimeout);
          this.retries = 0;
          let addr = this.addr;
          if (!addr && this.conn.remoteAddress && this.conn.remotePort) {
            addr = `${this.conn.remoteAddress}:${this.conn.remotePort}`;
          }
          this.swarm._onWire(this.wire, addr);
          if (!this.swarm || this.swarm.destroyed)
            return;
          if (!this.sentHandshake)
            this.handshake();
        }
        handshake() {
          const opts = {
            dht: this.swarm.private ? false : !!this.swarm.client.dht,
            fast: true
          };
          this.wire.handshake(this.swarm.infoHash, this.swarm.client.peerId, opts);
          this.sentHandshake = true;
        }
        startConnectTimeout() {
          clearTimeout(this.connectTimeout);
          const connectTimeoutValues = {
            webrtc: CONNECT_TIMEOUT_WEBRTC,
            tcpOutgoing: CONNECT_TIMEOUT_TCP,
            utpOutgoing: CONNECT_TIMEOUT_UTP
          };
          this.connectTimeout = setTimeout(() => {
            this.destroy(new Error("connect timeout"));
          }, connectTimeoutValues[this.type]);
          if (this.connectTimeout.unref)
            this.connectTimeout.unref();
        }
        startHandshakeTimeout() {
          clearTimeout(this.handshakeTimeout);
          this.handshakeTimeout = setTimeout(() => {
            this.destroy(new Error("handshake timeout"));
          }, HANDSHAKE_TIMEOUT);
          if (this.handshakeTimeout.unref)
            this.handshakeTimeout.unref();
        }
        destroy(err) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          this.connected = false;
          debug2("destroy %s %s (error: %s)", this.type, this.id, err && (err.message || err));
          clearTimeout(this.connectTimeout);
          clearTimeout(this.handshakeTimeout);
          const swarm = this.swarm;
          const conn = this.conn;
          const wire = this.wire;
          this.swarm = null;
          this.conn = null;
          this.wire = null;
          if (swarm && wire) {
            arrayRemove(swarm.wires, swarm.wires.indexOf(wire));
          }
          if (conn) {
            conn.on("error", () => {
            });
            conn.destroy();
          }
          if (wire)
            wire.destroy();
          if (swarm)
            swarm.removePeer(this.id);
        }
      };
    }
  });

  // node_modules/webtorrent/lib/rarity-map.js
  var require_rarity_map = __commonJS({
    "node_modules/webtorrent/lib/rarity-map.js"(exports, module) {
      init_esbuild_inject();
      var RarityMap = class {
        constructor(torrent) {
          this._torrent = torrent;
          this._numPieces = torrent.pieces.length;
          this._pieces = new Array(this._numPieces);
          this._onWire = (wire) => {
            this.recalculate();
            this._initWire(wire);
          };
          this._onWireHave = (index) => {
            this._pieces[index] += 1;
          };
          this._onWireBitfield = () => {
            this.recalculate();
          };
          this._torrent.wires.forEach((wire) => {
            this._initWire(wire);
          });
          this._torrent.on("wire", this._onWire);
          this.recalculate();
        }
        getRarestPiece(pieceFilterFunc) {
          let candidates = [];
          let min = Infinity;
          for (let i = 0; i < this._numPieces; ++i) {
            if (pieceFilterFunc && !pieceFilterFunc(i))
              continue;
            const availability = this._pieces[i];
            if (availability === min) {
              candidates.push(i);
            } else if (availability < min) {
              candidates = [i];
              min = availability;
            }
          }
          if (candidates.length) {
            return candidates[Math.random() * candidates.length | 0];
          } else {
            return -1;
          }
        }
        destroy() {
          this._torrent.removeListener("wire", this._onWire);
          this._torrent.wires.forEach((wire) => {
            this._cleanupWireEvents(wire);
          });
          this._torrent = null;
          this._pieces = null;
          this._onWire = null;
          this._onWireHave = null;
          this._onWireBitfield = null;
        }
        _initWire(wire) {
          wire._onClose = () => {
            this._cleanupWireEvents(wire);
            for (let i = 0; i < this._numPieces; ++i) {
              this._pieces[i] -= wire.peerPieces.get(i);
            }
          };
          wire.on("have", this._onWireHave);
          wire.on("bitfield", this._onWireBitfield);
          wire.once("close", wire._onClose);
        }
        recalculate() {
          this._pieces.fill(0);
          for (const wire of this._torrent.wires) {
            for (let i = 0; i < this._numPieces; ++i) {
              this._pieces[i] += wire.peerPieces.get(i);
            }
          }
        }
        _cleanupWireEvents(wire) {
          wire.removeListener("have", this._onWireHave);
          wire.removeListener("bitfield", this._onWireBitfield);
          if (wire._onClose)
            wire.removeListener("close", wire._onClose);
          wire._onClose = null;
        }
      };
      module.exports = RarityMap;
    }
  });

  // (disabled):node_modules/webtorrent/lib/server.js
  var require_server = __commonJS({
    "(disabled):node_modules/webtorrent/lib/server.js"() {
      init_esbuild_inject();
    }
  });

  // (disabled):node_modules/webtorrent/lib/utp.js
  var require_utp = __commonJS({
    "(disabled):node_modules/webtorrent/lib/utp.js"() {
      init_esbuild_inject();
    }
  });

  // node_modules/webtorrent/package.json
  var require_package = __commonJS({
    "node_modules/webtorrent/package.json"(exports, module) {
      module.exports = {
        name: "webtorrent",
        description: "Streaming torrent client",
        version: "1.8.24",
        author: {
          name: "WebTorrent LLC",
          email: "feross@webtorrent.io",
          url: "https://webtorrent.io"
        },
        browser: {
          "./lib/server.js": false,
          "./lib/conn-pool.js": false,
          "./lib/utp.js": false,
          "bittorrent-dht/client": false,
          fs: false,
          "fs-chunk-store": "memory-chunk-store",
          "load-ip-set": false,
          net: false,
          os: false,
          ut_pex: false
        },
        browserify: {
          transform: [
            "package-json-versionify"
          ]
        },
        bugs: {
          url: "https://github.com/webtorrent/webtorrent/issues"
        },
        chromeapp: {
          "./lib/utp.js": false,
          "fs-chunk-store": "memory-chunk-store",
          http: "@webtorrent/http-node",
          "load-ip-set": false,
          net: "chrome-net",
          os: false
        },
        dependencies: {
          "@webtorrent/http-node": "^1.3.0",
          "addr-to-ip-port": "^1.5.4",
          bitfield: "^4.1.0",
          "bittorrent-dht": "^10.0.4",
          "bittorrent-protocol": "^3.5.5",
          "cache-chunk-store": "^3.2.2",
          "chrome-net": "^3.3.4",
          "chunk-store-stream": "^4.3.0",
          cpus: "^1.0.3",
          "create-torrent": "^5.0.2",
          debug: "^4.3.4",
          "end-of-stream": "^1.4.4",
          "escape-html": "^1.0.3",
          "fs-chunk-store": "^2.0.5",
          "immediate-chunk-store": "^2.2.0",
          "load-ip-set": "^2.2.1",
          lt_donthave: "^1.0.1",
          "memory-chunk-store": "^1.3.5",
          mime: "^3.0.0",
          multistream: "^4.1.0",
          "package-json-versionify": "^1.0.4",
          "parse-torrent": "^9.1.5",
          pump: "^3.0.0",
          "queue-microtask": "^1.2.3",
          "random-iterate": "^1.0.1",
          randombytes: "^2.1.0",
          "range-parser": "^1.2.1",
          "render-media": "^4.1.0",
          "run-parallel": "^1.2.0",
          "run-parallel-limit": "^1.1.0",
          "simple-concat": "^1.0.1",
          "simple-get": "^4.0.1",
          "simple-peer": "^9.11.1",
          "simple-sha1": "^3.1.0",
          "speed-limiter": "^1.0.2",
          "stream-to-blob": "^2.0.1",
          "stream-to-blob-url": "^3.0.2",
          "stream-with-known-length-to-buffer": "^1.0.4",
          throughput: "^1.0.1",
          "torrent-discovery": "^9.4.13",
          "torrent-piece": "^2.0.1",
          "unordered-array-remove": "^1.0.2",
          ut_metadata: "^3.5.2",
          ut_pex: "^3.0.2"
        },
        devDependencies: {
          "@webtorrent/semantic-release-config": "1.0.7",
          airtap: "4.0.4",
          "airtap-manual": "1.0.0",
          "airtap-sauce": "1.1.2",
          "babel-minify": "0.5.2",
          "bittorrent-tracker": "9.19.0",
          browserify: "17.0.0",
          disc: "1.3.3",
          finalhandler: "1.2.0",
          "network-address": "1.1.2",
          "run-series": "1.1.9",
          "semantic-release": "19.0.3",
          "serve-static": "1.15.0",
          standard: "*",
          tape: "5.5.3",
          "webtorrent-fixtures": "1.7.5"
        },
        optionalDependencies: {
          "utp-native": "^2.5.3"
        },
        engines: {
          node: ">=12"
        },
        funding: [
          {
            type: "github",
            url: "https://github.com/sponsors/feross"
          },
          {
            type: "patreon",
            url: "https://www.patreon.com/feross"
          },
          {
            type: "consulting",
            url: "https://feross.org/support"
          }
        ],
        homepage: "https://webtorrent.io",
        keywords: [
          "bittorrent",
          "bittorrent client",
          "download",
          "mad science",
          "p2p",
          "peer-to-peer",
          "peers",
          "streaming",
          "swarm",
          "torrent",
          "web torrent",
          "webrtc",
          "webrtc data",
          "webtorrent"
        ],
        license: "MIT",
        main: "index.js",
        repository: {
          type: "git",
          url: "git://github.com/webtorrent/webtorrent.git"
        },
        scripts: {
          build: "npm run build-js && npm run build-js-worker && npm run build-chromeapp",
          "build-chromeapp": "browserify --browser-field=chromeapp --standalone WebTorrent . | minify --mangle=false > webtorrent.chromeapp.js",
          "build-chromeapp-debug": "browserify --browser-field=chromeapp --standalone WebTorrent . > webtorrent.chromeapp.js",
          "build-js": "browserify --standalone WebTorrent . | minify --mangle=false > webtorrent.min.js",
          "build-js-worker": "browserify ./lib/worker.js | minify --mangle=false > sw.min.js",
          "build-js-debug": "browserify --standalone WebTorrent . > webtorrent.debug.js",
          "build-js-worker-debug": "browserify ./lib/worker.js > sw.debug.js",
          prepublishOnly: "npm run build && npm run update-authors",
          preversion: "npm run build && npm run update-authors",
          size: "npm run size-js && npm run size-disc",
          "size-disc": "browserify --full-paths . | discify --open",
          "size-js": "npm run build && cat webtorrent.min.js | gzip | wc -c",
          test: "standard && npm run test-node && npm run test-browser",
          "test-browser": "airtap --concurrency 1 -- test/*.js test/browser/*.js",
          "test-browser-local": "airtap --preset local -- test/*.js test/browser/*.js",
          "test-node": "tape test/*.js test/node/*.js",
          "update-authors": "./scripts/update-authors.sh"
        },
        standard: {
          ignore: [
            "webtorrent.min.js",
            "sw.min.js",
            "webtorrent.chromeapp.js"
          ]
        },
        renovate: {
          extends: [
            "github>webtorrent/renovate-config"
          ],
          rangeStrategy: "bump"
        },
        release: {
          extends: "@webtorrent/semantic-release-config"
        }
      };
    }
  });

  // node_modules/webtorrent/lib/webconn.js
  var require_webconn = __commonJS({
    "node_modules/webtorrent/lib/webconn.js"(exports, module) {
      init_esbuild_inject();
      var { default: BitField } = require_lib2();
      var debugFactory = require_browser5();
      var get3 = require_simple_get2();
      var ltDontHave = require_lt_donthave();
      var sha1 = require_browser4();
      var Wire = require_bittorrent_protocol();
      var debug2 = debugFactory("webtorrent:webconn");
      var VERSION2 = require_package().version;
      var SOCKET_TIMEOUT = 6e4;
      var RETRY_DELAY = 1e4;
      var WebConn = class extends Wire {
        constructor(url, torrent) {
          super();
          this.url = url;
          this.connId = url;
          this.webPeerId = sha1.sync(url);
          this._torrent = torrent;
          this._init();
        }
        _init() {
          this.setKeepAlive(true);
          this.use(ltDontHave());
          this.once("handshake", (infoHash, peerId) => {
            if (this.destroyed)
              return;
            this.handshake(infoHash, this.webPeerId);
            const numPieces = this._torrent.pieces.length;
            const bitfield = new BitField(numPieces);
            for (let i = 0; i <= numPieces; i++) {
              bitfield.set(i, true);
            }
            this.bitfield(bitfield);
          });
          this.once("interested", () => {
            debug2("interested");
            this.unchoke();
          });
          this.on("uninterested", () => {
            debug2("uninterested");
          });
          this.on("choke", () => {
            debug2("choke");
          });
          this.on("unchoke", () => {
            debug2("unchoke");
          });
          this.on("bitfield", () => {
            debug2("bitfield");
          });
          this.lt_donthave.on("donthave", () => {
            debug2("donthave");
          });
          this.on("request", (pieceIndex, offset, length, callback) => {
            debug2("request pieceIndex=%d offset=%d length=%d", pieceIndex, offset, length);
            this.httpRequest(pieceIndex, offset, length, (err, data) => {
              if (err) {
                this.lt_donthave.donthave(pieceIndex);
                const retryTimeout = setTimeout(() => {
                  if (this.destroyed)
                    return;
                  this.have(pieceIndex);
                }, RETRY_DELAY);
                if (retryTimeout.unref)
                  retryTimeout.unref();
              }
              callback(err, data);
            });
          });
        }
        httpRequest(pieceIndex, offset, length, cb) {
          const pieceOffset = pieceIndex * this._torrent.pieceLength;
          const rangeStart = pieceOffset + offset;
          const rangeEnd = rangeStart + length - 1;
          const files = this._torrent.files;
          let requests;
          if (files.length <= 1) {
            requests = [{
              url: this.url,
              start: rangeStart,
              end: rangeEnd
            }];
          } else {
            const requestedFiles = files.filter((file) => file.offset <= rangeEnd && file.offset + file.length > rangeStart);
            if (requestedFiles.length < 1) {
              return cb(new Error("Could not find file corresponding to web seed range request"));
            }
            requests = requestedFiles.map((requestedFile) => {
              const fileEnd = requestedFile.offset + requestedFile.length - 1;
              const url = this.url + (this.url[this.url.length - 1] === "/" ? "" : "/") + requestedFile.path.replace(this._torrent.path, "");
              return {
                url,
                fileOffsetInRange: Math.max(requestedFile.offset - rangeStart, 0),
                start: Math.max(rangeStart - requestedFile.offset, 0),
                end: Math.min(fileEnd, rangeEnd - requestedFile.offset)
              };
            });
          }
          let numRequestsSucceeded = 0;
          let hasError = false;
          let ret;
          if (requests.length > 1) {
            ret = Buffer3.alloc(length);
          }
          requests.forEach((request3) => {
            const url = request3.url;
            const start = request3.start;
            const end = request3.end;
            debug2("Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d", url, pieceIndex, offset, length, start, end);
            const opts = {
              url,
              method: "GET",
              headers: {
                "user-agent": `WebTorrent/${VERSION2} (https://webtorrent.io)`,
                range: `bytes=${start}-${end}`
              },
              timeout: SOCKET_TIMEOUT
            };
            function onResponse(res, data) {
              if (res.statusCode < 200 || res.statusCode >= 300) {
                if (hasError)
                  return;
                hasError = true;
                return cb(new Error(`Unexpected HTTP status code ${res.statusCode}`));
              }
              debug2("Got data of length %d", data.length);
              if (requests.length === 1) {
                cb(null, data);
              } else {
                data.copy(ret, request3.fileOffsetInRange);
                if (++numRequestsSucceeded === requests.length) {
                  cb(null, ret);
                }
              }
            }
            get3.concat(opts, (err, res, data) => {
              if (hasError)
                return;
              if (err) {
                if (typeof window === "undefined" || url.startsWith(`${window.location.origin}/`)) {
                  hasError = true;
                  return cb(err);
                }
                return get3.head(url, (errHead, res2) => {
                  if (hasError)
                    return;
                  if (errHead) {
                    hasError = true;
                    return cb(errHead);
                  }
                  if (res2.statusCode < 200 || res2.statusCode >= 300) {
                    hasError = true;
                    return cb(new Error(`Unexpected HTTP status code ${res2.statusCode}`));
                  }
                  if (res2.url === url) {
                    hasError = true;
                    return cb(err);
                  }
                  opts.url = res2.url;
                  get3.concat(opts, (err2, res3, data2) => {
                    if (hasError)
                      return;
                    if (err2) {
                      hasError = true;
                      return cb(err2);
                    }
                    onResponse(res3, data2);
                  });
                });
              }
              onResponse(res, data);
            });
          });
        }
        destroy() {
          super.destroy();
          this._torrent = null;
        }
      };
      module.exports = WebConn;
    }
  });

  // node_modules/webtorrent/lib/torrent.js
  var require_torrent = __commonJS({
    "node_modules/webtorrent/lib/torrent.js"(exports, module) {
      init_esbuild_inject();
      var EventEmitter2 = require_events();
      var fs = require_fs();
      var net = require_net();
      var os = require_os();
      var path = require_path();
      var addrToIPPort = require_addr_to_ip_port();
      var { default: BitField } = require_lib2();
      var CacheChunkStore = require_cache_chunk_store();
      var ChunkStoreWriteStream = require_write();
      var cpus2 = require_browser7();
      var debugFactory = require_browser5();
      var Discovery = require_torrent_discovery();
      var FSChunkStore = require_memory_chunk_store();
      var get3 = require_simple_get2();
      var ImmediateChunkStore = require_immediate_chunk_store();
      var ltDontHave = require_lt_donthave();
      var MemoryChunkStore = require_memory_chunk_store();
      var MultiStream = require_multistream();
      var parallel = require_run_parallel();
      var parallelLimit = require_run_parallel_limit();
      var parseTorrent = require_parse_torrent();
      var Piece = require_torrent_piece();
      var pump = require_pump();
      var queueMicrotask2 = require_queue_microtask();
      var randomIterate = require_random_iterate();
      var sha1 = require_browser4();
      var throughput = require_throughput();
      var utMetadata = require_ut_metadata();
      var utPex = require_ut_pex();
      var File2 = require_file();
      var Peer = require_peer();
      var RarityMap = require_rarity_map();
      var Server = require_server();
      var utp = require_utp();
      var WebConn = require_webconn();
      var debug2 = debugFactory("webtorrent:torrent");
      var MAX_BLOCK_LENGTH = 128 * 1024;
      var PIECE_TIMEOUT = 3e4;
      var CHOKE_TIMEOUT = 5e3;
      var SPEED_THRESHOLD = 3 * Piece.BLOCK_LENGTH;
      var PIPELINE_MIN_DURATION = 0.5;
      var PIPELINE_MAX_DURATION = 1;
      var RECHOKE_INTERVAL = 1e4;
      var RECHOKE_OPTIMISTIC_DURATION = 2;
      var FILESYSTEM_CONCURRENCY = process.browser ? cpus2().length : 2;
      var RECONNECT_WAIT = [1e3, 5e3, 15e3];
      var VERSION2 = require_package().version;
      var USER_AGENT = `WebTorrent/${VERSION2} (https://webtorrent.io)`;
      var TMP;
      try {
        TMP = path.join(fs.statSync("/tmp") && "/tmp", "webtorrent");
      } catch (err) {
        TMP = path.join(typeof os.tmpdir === "function" ? os.tmpdir() : "/", "webtorrent");
      }
      var Torrent = class extends EventEmitter2 {
        constructor(torrentId, client, opts) {
          super();
          this._debugId = "unknown infohash";
          this.client = client;
          this.announce = opts.announce;
          this.urlList = opts.urlList;
          this.path = opts.path || TMP;
          this.addUID = opts.addUID || false;
          this.skipVerify = !!opts.skipVerify;
          this._store = opts.store || FSChunkStore;
          this._preloadedStore = opts.preloadedStore || null;
          this._storeCacheSlots = opts.storeCacheSlots !== void 0 ? opts.storeCacheSlots : 20;
          this._destroyStoreOnDestroy = opts.destroyStoreOnDestroy || false;
          this._getAnnounceOpts = opts.getAnnounceOpts;
          if (typeof opts.private === "boolean")
            this.private = opts.private;
          this.strategy = opts.strategy || "sequential";
          this.maxWebConns = opts.maxWebConns || 4;
          this._rechokeNumSlots = opts.uploads === false || opts.uploads === 0 ? 0 : +opts.uploads || 10;
          this._rechokeOptimisticWire = null;
          this._rechokeOptimisticTime = 0;
          this._rechokeIntervalId = null;
          this.ready = false;
          this.destroyed = false;
          this.paused = opts.paused || false;
          this.done = false;
          this.metadata = null;
          this.store = null;
          this.storeOpts = opts.storeOpts;
          this.files = [];
          this.pieces = [];
          this._amInterested = false;
          this._selections = [];
          this._critical = [];
          this.wires = [];
          this._queue = [];
          this._peers = {};
          this._peersLength = 0;
          this.received = 0;
          this.uploaded = 0;
          this._downloadSpeed = throughput();
          this._uploadSpeed = throughput();
          this._servers = [];
          this._xsRequests = [];
          this._fileModtimes = opts.fileModtimes;
          if (torrentId !== null)
            this._onTorrentId(torrentId);
          this._debug("new torrent");
        }
        get timeRemaining() {
          if (this.done)
            return 0;
          if (this.downloadSpeed === 0)
            return Infinity;
          return (this.length - this.downloaded) / this.downloadSpeed * 1e3;
        }
        get downloaded() {
          if (!this.bitfield)
            return 0;
          let downloaded = 0;
          for (let index = 0, len = this.pieces.length; index < len; ++index) {
            if (this.bitfield.get(index)) {
              downloaded += index === len - 1 ? this.lastPieceLength : this.pieceLength;
            } else {
              const piece = this.pieces[index];
              downloaded += piece.length - piece.missing;
            }
          }
          return downloaded;
        }
        get downloadSpeed() {
          return this._downloadSpeed();
        }
        get uploadSpeed() {
          return this._uploadSpeed();
        }
        get progress() {
          return this.length ? this.downloaded / this.length : 0;
        }
        get ratio() {
          return this.uploaded / (this.received || this.length);
        }
        get numPeers() {
          return this.wires.length;
        }
        get torrentFileBlobURL() {
          if (typeof window === "undefined")
            throw new Error("browser-only property");
          if (!this.torrentFile)
            return null;
          return URL.createObjectURL(new Blob([this.torrentFile], { type: "application/x-bittorrent" }));
        }
        get _numQueued() {
          return this._queue.length + (this._peersLength - this._numConns);
        }
        get _numConns() {
          let numConns = 0;
          for (const id in this._peers) {
            if (this._peers[id].connected)
              numConns += 1;
          }
          return numConns;
        }
        _onTorrentId(torrentId) {
          if (this.destroyed)
            return;
          let parsedTorrent;
          try {
            parsedTorrent = parseTorrent(torrentId);
          } catch (err) {
          }
          if (parsedTorrent) {
            this.infoHash = parsedTorrent.infoHash;
            this._debugId = parsedTorrent.infoHash.toString("hex").substring(0, 7);
            queueMicrotask2(() => {
              if (this.destroyed)
                return;
              this._onParsedTorrent(parsedTorrent);
            });
          } else {
            parseTorrent.remote(torrentId, (err, parsedTorrent2) => {
              if (this.destroyed)
                return;
              if (err)
                return this._destroy(err);
              this._onParsedTorrent(parsedTorrent2);
            });
          }
        }
        _onParsedTorrent(parsedTorrent) {
          if (this.destroyed)
            return;
          this._processParsedTorrent(parsedTorrent);
          if (!this.infoHash) {
            return this._destroy(new Error("Malformed torrent data: No info hash"));
          }
          this._rechokeIntervalId = setInterval(() => {
            this._rechoke();
          }, RECHOKE_INTERVAL);
          if (this._rechokeIntervalId.unref)
            this._rechokeIntervalId.unref();
          this.emit("_infoHash", this.infoHash);
          if (this.destroyed)
            return;
          this.emit("infoHash", this.infoHash);
          if (this.destroyed)
            return;
          if (this.client.listening) {
            this._onListening();
          } else {
            this.client.once("listening", () => {
              this._onListening();
            });
          }
        }
        _processParsedTorrent(parsedTorrent) {
          this._debugId = parsedTorrent.infoHash.toString("hex").substring(0, 7);
          if (typeof this.private !== "undefined") {
            parsedTorrent.private = this.private;
          }
          if (this.announce) {
            parsedTorrent.announce = parsedTorrent.announce.concat(this.announce);
          }
          if (this.client.tracker && globalThis.WEBTORRENT_ANNOUNCE && !parsedTorrent.private) {
            parsedTorrent.announce = parsedTorrent.announce.concat(globalThis.WEBTORRENT_ANNOUNCE);
          }
          if (this.urlList) {
            parsedTorrent.urlList = parsedTorrent.urlList.concat(this.urlList);
          }
          parsedTorrent.announce = Array.from(new Set(parsedTorrent.announce));
          parsedTorrent.urlList = Array.from(new Set(parsedTorrent.urlList));
          Object.assign(this, parsedTorrent);
          this.magnetURI = parseTorrent.toMagnetURI(parsedTorrent);
          this.torrentFile = parseTorrent.toTorrentFile(parsedTorrent);
        }
        _onListening() {
          if (this.destroyed)
            return;
          if (this.info) {
            this._onMetadata(this);
          } else {
            if (this.xs)
              this._getMetadataFromServer();
            this._startDiscovery();
          }
        }
        _startDiscovery() {
          if (this.discovery || this.destroyed)
            return;
          let trackerOpts = this.client.tracker;
          if (trackerOpts) {
            trackerOpts = Object.assign({}, this.client.tracker, {
              getAnnounceOpts: () => {
                if (this.destroyed)
                  return;
                const opts = {
                  uploaded: this.uploaded,
                  downloaded: this.downloaded,
                  left: Math.max(this.length - this.downloaded, 0)
                };
                if (this.client.tracker.getAnnounceOpts) {
                  Object.assign(opts, this.client.tracker.getAnnounceOpts());
                }
                if (this._getAnnounceOpts) {
                  Object.assign(opts, this._getAnnounceOpts());
                }
                return opts;
              }
            });
          }
          if (this.peerAddresses) {
            this.peerAddresses.forEach((peer) => this.addPeer(peer));
          }
          this.discovery = new Discovery({
            infoHash: this.infoHash,
            announce: this.announce,
            peerId: this.client.peerId,
            dht: !this.private && this.client.dht,
            tracker: trackerOpts,
            port: this.client.torrentPort,
            userAgent: USER_AGENT,
            lsd: this.client.lsd
          });
          this.discovery.on("error", (err) => {
            this._destroy(err);
          });
          this.discovery.on("peer", (peer, source) => {
            this._debug("peer %s discovered via %s", peer, source);
            if (typeof peer === "string" && this.done)
              return;
            this.addPeer(peer);
          });
          this.discovery.on("trackerAnnounce", () => {
            this.emit("trackerAnnounce");
            if (this.numPeers === 0)
              this.emit("noPeers", "tracker");
          });
          this.discovery.on("dhtAnnounce", () => {
            this.emit("dhtAnnounce");
            if (this.numPeers === 0)
              this.emit("noPeers", "dht");
          });
          this.discovery.on("warning", (err) => {
            this.emit("warning", err);
          });
        }
        _getMetadataFromServer() {
          const self2 = this;
          const urls = Array.isArray(this.xs) ? this.xs : [this.xs];
          const tasks = urls.map((url) => (cb) => {
            getMetadataFromURL(url, cb);
          });
          parallel(tasks);
          function getMetadataFromURL(url, cb) {
            if (url.indexOf("http://") !== 0 && url.indexOf("https://") !== 0) {
              self2.emit("warning", new Error(`skipping non-http xs param: ${url}`));
              return cb(null);
            }
            const opts = {
              url,
              method: "GET",
              headers: {
                "user-agent": USER_AGENT
              }
            };
            let req;
            try {
              req = get3.concat(opts, onResponse);
            } catch (err) {
              self2.emit("warning", new Error(`skipping invalid url xs param: ${url}`));
              return cb(null);
            }
            self2._xsRequests.push(req);
            function onResponse(err, res, torrent) {
              if (self2.destroyed)
                return cb(null);
              if (self2.metadata)
                return cb(null);
              if (err) {
                self2.emit("warning", new Error(`http error from xs param: ${url}`));
                return cb(null);
              }
              if (res.statusCode !== 200) {
                self2.emit("warning", new Error(`non-200 status code ${res.statusCode} from xs param: ${url}`));
                return cb(null);
              }
              let parsedTorrent;
              try {
                parsedTorrent = parseTorrent(torrent);
              } catch (err2) {
              }
              if (!parsedTorrent) {
                self2.emit("warning", new Error(`got invalid torrent file from xs param: ${url}`));
                return cb(null);
              }
              if (parsedTorrent.infoHash !== self2.infoHash) {
                self2.emit("warning", new Error(`got torrent file with incorrect info hash from xs param: ${url}`));
                return cb(null);
              }
              self2._onMetadata(parsedTorrent);
              cb(null);
            }
          }
        }
        _onMetadata(metadata) {
          if (this.metadata || this.destroyed)
            return;
          this._debug("got metadata");
          this._xsRequests.forEach((req) => {
            req.abort();
          });
          this._xsRequests = [];
          let parsedTorrent;
          if (metadata && metadata.infoHash) {
            parsedTorrent = metadata;
          } else {
            try {
              parsedTorrent = parseTorrent(metadata);
            } catch (err) {
              return this._destroy(err);
            }
          }
          this._processParsedTorrent(parsedTorrent);
          this.metadata = this.torrentFile;
          if (this.client.enableWebSeeds) {
            this.urlList.forEach((url) => {
              this.addWebSeed(url);
            });
          }
          this._rarityMap = new RarityMap(this);
          this.files = this.files.map((file) => new File2(this, file));
          let rawStore = this._preloadedStore;
          if (!rawStore) {
            rawStore = new this._store(this.pieceLength, {
              ...this.storeOpts,
              torrent: this,
              path: this.path,
              files: this.files,
              length: this.length,
              name: this.name + " - " + this.infoHash.slice(0, 8),
              addUID: this.addUID
            });
          }
          if (this._storeCacheSlots > 0 && !(rawStore instanceof MemoryChunkStore)) {
            rawStore = new CacheChunkStore(rawStore, {
              max: this._storeCacheSlots
            });
          }
          this.store = new ImmediateChunkStore(rawStore);
          if (this.so) {
            this.files.forEach((v, i) => {
              if (this.so.includes(i)) {
                this.files[i].select();
              } else {
                this.files[i].deselect();
              }
            });
          } else {
            if (this.pieces.length !== 0) {
              this.select(0, this.pieces.length - 1, false);
            }
          }
          this._hashes = this.pieces;
          this.pieces = this.pieces.map((hash, i) => {
            const pieceLength = i === this.pieces.length - 1 ? this.lastPieceLength : this.pieceLength;
            return new Piece(pieceLength);
          });
          this._reservations = this.pieces.map(() => []);
          this.bitfield = new BitField(this.pieces.length);
          this.emit("metadata");
          if (this.destroyed)
            return;
          if (this.skipVerify) {
            this._markAllVerified();
            this._onStore();
          } else {
            const onPiecesVerified = (err) => {
              if (err)
                return this._destroy(err);
              this._debug("done verifying");
              this._onStore();
            };
            this._debug("verifying existing torrent data");
            if (this._fileModtimes && this._store === FSChunkStore) {
              this.getFileModtimes((err, fileModtimes) => {
                if (err)
                  return this._destroy(err);
                const unchanged = this.files.map((_, index) => fileModtimes[index] === this._fileModtimes[index]).every((x) => x);
                if (unchanged) {
                  this._markAllVerified();
                  this._onStore();
                } else {
                  this._verifyPieces(onPiecesVerified);
                }
              });
            } else {
              this._verifyPieces(onPiecesVerified);
            }
          }
        }
        getFileModtimes(cb) {
          const ret = [];
          parallelLimit(this.files.map((file, index) => (cb2) => {
            const filePath = this.addUID ? path.join(this.name + " - " + this.infoHash.slice(0, 8)) : path.join(this.path, file.path);
            fs.stat(filePath, (err, stat) => {
              if (err && err.code !== "ENOENT")
                return cb2(err);
              ret[index] = stat && stat.mtime.getTime();
              cb2(null);
            });
          }), FILESYSTEM_CONCURRENCY, (err) => {
            this._debug("done getting file modtimes");
            cb(err, ret);
          });
        }
        _verifyPieces(cb) {
          parallelLimit(this.pieces.map((piece, index) => (cb2) => {
            if (this.destroyed)
              return cb2(new Error("torrent is destroyed"));
            const getOpts = {};
            if (index === this.pieces.length - 1) {
              getOpts.length = this.lastPieceLength;
            }
            this.store.get(index, getOpts, (err, buf) => {
              if (this.destroyed)
                return cb2(new Error("torrent is destroyed"));
              if (err)
                return queueMicrotask2(() => cb2(null));
              sha1(buf, (hash) => {
                if (this.destroyed)
                  return cb2(new Error("torrent is destroyed"));
                if (hash === this._hashes[index]) {
                  this._debug("piece verified %s", index);
                  this._markVerified(index);
                } else {
                  this._debug("piece invalid %s", index);
                }
                cb2(null);
              });
            });
          }), FILESYSTEM_CONCURRENCY, cb);
        }
        rescanFiles(cb) {
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          if (!cb)
            cb = noop2;
          this._verifyPieces((err) => {
            if (err) {
              this._destroy(err);
              return cb(err);
            }
            this._checkDone();
            cb(null);
          });
        }
        _markAllVerified() {
          for (let index = 0; index < this.pieces.length; index++) {
            this._markVerified(index);
          }
        }
        _markVerified(index) {
          this.pieces[index] = null;
          this._reservations[index] = null;
          this.bitfield.set(index, true);
        }
        _hasAllPieces() {
          for (let index = 0; index < this.pieces.length; index++) {
            if (!this.bitfield.get(index))
              return false;
          }
          return true;
        }
        _hasNoPieces() {
          return !this._hasMorePieces(0);
        }
        _hasMorePieces(threshold) {
          let count = 0;
          for (let index = 0; index < this.pieces.length; index++) {
            if (this.bitfield.get(index)) {
              count += 1;
              if (count > threshold)
                return true;
            }
          }
          return false;
        }
        _onStore() {
          if (this.destroyed)
            return;
          this._debug("on store");
          this._startDiscovery();
          this.ready = true;
          this.emit("ready");
          this._checkDone();
          this._updateSelections();
          this.wires.forEach((wire) => {
            if (wire.ut_metadata)
              wire.ut_metadata.setMetadata(this.metadata);
            this._onWireWithMetadata(wire);
          });
        }
        destroy(opts, cb) {
          if (typeof opts === "function")
            return this.destroy(null, opts);
          this._destroy(null, opts, cb);
        }
        _destroy(err, opts, cb) {
          if (typeof opts === "function")
            return this._destroy(err, null, opts);
          if (this.destroyed)
            return;
          this.destroyed = true;
          this._debug("destroy");
          this.client._remove(this);
          clearInterval(this._rechokeIntervalId);
          this._xsRequests.forEach((req) => {
            req.abort();
          });
          if (this._rarityMap) {
            this._rarityMap.destroy();
          }
          for (const id in this._peers) {
            this.removePeer(id);
          }
          this.files.forEach((file) => {
            if (file instanceof File2)
              file._destroy();
          });
          const tasks = this._servers.map((server) => (cb2) => {
            server.destroy(cb2);
          });
          if (this.discovery) {
            tasks.push((cb2) => {
              this.discovery.destroy(cb2);
            });
          }
          if (this.store) {
            let destroyStore = this._destroyStoreOnDestroy;
            if (opts && opts.destroyStore !== void 0) {
              destroyStore = opts.destroyStore;
            }
            tasks.push((cb2) => {
              if (destroyStore) {
                this.store.destroy(cb2);
              } else {
                this.store.close(cb2);
              }
            });
          }
          parallel(tasks, cb);
          if (err) {
            if (this.listenerCount("error") === 0) {
              this.client.emit("error", err);
            } else {
              this.emit("error", err);
            }
          }
          this.emit("close");
          this.client = null;
          this.files = [];
          this.discovery = null;
          this.store = null;
          this._rarityMap = null;
          this._peers = null;
          this._servers = null;
          this._xsRequests = null;
        }
        addPeer(peer) {
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          if (!this.infoHash)
            throw new Error("addPeer() must not be called before the `infoHash` event");
          let host;
          if (this.client.blocked) {
            if (typeof peer === "string") {
              let parts;
              try {
                parts = addrToIPPort(peer);
              } catch (e) {
                this._debug("ignoring peer: invalid %s", peer);
                this.emit("invalidPeer", peer);
                return false;
              }
              host = parts[0];
            } else if (typeof peer.remoteAddress === "string") {
              host = peer.remoteAddress;
            }
            if (host && this.client.blocked.contains(host)) {
              this._debug("ignoring peer: blocked %s", peer);
              if (typeof peer !== "string")
                peer.destroy();
              this.emit("blockedPeer", peer);
              return false;
            }
          }
          const type2 = this.client.utp && this._isIPv4(host) ? "utp" : "tcp";
          const wasAdded = !!this._addPeer(peer, type2);
          if (wasAdded) {
            this.emit("peer", peer);
          } else {
            this.emit("invalidPeer", peer);
          }
          return wasAdded;
        }
        _addPeer(peer, type2) {
          if (this.destroyed) {
            if (typeof peer !== "string")
              peer.destroy();
            return null;
          }
          if (typeof peer === "string" && !this._validAddr(peer)) {
            this._debug("ignoring peer: invalid %s", peer);
            return null;
          }
          const id = peer && peer.id || peer;
          if (this._peers[id]) {
            this._debug("ignoring peer: duplicate (%s)", id);
            if (typeof peer !== "string")
              peer.destroy();
            return null;
          }
          if (this.paused) {
            this._debug("ignoring peer: torrent is paused");
            if (typeof peer !== "string")
              peer.destroy();
            return null;
          }
          this._debug("add peer %s", id);
          let newPeer;
          if (typeof peer === "string") {
            newPeer = type2 === "utp" ? Peer.createUTPOutgoingPeer(peer, this, this.client.throttleGroups) : Peer.createTCPOutgoingPeer(peer, this, this.client.throttleGroups);
          } else {
            newPeer = Peer.createWebRTCPeer(peer, this, this.client.throttleGroups);
          }
          this._registerPeer(newPeer);
          if (typeof peer === "string") {
            this._queue.push(newPeer);
            this._drain();
          }
          return newPeer;
        }
        addWebSeed(urlOrConn) {
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          let id;
          let conn;
          if (typeof urlOrConn === "string") {
            id = urlOrConn;
            if (!/^https?:\/\/.+/.test(id)) {
              this.emit("warning", new Error(`ignoring invalid web seed: ${id}`));
              this.emit("invalidPeer", id);
              return;
            }
            if (this._peers[id]) {
              this.emit("warning", new Error(`ignoring duplicate web seed: ${id}`));
              this.emit("invalidPeer", id);
              return;
            }
            conn = new WebConn(id, this);
          } else if (urlOrConn && typeof urlOrConn.connId === "string") {
            conn = urlOrConn;
            id = conn.connId;
            if (this._peers[id]) {
              this.emit("warning", new Error(`ignoring duplicate web seed: ${id}`));
              this.emit("invalidPeer", id);
              return;
            }
          } else {
            this.emit("warning", new Error("addWebSeed must be passed a string or connection object with id property"));
            return;
          }
          this._debug("add web seed %s", id);
          const newPeer = Peer.createWebSeedPeer(conn, id, this, this.client.throttleGroups);
          this._registerPeer(newPeer);
          this.emit("peer", id);
        }
        _addIncomingPeer(peer) {
          if (this.destroyed)
            return peer.destroy(new Error("torrent is destroyed"));
          if (this.paused)
            return peer.destroy(new Error("torrent is paused"));
          this._debug("add incoming peer %s", peer.id);
          this._registerPeer(peer);
        }
        _registerPeer(newPeer) {
          newPeer.on("download", (downloaded) => {
            if (this.destroyed)
              return;
            this.received += downloaded;
            this._downloadSpeed(downloaded);
            this.client._downloadSpeed(downloaded);
            this.emit("download", downloaded);
            if (this.destroyed)
              return;
            this.client.emit("download", downloaded);
          });
          newPeer.on("upload", (uploaded) => {
            if (this.destroyed)
              return;
            this.uploaded += uploaded;
            this._uploadSpeed(uploaded);
            this.client._uploadSpeed(uploaded);
            this.emit("upload", uploaded);
            if (this.destroyed)
              return;
            this.client.emit("upload", uploaded);
          });
          this._peers[newPeer.id] = newPeer;
          this._peersLength += 1;
        }
        removePeer(peer) {
          const id = peer && peer.id || peer;
          peer = this._peers[id];
          if (!peer)
            return;
          this._debug("removePeer %s", id);
          delete this._peers[id];
          this._peersLength -= 1;
          peer.destroy();
          this._drain();
        }
        select(start, end, priority, notify) {
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          if (start < 0 || end < start || this.pieces.length <= end) {
            throw new Error(`invalid selection ${start} : ${end}`);
          }
          priority = Number(priority) || 0;
          this._debug("select %s-%s (priority %s)", start, end, priority);
          this._selections.push({
            from: start,
            to: end,
            offset: 0,
            priority,
            notify: notify || noop2
          });
          this._selections.sort((a, b) => b.priority - a.priority);
          this._updateSelections();
        }
        deselect(start, end, priority) {
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          priority = Number(priority) || 0;
          this._debug("deselect %s-%s (priority %s)", start, end, priority);
          for (let i = 0; i < this._selections.length; ++i) {
            const s = this._selections[i];
            if (s.from === start && s.to === end && s.priority === priority) {
              this._selections.splice(i, 1);
              break;
            }
          }
          this._updateSelections();
        }
        critical(start, end) {
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          this._debug("critical %s-%s", start, end);
          for (let i = start; i <= end; ++i) {
            this._critical[i] = true;
          }
          this._updateSelections();
        }
        _onWire(wire, addr) {
          this._debug("got wire %s (%s)", wire._debugId, addr || "Unknown");
          this.wires.push(wire);
          if (addr) {
            const parts = addrToIPPort(addr);
            wire.remoteAddress = parts[0];
            wire.remotePort = parts[1];
          }
          if (this.client.dht && this.client.dht.listening) {
            wire.on("port", (port) => {
              if (this.destroyed || this.client.dht.destroyed) {
                return;
              }
              if (!wire.remoteAddress) {
                return this._debug("ignoring PORT from peer with no address");
              }
              if (port === 0 || port > 65536) {
                return this._debug("ignoring invalid PORT from peer");
              }
              this._debug("port: %s (from %s)", port, addr);
              this.client.dht.addNode({ host: wire.remoteAddress, port });
            });
          }
          wire.on("timeout", () => {
            this._debug("wire timeout (%s)", addr);
            wire.destroy();
          });
          if (wire.type !== "webSeed") {
            wire.setTimeout(PIECE_TIMEOUT, true);
          }
          wire.setKeepAlive(true);
          wire.use(utMetadata(this.metadata));
          wire.ut_metadata.on("warning", (err) => {
            this._debug("ut_metadata warning: %s", err.message);
          });
          if (!this.metadata) {
            wire.ut_metadata.on("metadata", (metadata) => {
              this._debug("got metadata via ut_metadata");
              this._onMetadata(metadata);
            });
            wire.ut_metadata.fetch();
          }
          if (typeof utPex === "function" && !this.private) {
            wire.use(utPex());
            wire.ut_pex.on("peer", (peer) => {
              if (this.done)
                return;
              this._debug("ut_pex: got peer: %s (from %s)", peer, addr);
              this.addPeer(peer);
            });
            wire.ut_pex.on("dropped", (peer) => {
              const peerObj = this._peers[peer];
              if (peerObj && !peerObj.connected) {
                this._debug("ut_pex: dropped peer: %s (from %s)", peer, addr);
                this.removePeer(peer);
              }
            });
            wire.once("close", () => {
              wire.ut_pex.reset();
            });
          }
          wire.use(ltDontHave());
          this.emit("wire", wire, addr);
          if (this.ready) {
            queueMicrotask2(() => {
              this._onWireWithMetadata(wire);
            });
          }
        }
        _onWireWithMetadata(wire) {
          let timeoutId = null;
          const onChokeTimeout = () => {
            if (this.destroyed || wire.destroyed)
              return;
            if (this._numQueued > 2 * (this._numConns - this.numPeers) && wire.amInterested) {
              wire.destroy();
            } else {
              timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
              if (timeoutId.unref)
                timeoutId.unref();
            }
          };
          let i;
          const updateSeedStatus = () => {
            if (wire.peerPieces.buffer.length !== this.bitfield.buffer.length)
              return;
            for (i = 0; i < this.pieces.length; ++i) {
              if (!wire.peerPieces.get(i))
                return;
            }
            wire.isSeeder = true;
            wire.choke();
          };
          wire.on("bitfield", () => {
            updateSeedStatus();
            this._update();
            this._updateWireInterest(wire);
          });
          wire.on("have", () => {
            updateSeedStatus();
            this._update();
            this._updateWireInterest(wire);
          });
          wire.lt_donthave.on("donthave", () => {
            updateSeedStatus();
            this._update();
            this._updateWireInterest(wire);
          });
          wire.on("have-all", () => {
            wire.isSeeder = true;
            wire.choke();
            this._update();
            this._updateWireInterest(wire);
          });
          wire.on("have-none", () => {
            wire.isSeeder = false;
            this._update();
            this._updateWireInterest(wire);
          });
          wire.on("allowed-fast", (index) => {
            this._update();
          });
          wire.once("interested", () => {
            wire.unchoke();
          });
          wire.once("close", () => {
            clearTimeout(timeoutId);
          });
          wire.on("choke", () => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
            if (timeoutId.unref)
              timeoutId.unref();
          });
          wire.on("unchoke", () => {
            clearTimeout(timeoutId);
            this._update();
          });
          wire.on("request", (index, offset, length, cb) => {
            if (length > MAX_BLOCK_LENGTH) {
              return wire.destroy();
            }
            if (this.pieces[index])
              return;
            this.store.get(index, { offset, length }, cb);
          });
          if (wire.hasFast && this._hasAllPieces())
            wire.haveAll();
          else if (wire.hasFast && this._hasNoPieces())
            wire.haveNone();
          else
            wire.bitfield(this.bitfield);
          this._updateWireInterest(wire);
          if (wire.peerExtensions.dht && this.client.dht && this.client.dht.listening) {
            wire.port(this.client.dht.address().port);
          }
          if (wire.type !== "webSeed") {
            timeoutId = setTimeout(onChokeTimeout, CHOKE_TIMEOUT);
            if (timeoutId.unref)
              timeoutId.unref();
          }
          wire.isSeeder = false;
          updateSeedStatus();
        }
        _updateSelections() {
          if (!this.ready || this.destroyed)
            return;
          queueMicrotask2(() => {
            this._gcSelections();
          });
          this._updateInterest();
          this._update();
        }
        _gcSelections() {
          for (let i = 0; i < this._selections.length; ++i) {
            const s = this._selections[i];
            const oldOffset = s.offset;
            while (this.bitfield.get(s.from + s.offset) && s.from + s.offset < s.to) {
              s.offset += 1;
            }
            if (oldOffset !== s.offset)
              s.notify();
            if (s.to !== s.from + s.offset)
              continue;
            if (!this.bitfield.get(s.from + s.offset))
              continue;
            this._selections.splice(i, 1);
            i -= 1;
            s.notify();
            this._updateInterest();
          }
          if (!this._selections.length)
            this.emit("idle");
        }
        _updateInterest() {
          const prev = this._amInterested;
          this._amInterested = !!this._selections.length;
          this.wires.forEach((wire) => this._updateWireInterest(wire));
          if (prev === this._amInterested)
            return;
          if (this._amInterested)
            this.emit("interested");
          else
            this.emit("uninterested");
        }
        _updateWireInterest(wire) {
          let interested = false;
          for (let index = 0; index < this.pieces.length; ++index) {
            if (this.pieces[index] && wire.peerPieces.get(index)) {
              interested = true;
              break;
            }
          }
          if (interested)
            wire.interested();
          else
            wire.uninterested();
        }
        _update() {
          if (this.destroyed)
            return;
          const ite = randomIterate(this.wires);
          let wire;
          while (wire = ite()) {
            this._updateWireWrapper(wire);
          }
        }
        _updateWireWrapper(wire) {
          const self2 = this;
          if (typeof window !== "undefined" && typeof window.requestIdleCallback === "function") {
            window.requestIdleCallback(() => {
              self2._updateWire(wire);
            }, { timeout: 250 });
          } else {
            self2._updateWire(wire);
          }
        }
        _updateWire(wire) {
          const self2 = this;
          const minOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MIN_DURATION);
          if (wire.requests.length >= minOutstandingRequests)
            return;
          const maxOutstandingRequests = getBlockPipelineLength(wire, PIPELINE_MAX_DURATION);
          if (wire.peerChoking) {
            if (wire.hasFast && wire.peerAllowedFastSet.length > 0 && !this._hasMorePieces(wire.peerAllowedFastSet.length - 1)) {
              requestAllowedFastSet();
            }
            return;
          }
          if (!wire.downloaded)
            return validateWire();
          trySelectWire(false) || trySelectWire(true);
          function requestAllowedFastSet() {
            if (wire.requests.length >= maxOutstandingRequests)
              return false;
            for (const piece of wire.peerAllowedFastSet) {
              if (wire.peerPieces.get(piece) && !self2.bitfield.get(piece)) {
                while (self2._request(wire, piece, false) && wire.requests.length < maxOutstandingRequests) {
                }
              }
              if (wire.requests.length < maxOutstandingRequests)
                continue;
              return true;
            }
            return false;
          }
          function genPieceFilterFunc(start, end, tried, rank) {
            return (i) => i >= start && i <= end && !(i in tried) && wire.peerPieces.get(i) && (!rank || rank(i));
          }
          function validateWire() {
            if (wire.requests.length)
              return;
            let i = self2._selections.length;
            while (i--) {
              const next = self2._selections[i];
              let piece;
              if (self2.strategy === "rarest") {
                const start = next.from + next.offset;
                const end = next.to;
                const len = end - start + 1;
                const tried = {};
                let tries = 0;
                const filter2 = genPieceFilterFunc(start, end, tried);
                while (tries < len) {
                  piece = self2._rarityMap.getRarestPiece(filter2);
                  if (piece < 0)
                    break;
                  if (self2._request(wire, piece, false))
                    return;
                  tried[piece] = true;
                  tries += 1;
                }
              } else {
                for (piece = next.to; piece >= next.from + next.offset; --piece) {
                  if (!wire.peerPieces.get(piece))
                    continue;
                  if (self2._request(wire, piece, false))
                    return;
                }
              }
            }
          }
          function speedRanker() {
            const speed = wire.downloadSpeed() || 1;
            if (speed > SPEED_THRESHOLD)
              return () => true;
            const secs = Math.max(1, wire.requests.length) * Piece.BLOCK_LENGTH / speed;
            let tries = 10;
            let ptr = 0;
            return (index) => {
              if (!tries || self2.bitfield.get(index))
                return true;
              let missing = self2.pieces[index].missing;
              for (; ptr < self2.wires.length; ptr++) {
                const otherWire = self2.wires[ptr];
                const otherSpeed = otherWire.downloadSpeed();
                if (otherSpeed < SPEED_THRESHOLD)
                  continue;
                if (otherSpeed <= speed)
                  continue;
                if (!otherWire.peerPieces.get(index))
                  continue;
                if ((missing -= otherSpeed * secs) > 0)
                  continue;
                tries--;
                return false;
              }
              return true;
            };
          }
          function shufflePriority(i) {
            let last = i;
            for (let j = i; j < self2._selections.length && self2._selections[j].priority; j++) {
              last = j;
            }
            const tmp = self2._selections[i];
            self2._selections[i] = self2._selections[last];
            self2._selections[last] = tmp;
          }
          function trySelectWire(hotswap) {
            if (wire.requests.length >= maxOutstandingRequests)
              return true;
            const rank = speedRanker();
            for (let i = 0; i < self2._selections.length; i++) {
              const next = self2._selections[i];
              let piece;
              if (self2.strategy === "rarest") {
                const start = next.from + next.offset;
                const end = next.to;
                const len = end - start + 1;
                const tried = {};
                let tries = 0;
                const filter2 = genPieceFilterFunc(start, end, tried, rank);
                while (tries < len) {
                  piece = self2._rarityMap.getRarestPiece(filter2);
                  if (piece < 0)
                    break;
                  while (self2._request(wire, piece, self2._critical[piece] || hotswap) && wire.requests.length < maxOutstandingRequests) {
                  }
                  if (wire.requests.length < maxOutstandingRequests) {
                    tried[piece] = true;
                    tries++;
                    continue;
                  }
                  if (next.priority)
                    shufflePriority(i);
                  return true;
                }
              } else {
                for (piece = next.from + next.offset; piece <= next.to; piece++) {
                  if (!wire.peerPieces.get(piece) || !rank(piece))
                    continue;
                  while (self2._request(wire, piece, self2._critical[piece] || hotswap) && wire.requests.length < maxOutstandingRequests) {
                  }
                  if (wire.requests.length < maxOutstandingRequests)
                    continue;
                  if (next.priority)
                    shufflePriority(i);
                  return true;
                }
              }
            }
            return false;
          }
        }
        _rechoke() {
          if (!this.ready)
            return;
          const wireStack = this.wires.map((wire) => ({ wire, random: Math.random() })).sort((objA, objB) => {
            const wireA = objA.wire;
            const wireB = objB.wire;
            if (wireA.downloadSpeed() !== wireB.downloadSpeed()) {
              return wireA.downloadSpeed() - wireB.downloadSpeed();
            }
            if (wireA.uploadSpeed() !== wireB.uploadSpeed()) {
              return wireA.uploadSpeed() - wireB.uploadSpeed();
            }
            if (wireA.amChoking !== wireB.amChoking) {
              return wireA.amChoking ? -1 : 1;
            }
            return objA.random - objB.random;
          }).map((obj) => obj.wire);
          if (this._rechokeOptimisticTime <= 0) {
            this._rechokeOptimisticWire = null;
          } else {
            this._rechokeOptimisticTime -= 1;
          }
          let numInterestedUnchoked = 0;
          while (wireStack.length > 0 && numInterestedUnchoked < this._rechokeNumSlots - 1) {
            const wire = wireStack.pop();
            if (wire.isSeeder || wire === this._rechokeOptimisticWire) {
              continue;
            }
            wire.unchoke();
            if (wire.peerInterested) {
              numInterestedUnchoked++;
            }
          }
          if (this._rechokeOptimisticWire === null && this._rechokeNumSlots > 0) {
            const remaining = wireStack.filter((wire) => wire.peerInterested);
            if (remaining.length > 0) {
              const newOptimisticPeer = remaining[randomInt(remaining.length)];
              newOptimisticPeer.unchoke();
              this._rechokeOptimisticWire = newOptimisticPeer;
              this._rechokeOptimisticTime = RECHOKE_OPTIMISTIC_DURATION;
            }
          }
          wireStack.filter((wire) => wire !== this._rechokeOptimisticWire).forEach((wire) => wire.choke());
        }
        _hotswap(wire, index) {
          const speed = wire.downloadSpeed();
          if (speed < Piece.BLOCK_LENGTH)
            return false;
          if (!this._reservations[index])
            return false;
          const r = this._reservations[index];
          if (!r) {
            return false;
          }
          let minSpeed = Infinity;
          let minWire;
          let i;
          for (i = 0; i < r.length; i++) {
            const otherWire = r[i];
            if (!otherWire || otherWire === wire)
              continue;
            const otherSpeed = otherWire.downloadSpeed();
            if (otherSpeed >= SPEED_THRESHOLD)
              continue;
            if (2 * otherSpeed > speed || otherSpeed > minSpeed)
              continue;
            minWire = otherWire;
            minSpeed = otherSpeed;
          }
          if (!minWire)
            return false;
          for (i = 0; i < r.length; i++) {
            if (r[i] === minWire)
              r[i] = null;
          }
          for (i = 0; i < minWire.requests.length; i++) {
            const req = minWire.requests[i];
            if (req.piece !== index)
              continue;
            this.pieces[index].cancel(req.offset / Piece.BLOCK_LENGTH | 0);
          }
          this.emit("hotswap", minWire, wire, index);
          return true;
        }
        _request(wire, index, hotswap) {
          const self2 = this;
          const numRequests = wire.requests.length;
          const isWebSeed = wire.type === "webSeed";
          if (self2.bitfield.get(index))
            return false;
          const maxOutstandingRequests = isWebSeed ? Math.min(getPiecePipelineLength(wire, PIPELINE_MAX_DURATION, self2.pieceLength), self2.maxWebConns) : getBlockPipelineLength(wire, PIPELINE_MAX_DURATION);
          if (numRequests >= maxOutstandingRequests)
            return false;
          const piece = self2.pieces[index];
          let reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve();
          if (reservation === -1 && hotswap && self2._hotswap(wire, index)) {
            reservation = isWebSeed ? piece.reserveRemaining() : piece.reserve();
          }
          if (reservation === -1)
            return false;
          let r = self2._reservations[index];
          if (!r)
            r = self2._reservations[index] = [];
          let i = r.indexOf(null);
          if (i === -1)
            i = r.length;
          r[i] = wire;
          const chunkOffset = piece.chunkOffset(reservation);
          const chunkLength = isWebSeed ? piece.chunkLengthRemaining(reservation) : piece.chunkLength(reservation);
          wire.request(index, chunkOffset, chunkLength, function onChunk(err, chunk) {
            if (self2.destroyed)
              return;
            if (!self2.ready)
              return self2.once("ready", () => {
                onChunk(err, chunk);
              });
            if (r[i] === wire)
              r[i] = null;
            if (piece !== self2.pieces[index])
              return onUpdateTick();
            if (err) {
              self2._debug("error getting piece %s (offset: %s length: %s) from %s: %s", index, chunkOffset, chunkLength, `${wire.remoteAddress}:${wire.remotePort}`, err.message);
              isWebSeed ? piece.cancelRemaining(reservation) : piece.cancel(reservation);
              onUpdateTick();
              return;
            }
            self2._debug("got piece %s (offset: %s length: %s) from %s", index, chunkOffset, chunkLength, `${wire.remoteAddress}:${wire.remotePort}`);
            if (!piece.set(reservation, chunk, wire))
              return onUpdateTick();
            const buf = piece.flush();
            sha1(buf, (hash) => {
              if (self2.destroyed)
                return;
              if (hash === self2._hashes[index]) {
                self2._debug("piece verified %s", index);
                self2.store.put(index, buf, (err2) => {
                  if (err2) {
                    self2._destroy(err2);
                    return;
                  } else {
                    self2.pieces[index] = null;
                    self2._markVerified(index);
                    self2.wires.forEach((wire2) => {
                      wire2.have(index);
                    });
                  }
                  if (self2._checkDone() && !self2.destroyed)
                    self2.discovery.complete();
                  onUpdateTick();
                });
              } else {
                self2.pieces[index] = new Piece(piece.length);
                self2.emit("warning", new Error(`Piece ${index} failed verification`));
                onUpdateTick();
              }
            });
          });
          function onUpdateTick() {
            queueMicrotask2(() => {
              self2._update();
            });
          }
          return true;
        }
        _checkDone() {
          if (this.destroyed)
            return;
          this.files.forEach((file) => {
            if (file.done)
              return;
            for (let i = file._startPiece; i <= file._endPiece; ++i) {
              if (!this.bitfield.get(i))
                return;
            }
            file.done = true;
            file.emit("done");
            this._debug(`file done: ${file.name}`);
          });
          let done2 = true;
          for (const selection of this._selections) {
            for (let piece = selection.from; piece <= selection.to; piece++) {
              if (!this.bitfield.get(piece)) {
                done2 = false;
                break;
              }
            }
            if (!done2)
              break;
          }
          if (!this.done && done2) {
            this.done = true;
            this._debug(`torrent done: ${this.infoHash}`);
            this.emit("done");
          } else {
            this.done = false;
          }
          this._gcSelections();
          return done2;
        }
        load(streams, cb) {
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          if (!this.ready)
            return this.once("ready", () => {
              this.load(streams, cb);
            });
          if (!Array.isArray(streams))
            streams = [streams];
          if (!cb)
            cb = noop2;
          const readable = new MultiStream(streams);
          const writable = new ChunkStoreWriteStream(this.store, this.pieceLength);
          pump(readable, writable, (err) => {
            if (err)
              return cb(err);
            this._markAllVerified();
            this._checkDone();
            cb(null);
          });
        }
        createServer(requestListener) {
          if (typeof Server !== "function")
            throw new Error("node.js-only method");
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          const server = new Server(this, requestListener);
          this._servers.push(server);
          return server;
        }
        pause() {
          if (this.destroyed)
            return;
          this._debug("pause");
          this.paused = true;
        }
        resume() {
          if (this.destroyed)
            return;
          this._debug("resume");
          this.paused = false;
          this._drain();
        }
        _debug() {
          const args = [].slice.call(arguments);
          args[0] = `[${this.client ? this.client._debugId : "No Client"}] [${this._debugId}] ${args[0]}`;
          debug2(...args);
        }
        _drain() {
          this._debug("_drain numConns %s maxConns %s", this._numConns, this.client.maxConns);
          if (typeof net.connect !== "function" || this.destroyed || this.paused || this._numConns >= this.client.maxConns) {
            return;
          }
          this._debug("drain (%s queued, %s/%s peers)", this._numQueued, this.numPeers, this.client.maxConns);
          const peer = this._queue.shift();
          if (!peer)
            return;
          this._debug("%s connect attempt to %s", peer.type, peer.addr);
          const parts = addrToIPPort(peer.addr);
          const opts = {
            host: parts[0],
            port: parts[1]
          };
          if (this.client.utp && peer.type === "utpOutgoing") {
            peer.conn = utp.connect(opts.port, opts.host);
          } else {
            peer.conn = net.connect(opts);
          }
          const conn = peer.conn;
          conn.once("connect", () => {
            peer.onConnect();
          });
          conn.once("error", (err) => {
            peer.destroy(err);
          });
          peer.startConnectTimeout();
          conn.on("close", () => {
            if (this.destroyed)
              return;
            if (peer.retries >= RECONNECT_WAIT.length) {
              if (this.client.utp) {
                const newPeer = this._addPeer(peer.addr, "tcp");
                if (newPeer)
                  newPeer.retries = 0;
              } else {
                this._debug("conn %s closed: will not re-add (max %s attempts)", peer.addr, RECONNECT_WAIT.length);
              }
              return;
            }
            const ms = RECONNECT_WAIT[peer.retries];
            this._debug("conn %s closed: will re-add to queue in %sms (attempt %s)", peer.addr, ms, peer.retries + 1);
            const reconnectTimeout = setTimeout(() => {
              if (this.destroyed)
                return;
              const host = addrToIPPort(peer.addr)[0];
              const type2 = this.client.utp && this._isIPv4(host) ? "utp" : "tcp";
              const newPeer = this._addPeer(peer.addr, type2);
              if (newPeer)
                newPeer.retries = peer.retries + 1;
            }, ms);
            if (reconnectTimeout.unref)
              reconnectTimeout.unref();
          });
        }
        _validAddr(addr) {
          let parts;
          try {
            parts = addrToIPPort(addr);
          } catch (e) {
            return false;
          }
          const host = parts[0];
          const port = parts[1];
          return port > 0 && port < 65535 && !(host === "127.0.0.1" && port === this.client.torrentPort);
        }
        _isIPv4(addr) {
          const IPv4Pattern = /^((?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])[.]){3}(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/;
          return IPv4Pattern.test(addr);
        }
      };
      function getBlockPipelineLength(wire, duration) {
        let length = 2 + Math.ceil(duration * wire.downloadSpeed() / Piece.BLOCK_LENGTH);
        if (wire.peerExtendedHandshake) {
          const reqq = wire.peerExtendedHandshake.reqq;
          if (typeof reqq === "number" && reqq > 0) {
            length = Math.min(length, reqq);
          }
        }
        return length;
      }
      function getPiecePipelineLength(wire, duration, pieceLength) {
        return 1 + Math.ceil(duration * wire.downloadSpeed() / pieceLength);
      }
      function randomInt(high) {
        return Math.random() * high | 0;
      }
      function noop2() {
      }
      module.exports = Torrent;
    }
  });

  // node_modules/webtorrent/index.js
  var require_webtorrent = __commonJS({
    "node_modules/webtorrent/index.js"(exports, module) {
      init_esbuild_inject();
      var EventEmitter2 = require_events();
      var path = require_path();
      var concat2 = require_simple_concat();
      var createTorrent = require_create_torrent();
      var debugFactory = require_browser5();
      var DHT = require_client();
      var loadIPSet = require_load_ip_set();
      var parallel = require_run_parallel();
      var parseTorrent = require_parse_torrent();
      var Peer = require_simple_peer();
      var queueMicrotask2 = require_queue_microtask();
      var randombytes = require_browser6();
      var sha1 = require_browser4();
      var throughput = require_throughput();
      var { ThrottleGroup } = require_speed_limiter();
      var ConnPool = require_conn_pool();
      var Torrent = require_torrent();
      var { version: VERSION2 } = require_package();
      var debug2 = debugFactory("webtorrent");
      var VERSION_STR = VERSION2.replace(/\d*./g, (v) => `0${v % 100}`.slice(-2)).slice(0, 4);
      var VERSION_PREFIX = `-WW${VERSION_STR}-`;
      var WebTorrent = class extends EventEmitter2 {
        constructor(opts = {}) {
          super();
          if (typeof opts.peerId === "string") {
            this.peerId = opts.peerId;
          } else if (Buffer3.isBuffer(opts.peerId)) {
            this.peerId = opts.peerId.toString("hex");
          } else {
            this.peerId = Buffer3.from(VERSION_PREFIX + randombytes(9).toString("base64")).toString("hex");
          }
          this.peerIdBuffer = Buffer3.from(this.peerId, "hex");
          if (typeof opts.nodeId === "string") {
            this.nodeId = opts.nodeId;
          } else if (Buffer3.isBuffer(opts.nodeId)) {
            this.nodeId = opts.nodeId.toString("hex");
          } else {
            this.nodeId = randombytes(20).toString("hex");
          }
          this.nodeIdBuffer = Buffer3.from(this.nodeId, "hex");
          this._debugId = this.peerId.toString("hex").substring(0, 7);
          this.destroyed = false;
          this.listening = false;
          this.torrentPort = opts.torrentPort || 0;
          this.dhtPort = opts.dhtPort || 0;
          this.tracker = opts.tracker !== void 0 ? opts.tracker : {};
          this.lsd = opts.lsd !== false;
          this.torrents = [];
          this.maxConns = Number(opts.maxConns) || 55;
          this.utp = WebTorrent.UTP_SUPPORT && opts.utp !== false;
          this._downloadLimit = Math.max(typeof opts.downloadLimit === "number" ? opts.downloadLimit : -1, -1);
          this._uploadLimit = Math.max(typeof opts.uploadLimit === "number" ? opts.uploadLimit : -1, -1);
          this.serviceWorker = null;
          this.workerKeepAliveInterval = null;
          this.workerPortCount = 0;
          if (opts.secure === true) {
            require_peer().enableSecure();
          }
          this._debug("new webtorrent (peerId %s, nodeId %s, port %s)", this.peerId, this.nodeId, this.torrentPort);
          this.throttleGroups = {
            down: new ThrottleGroup({ rate: Math.max(this._downloadLimit, 0), enabled: this._downloadLimit >= 0 }),
            up: new ThrottleGroup({ rate: Math.max(this._uploadLimit, 0), enabled: this._uploadLimit >= 0 })
          };
          if (this.tracker) {
            if (typeof this.tracker !== "object")
              this.tracker = {};
            if (globalThis.WRTC && !this.tracker.wrtc)
              this.tracker.wrtc = globalThis.WRTC;
          }
          if (typeof ConnPool === "function") {
            this._connPool = new ConnPool(this);
          } else {
            queueMicrotask2(() => {
              this._onListening();
            });
          }
          this._downloadSpeed = throughput();
          this._uploadSpeed = throughput();
          if (opts.dht !== false && typeof DHT === "function") {
            this.dht = new DHT(Object.assign({}, { nodeId: this.nodeId }, opts.dht));
            this.dht.once("error", (err) => {
              this._destroy(err);
            });
            this.dht.once("listening", () => {
              const address = this.dht.address();
              if (address)
                this.dhtPort = address.port;
            });
            this.dht.setMaxListeners(0);
            this.dht.listen(this.dhtPort);
          } else {
            this.dht = false;
          }
          this.enableWebSeeds = opts.webSeeds !== false;
          const ready = () => {
            if (this.destroyed)
              return;
            this.ready = true;
            this.emit("ready");
          };
          if (typeof loadIPSet === "function" && opts.blocklist != null) {
            loadIPSet(opts.blocklist, {
              headers: {
                "user-agent": `WebTorrent/${VERSION2} (https://webtorrent.io)`
              }
            }, (err, ipSet) => {
              if (err)
                return console.error(`Failed to load blocklist: ${err.message}`);
              this.blocked = ipSet;
              ready();
            });
          } else {
            queueMicrotask2(ready);
          }
        }
        loadWorker(controller, cb = () => {
        }) {
          if (!(controller instanceof ServiceWorker))
            throw new Error("Invalid worker registration");
          if (controller.state !== "activated")
            throw new Error("Worker isn't activated");
          const keepAliveTime = 2e4;
          this.serviceWorker = controller;
          navigator.serviceWorker.addEventListener("message", (event) => {
            const { data } = event;
            if (!data.type || !data.type === "webtorrent" || !data.url)
              return null;
            let [infoHash, ...filePath] = data.url.slice(data.url.indexOf(data.scope + "webtorrent/") + 11 + data.scope.length).split("/");
            filePath = decodeURI(filePath.join("/"));
            if (!infoHash || !filePath)
              return null;
            const [port] = event.ports;
            const file = this.get(infoHash) && this.get(infoHash).files.find((file2) => file2.path === filePath);
            if (!file)
              return null;
            const [response, stream, raw] = file._serve(data);
            const asyncIterator = stream && stream[Symbol.asyncIterator]();
            const cleanup = () => {
              port.onmessage = null;
              if (stream)
                stream.destroy();
              if (raw)
                raw.destroy();
              this.workerPortCount--;
              if (!this.workerPortCount) {
                clearInterval(this.workerKeepAliveInterval);
                this.workerKeepAliveInterval = null;
              }
            };
            port.onmessage = async (msg) => {
              if (msg.data) {
                let chunk;
                try {
                  chunk = (await asyncIterator.next()).value;
                } catch (e) {
                }
                port.postMessage(chunk);
                if (!chunk)
                  cleanup();
                if (!this.workerKeepAliveInterval)
                  this.workerKeepAliveInterval = setInterval(() => fetch(`${this.serviceWorker.scriptURL.slice(0, this.serviceWorker.scriptURL.lastIndexOf("/") + 1).slice(window.location.origin.length)}webtorrent/keepalive/`), keepAliveTime);
              } else {
                cleanup();
              }
            };
            this.workerPortCount++;
            port.postMessage(response);
          });
          fetch(`${this.serviceWorker.scriptURL.slice(0, this.serviceWorker.scriptURL.lastIndexOf("/") + 1).slice(window.location.origin.length)}webtorrent/cancel/`).then((res) => {
            res.body.cancel();
          });
          cb(null, this.serviceWorker);
        }
        get downloadSpeed() {
          return this._downloadSpeed();
        }
        get uploadSpeed() {
          return this._uploadSpeed();
        }
        get progress() {
          const torrents = this.torrents.filter((torrent) => torrent.progress !== 1);
          const downloaded = torrents.reduce((total, torrent) => total + torrent.downloaded, 0);
          const length = torrents.reduce((total, torrent) => total + (torrent.length || 0), 0) || 1;
          return downloaded / length;
        }
        get ratio() {
          const uploaded = this.torrents.reduce((total, torrent) => total + torrent.uploaded, 0);
          const received = this.torrents.reduce((total, torrent) => total + torrent.received, 0) || 1;
          return uploaded / received;
        }
        get(torrentId) {
          if (torrentId instanceof Torrent) {
            if (this.torrents.includes(torrentId))
              return torrentId;
          } else {
            let parsed;
            try {
              parsed = parseTorrent(torrentId);
            } catch (err) {
            }
            if (!parsed)
              return null;
            if (!parsed.infoHash)
              throw new Error("Invalid torrent identifier");
            for (const torrent of this.torrents) {
              if (torrent.infoHash === parsed.infoHash)
                return torrent;
            }
          }
          return null;
        }
        add(torrentId, opts = {}, ontorrent = () => {
        }) {
          if (this.destroyed)
            throw new Error("client is destroyed");
          if (typeof opts === "function")
            [opts, ontorrent] = [{}, opts];
          const onInfoHash = () => {
            if (this.destroyed)
              return;
            for (const t of this.torrents) {
              if (t.infoHash === torrent.infoHash && t !== torrent) {
                torrent._destroy(new Error(`Cannot add duplicate torrent ${torrent.infoHash}`));
                return;
              }
            }
          };
          const onReady = () => {
            if (this.destroyed)
              return;
            ontorrent(torrent);
            this.emit("torrent", torrent);
          };
          function onClose() {
            torrent.removeListener("_infoHash", onInfoHash);
            torrent.removeListener("ready", onReady);
            torrent.removeListener("close", onClose);
          }
          this._debug("add");
          opts = opts ? Object.assign({}, opts) : {};
          const torrent = new Torrent(torrentId, this, opts);
          this.torrents.push(torrent);
          torrent.once("_infoHash", onInfoHash);
          torrent.once("ready", onReady);
          torrent.once("close", onClose);
          return torrent;
        }
        seed(input, opts, onseed) {
          if (this.destroyed)
            throw new Error("client is destroyed");
          if (typeof opts === "function")
            [opts, onseed] = [{}, opts];
          this._debug("seed");
          opts = opts ? Object.assign({}, opts) : {};
          opts.skipVerify = true;
          const isFilePath = typeof input === "string";
          if (isFilePath)
            opts.path = path.dirname(input);
          if (!opts.createdBy)
            opts.createdBy = `WebTorrent/${VERSION_STR}`;
          const onTorrent = (torrent2) => {
            const tasks = [
              (cb) => {
                if (isFilePath || opts.preloadedStore)
                  return cb();
                torrent2.load(streams, cb);
              }
            ];
            if (this.dht) {
              tasks.push((cb) => {
                torrent2.once("dhtAnnounce", cb);
              });
            }
            parallel(tasks, (err) => {
              if (this.destroyed)
                return;
              if (err)
                return torrent2._destroy(err);
              _onseed(torrent2);
            });
          };
          const _onseed = (torrent2) => {
            this._debug("on seed");
            if (typeof onseed === "function")
              onseed(torrent2);
            torrent2.emit("seed");
            this.emit("seed", torrent2);
          };
          const torrent = this.add(null, opts, onTorrent);
          let streams;
          if (isFileList(input))
            input = Array.from(input);
          else if (!Array.isArray(input))
            input = [input];
          parallel(input.map((item) => (cb) => {
            if (!opts.preloadedStore && isReadable(item)) {
              concat2(item, (err, buf) => {
                if (err)
                  return cb(err);
                buf.name = item.name;
                cb(null, buf);
              });
            } else {
              cb(null, item);
            }
          }), (err, input2) => {
            if (this.destroyed)
              return;
            if (err)
              return torrent._destroy(err);
            createTorrent.parseInput(input2, opts, (err2, files) => {
              if (this.destroyed)
                return;
              if (err2)
                return torrent._destroy(err2);
              streams = files.map((file) => file.getStream);
              createTorrent(input2, opts, (err3, torrentBuf) => {
                if (this.destroyed)
                  return;
                if (err3)
                  return torrent._destroy(err3);
                const existingTorrent = this.get(torrentBuf);
                if (existingTorrent) {
                  console.warn("A torrent with the same id is already being seeded");
                  torrent._destroy();
                  if (typeof onseed === "function")
                    onseed(existingTorrent);
                } else {
                  torrent._onTorrentId(torrentBuf);
                }
              });
            });
          });
          return torrent;
        }
        remove(torrentId, opts, cb) {
          if (typeof opts === "function")
            return this.remove(torrentId, null, opts);
          this._debug("remove");
          const torrent = this.get(torrentId);
          if (!torrent)
            throw new Error(`No torrent with id ${torrentId}`);
          this._remove(torrentId, opts, cb);
        }
        _remove(torrentId, opts, cb) {
          if (typeof opts === "function")
            return this._remove(torrentId, null, opts);
          const torrent = this.get(torrentId);
          if (!torrent)
            return;
          this.torrents.splice(this.torrents.indexOf(torrent), 1);
          torrent.destroy(opts, cb);
          if (this.dht) {
            this.dht._tables.remove(torrent.infoHash);
          }
        }
        address() {
          if (!this.listening)
            return null;
          return this._connPool ? this._connPool.tcpServer.address() : { address: "0.0.0.0", family: "IPv4", port: 0 };
        }
        throttleDownload(rate) {
          rate = Number(rate);
          if (isNaN(rate) || !isFinite(rate) || rate < -1)
            return false;
          this._downloadLimit = rate;
          if (this._downloadLimit < 0)
            return this.throttleGroups.down.setEnabled(false);
          this.throttleGroups.down.setEnabled(true);
          this.throttleGroups.down.setRate(this._downloadLimit);
        }
        throttleUpload(rate) {
          rate = Number(rate);
          if (isNaN(rate) || !isFinite(rate) || rate < -1)
            return false;
          this._uploadLimit = rate;
          if (this._uploadLimit < 0)
            return this.throttleGroups.up.setEnabled(false);
          this.throttleGroups.up.setEnabled(true);
          this.throttleGroups.up.setRate(this._uploadLimit);
        }
        destroy(cb) {
          if (this.destroyed)
            throw new Error("client already destroyed");
          this._destroy(null, cb);
        }
        _destroy(err, cb) {
          this._debug("client destroy");
          this.destroyed = true;
          const tasks = this.torrents.map((torrent) => (cb2) => {
            torrent.destroy(cb2);
          });
          if (this._connPool) {
            tasks.push((cb2) => {
              this._connPool.destroy(cb2);
            });
          }
          if (this.dht) {
            tasks.push((cb2) => {
              this.dht.destroy(cb2);
            });
          }
          parallel(tasks, cb);
          if (err)
            this.emit("error", err);
          this.torrents = [];
          this._connPool = null;
          this.dht = null;
          this.throttleGroups.down.destroy();
          this.throttleGroups.up.destroy();
        }
        _onListening() {
          this._debug("listening");
          this.listening = true;
          if (this._connPool) {
            const address = this._connPool.tcpServer.address();
            if (address)
              this.torrentPort = address.port;
          }
          this.emit("listening");
        }
        _debug() {
          const args = [].slice.call(arguments);
          args[0] = `[${this._debugId}] ${args[0]}`;
          debug2(...args);
        }
        _getByHash(infoHashHash) {
          for (const torrent of this.torrents) {
            if (!torrent.infoHashHash) {
              torrent.infoHashHash = sha1.sync(Buffer3.from("72657132" + torrent.infoHash, "hex"));
            }
            if (infoHashHash === torrent.infoHashHash) {
              return torrent;
            }
          }
          return null;
        }
      };
      WebTorrent.WEBRTC_SUPPORT = Peer.WEBRTC_SUPPORT;
      WebTorrent.UTP_SUPPORT = ConnPool.UTP_SUPPORT;
      WebTorrent.VERSION = VERSION2;
      function isReadable(obj) {
        return typeof obj === "object" && obj != null && typeof obj.pipe === "function";
      }
      function isFileList(obj) {
        return typeof FileList !== "undefined" && obj instanceof FileList;
      }
      module.exports = WebTorrent;
    }
  });

  // node_modules/tweetnacl/nacl-fast.js
  var require_nacl_fast = __commonJS({
    "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
      init_esbuild_inject();
      (function(nacl) {
        "use strict";
        var gf = function(init2) {
          var i, r = new Float64Array(16);
          if (init2)
            for (i = 0; i < init2.length; i++)
              r[i] = init2[i];
          return r;
        };
        var randombytes = function() {
          throw new Error("no PRNG");
        };
        var _0 = new Uint8Array(16);
        var _9 = new Uint8Array(32);
        _9[0] = 9;
        var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ts64(x, i, h, l) {
          x[i] = h >> 24 & 255;
          x[i + 1] = h >> 16 & 255;
          x[i + 2] = h >> 8 & 255;
          x[i + 3] = h & 255;
          x[i + 4] = l >> 24 & 255;
          x[i + 5] = l >> 16 & 255;
          x[i + 6] = l >> 8 & 255;
          x[i + 7] = l & 255;
        }
        function vn(x, xi, y, yi, n) {
          var i, d = 0;
          for (i = 0; i < n; i++)
            d |= x[xi + i] ^ y[yi + i];
          return (1 & d - 1 >>> 8) - 1;
        }
        function crypto_verify_16(x, xi, y, yi) {
          return vn(x, xi, y, yi, 16);
        }
        function crypto_verify_32(x, xi, y, yi) {
          return vn(x, xi, y, yi, 32);
        }
        function core_salsa20(o, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0; i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          x0 = x0 + j0 | 0;
          x1 = x1 + j1 | 0;
          x2 = x2 + j2 | 0;
          x3 = x3 + j3 | 0;
          x4 = x4 + j4 | 0;
          x5 = x5 + j5 | 0;
          x6 = x6 + j6 | 0;
          x7 = x7 + j7 | 0;
          x8 = x8 + j8 | 0;
          x9 = x9 + j9 | 0;
          x10 = x10 + j10 | 0;
          x11 = x11 + j11 | 0;
          x12 = x12 + j12 | 0;
          x13 = x13 + j13 | 0;
          x14 = x14 + j14 | 0;
          x15 = x15 + j15 | 0;
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x1 >>> 0 & 255;
          o[5] = x1 >>> 8 & 255;
          o[6] = x1 >>> 16 & 255;
          o[7] = x1 >>> 24 & 255;
          o[8] = x2 >>> 0 & 255;
          o[9] = x2 >>> 8 & 255;
          o[10] = x2 >>> 16 & 255;
          o[11] = x2 >>> 24 & 255;
          o[12] = x3 >>> 0 & 255;
          o[13] = x3 >>> 8 & 255;
          o[14] = x3 >>> 16 & 255;
          o[15] = x3 >>> 24 & 255;
          o[16] = x4 >>> 0 & 255;
          o[17] = x4 >>> 8 & 255;
          o[18] = x4 >>> 16 & 255;
          o[19] = x4 >>> 24 & 255;
          o[20] = x5 >>> 0 & 255;
          o[21] = x5 >>> 8 & 255;
          o[22] = x5 >>> 16 & 255;
          o[23] = x5 >>> 24 & 255;
          o[24] = x6 >>> 0 & 255;
          o[25] = x6 >>> 8 & 255;
          o[26] = x6 >>> 16 & 255;
          o[27] = x6 >>> 24 & 255;
          o[28] = x7 >>> 0 & 255;
          o[29] = x7 >>> 8 & 255;
          o[30] = x7 >>> 16 & 255;
          o[31] = x7 >>> 24 & 255;
          o[32] = x8 >>> 0 & 255;
          o[33] = x8 >>> 8 & 255;
          o[34] = x8 >>> 16 & 255;
          o[35] = x8 >>> 24 & 255;
          o[36] = x9 >>> 0 & 255;
          o[37] = x9 >>> 8 & 255;
          o[38] = x9 >>> 16 & 255;
          o[39] = x9 >>> 24 & 255;
          o[40] = x10 >>> 0 & 255;
          o[41] = x10 >>> 8 & 255;
          o[42] = x10 >>> 16 & 255;
          o[43] = x10 >>> 24 & 255;
          o[44] = x11 >>> 0 & 255;
          o[45] = x11 >>> 8 & 255;
          o[46] = x11 >>> 16 & 255;
          o[47] = x11 >>> 24 & 255;
          o[48] = x12 >>> 0 & 255;
          o[49] = x12 >>> 8 & 255;
          o[50] = x12 >>> 16 & 255;
          o[51] = x12 >>> 24 & 255;
          o[52] = x13 >>> 0 & 255;
          o[53] = x13 >>> 8 & 255;
          o[54] = x13 >>> 16 & 255;
          o[55] = x13 >>> 24 & 255;
          o[56] = x14 >>> 0 & 255;
          o[57] = x14 >>> 8 & 255;
          o[58] = x14 >>> 16 & 255;
          o[59] = x14 >>> 24 & 255;
          o[60] = x15 >>> 0 & 255;
          o[61] = x15 >>> 8 & 255;
          o[62] = x15 >>> 16 & 255;
          o[63] = x15 >>> 24 & 255;
        }
        function core_hsalsa20(o, p, k, c) {
          var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
          var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
          for (var i = 0; i < 20; i += 2) {
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
          }
          o[0] = x0 >>> 0 & 255;
          o[1] = x0 >>> 8 & 255;
          o[2] = x0 >>> 16 & 255;
          o[3] = x0 >>> 24 & 255;
          o[4] = x5 >>> 0 & 255;
          o[5] = x5 >>> 8 & 255;
          o[6] = x5 >>> 16 & 255;
          o[7] = x5 >>> 24 & 255;
          o[8] = x10 >>> 0 & 255;
          o[9] = x10 >>> 8 & 255;
          o[10] = x10 >>> 16 & 255;
          o[11] = x10 >>> 24 & 255;
          o[12] = x15 >>> 0 & 255;
          o[13] = x15 >>> 8 & 255;
          o[14] = x15 >>> 16 & 255;
          o[15] = x15 >>> 24 & 255;
          o[16] = x6 >>> 0 & 255;
          o[17] = x6 >>> 8 & 255;
          o[18] = x6 >>> 16 & 255;
          o[19] = x6 >>> 24 & 255;
          o[20] = x7 >>> 0 & 255;
          o[21] = x7 >>> 8 & 255;
          o[22] = x7 >>> 16 & 255;
          o[23] = x7 >>> 24 & 255;
          o[24] = x8 >>> 0 & 255;
          o[25] = x8 >>> 8 & 255;
          o[26] = x8 >>> 16 & 255;
          o[27] = x8 >>> 24 & 255;
          o[28] = x9 >>> 0 & 255;
          o[29] = x9 >>> 8 & 255;
          o[30] = x9 >>> 16 & 255;
          o[31] = x9 >>> 24 & 255;
        }
        function crypto_core_salsa20(out, inp, k, c) {
          core_salsa20(out, inp, k, c);
        }
        function crypto_core_hsalsa20(out, inp, k, c) {
          core_hsalsa20(out, inp, k, c);
        }
        var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0; i < 16; i++)
            z[i] = 0;
          for (i = 0; i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < 64; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
            u = 1;
            for (i = 8; i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
            mpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < b; i++)
              c[cpos + i] = m[mpos + i] ^ x[i];
          }
          return 0;
        }
        function crypto_stream_salsa20(c, cpos, b, n, k) {
          var z = new Uint8Array(16), x = new Uint8Array(64);
          var u, i;
          for (i = 0; i < 16; i++)
            z[i] = 0;
          for (i = 0; i < 8; i++)
            z[i] = n[i];
          while (b >= 64) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < 64; i++)
              c[cpos + i] = x[i];
            u = 1;
            for (i = 8; i < 16; i++) {
              u = u + (z[i] & 255) | 0;
              z[i] = u & 255;
              u >>>= 8;
            }
            b -= 64;
            cpos += 64;
          }
          if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for (i = 0; i < b; i++)
              c[cpos + i] = x[i];
          }
          return 0;
        }
        function crypto_stream(c, cpos, d, n, k) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0; i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20(c, cpos, d, sn, s);
        }
        function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
          var s = new Uint8Array(32);
          crypto_core_hsalsa20(s, n, k, sigma);
          var sn = new Uint8Array(8);
          for (var i = 0; i < 8; i++)
            sn[i] = n[i + 16];
          return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
        }
        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16);
          this.r = new Uint16Array(10);
          this.h = new Uint16Array(10);
          this.pad = new Uint16Array(8);
          this.leftover = 0;
          this.fin = 0;
          var t0, t1, t2, t3, t4, t5, t6, t7;
          t0 = key[0] & 255 | (key[1] & 255) << 8;
          this.r[0] = t0 & 8191;
          t1 = key[2] & 255 | (key[3] & 255) << 8;
          this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          t2 = key[4] & 255 | (key[5] & 255) << 8;
          this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          t3 = key[6] & 255 | (key[7] & 255) << 8;
          this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          t4 = key[8] & 255 | (key[9] & 255) << 8;
          this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this.r[5] = t4 >>> 1 & 8190;
          t5 = key[10] & 255 | (key[11] & 255) << 8;
          this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          t6 = key[12] & 255 | (key[13] & 255) << 8;
          this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          t7 = key[14] & 255 | (key[15] & 255) << 8;
          this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this.r[9] = t7 >>> 5 & 127;
          this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
          this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
          this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
          this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
          this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
          this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
          this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
          this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
        };
        poly1305.prototype.blocks = function(m, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11;
          var t0, t1, t2, t3, t4, t5, t6, t7, c;
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
          var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
          var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
          while (bytes >= 16) {
            t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
            h0 += t0 & 8191;
            t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            c = 0;
            d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 8191;
            d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 8191;
            d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 8191;
            d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 8191;
            d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 8191;
            d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 8191;
            d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 8191;
            d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 8191;
            d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 8191;
            d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 8191;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 8191;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this.h[0] = h0;
          this.h[1] = h1;
          this.h[2] = h2;
          this.h[3] = h3;
          this.h[4] = h4;
          this.h[5] = h5;
          this.h[6] = h6;
          this.h[7] = h7;
          this.h[8] = h8;
          this.h[9] = h9;
        };
        poly1305.prototype.finish = function(mac, macpos) {
          var g = new Uint16Array(10);
          var c, mask, f, i;
          if (this.leftover) {
            i = this.leftover;
            this.buffer[i++] = 1;
            for (; i < 16; i++)
              this.buffer[i] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
          }
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          for (i = 2; i < 10; i++) {
            this.h[i] += c;
            c = this.h[i] >>> 13;
            this.h[i] &= 8191;
          }
          this.h[0] += c * 5;
          c = this.h[0] >>> 13;
          this.h[0] &= 8191;
          this.h[1] += c;
          c = this.h[1] >>> 13;
          this.h[1] &= 8191;
          this.h[2] += c;
          g[0] = this.h[0] + 5;
          c = g[0] >>> 13;
          g[0] &= 8191;
          for (i = 1; i < 10; i++) {
            g[i] = this.h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 8191;
          }
          g[9] -= 1 << 13;
          mask = (c ^ 1) - 1;
          for (i = 0; i < 10; i++)
            g[i] &= mask;
          mask = ~mask;
          for (i = 0; i < 10; i++)
            this.h[i] = this.h[i] & mask | g[i];
          this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
          this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
          this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
          this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
          this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
          this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
          this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
          this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
          f = this.h[0] + this.pad[0];
          this.h[0] = f & 65535;
          for (i = 1; i < 8; i++) {
            f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
            this.h[i] = f & 65535;
          }
          mac[macpos + 0] = this.h[0] >>> 0 & 255;
          mac[macpos + 1] = this.h[0] >>> 8 & 255;
          mac[macpos + 2] = this.h[1] >>> 0 & 255;
          mac[macpos + 3] = this.h[1] >>> 8 & 255;
          mac[macpos + 4] = this.h[2] >>> 0 & 255;
          mac[macpos + 5] = this.h[2] >>> 8 & 255;
          mac[macpos + 6] = this.h[3] >>> 0 & 255;
          mac[macpos + 7] = this.h[3] >>> 8 & 255;
          mac[macpos + 8] = this.h[4] >>> 0 & 255;
          mac[macpos + 9] = this.h[4] >>> 8 & 255;
          mac[macpos + 10] = this.h[5] >>> 0 & 255;
          mac[macpos + 11] = this.h[5] >>> 8 & 255;
          mac[macpos + 12] = this.h[6] >>> 0 & 255;
          mac[macpos + 13] = this.h[6] >>> 8 & 255;
          mac[macpos + 14] = this.h[7] >>> 0 & 255;
          mac[macpos + 15] = this.h[7] >>> 8 & 255;
        };
        poly1305.prototype.update = function(m, mpos, bytes) {
          var i, want;
          if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes)
              want = bytes;
            for (i = 0; i < want; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16)
              return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (i = 0; i < bytes; i++)
              this.buffer[this.leftover + i] = m[mpos + i];
            this.leftover += bytes;
          }
        };
        function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
          var s = new poly1305(k);
          s.update(m, mpos, n);
          s.finish(out, outpos);
          return 0;
        }
        function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
          var x = new Uint8Array(16);
          crypto_onetimeauth(x, 0, m, mpos, n, k);
          return crypto_verify_16(h, hpos, x, 0);
        }
        function crypto_secretbox(c, m, d, n, k) {
          var i;
          if (d < 32)
            return -1;
          crypto_stream_xor(c, 0, m, 0, d, n, k);
          crypto_onetimeauth(c, 16, c, 32, d - 32, c);
          for (i = 0; i < 16; i++)
            c[i] = 0;
          return 0;
        }
        function crypto_secretbox_open(m, c, d, n, k) {
          var i;
          var x = new Uint8Array(32);
          if (d < 32)
            return -1;
          crypto_stream(x, 0, 32, n, k);
          if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
            return -1;
          crypto_stream_xor(m, 0, c, 0, d, n, k);
          for (i = 0; i < 32; i++)
            m[i] = 0;
          return 0;
        }
        function set25519(r, a) {
          var i;
          for (i = 0; i < 16; i++)
            r[i] = a[i] | 0;
        }
        function car25519(o) {
          var i, v, c = 1;
          for (i = 0; i < 16; i++) {
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
          }
          o[0] += c - 1 + 37 * (c - 1);
        }
        function sel25519(p, q, b) {
          var t, c = ~(b - 1);
          for (var i = 0; i < 16; i++) {
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
          }
        }
        function pack25519(o, n) {
          var i, j, b;
          var m = gf(), t = gf();
          for (i = 0; i < 16; i++)
            t[i] = n[i];
          car25519(t);
          car25519(t);
          car25519(t);
          for (j = 0; j < 2; j++) {
            m[0] = t[0] - 65517;
            for (i = 1; i < 15; i++) {
              m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
              m[i - 1] &= 65535;
            }
            m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 65535;
            sel25519(t, m, 1 - b);
          }
          for (i = 0; i < 16; i++) {
            o[2 * i] = t[i] & 255;
            o[2 * i + 1] = t[i] >> 8;
          }
        }
        function neq25519(a, b) {
          var c = new Uint8Array(32), d = new Uint8Array(32);
          pack25519(c, a);
          pack25519(d, b);
          return crypto_verify_32(c, 0, d, 0);
        }
        function par25519(a) {
          var d = new Uint8Array(32);
          pack25519(d, a);
          return d[0] & 1;
        }
        function unpack25519(o, n) {
          var i;
          for (i = 0; i < 16; i++)
            o[i] = n[2 * i] + (n[2 * i + 1] << 8);
          o[15] &= 32767;
        }
        function A(o, a, b) {
          for (var i = 0; i < 16; i++)
            o[i] = a[i] + b[i];
        }
        function Z(o, a, b) {
          for (var i = 0; i < 16; i++)
            o[i] = a[i] - b[i];
        }
        function M(o, a, b) {
          var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
          v = a[0];
          t0 += v * b0;
          t1 += v * b1;
          t2 += v * b2;
          t3 += v * b3;
          t4 += v * b4;
          t5 += v * b5;
          t6 += v * b6;
          t7 += v * b7;
          t8 += v * b8;
          t9 += v * b9;
          t10 += v * b10;
          t11 += v * b11;
          t12 += v * b12;
          t13 += v * b13;
          t14 += v * b14;
          t15 += v * b15;
          v = a[1];
          t1 += v * b0;
          t2 += v * b1;
          t3 += v * b2;
          t4 += v * b3;
          t5 += v * b4;
          t6 += v * b5;
          t7 += v * b6;
          t8 += v * b7;
          t9 += v * b8;
          t10 += v * b9;
          t11 += v * b10;
          t12 += v * b11;
          t13 += v * b12;
          t14 += v * b13;
          t15 += v * b14;
          t16 += v * b15;
          v = a[2];
          t2 += v * b0;
          t3 += v * b1;
          t4 += v * b2;
          t5 += v * b3;
          t6 += v * b4;
          t7 += v * b5;
          t8 += v * b6;
          t9 += v * b7;
          t10 += v * b8;
          t11 += v * b9;
          t12 += v * b10;
          t13 += v * b11;
          t14 += v * b12;
          t15 += v * b13;
          t16 += v * b14;
          t17 += v * b15;
          v = a[3];
          t3 += v * b0;
          t4 += v * b1;
          t5 += v * b2;
          t6 += v * b3;
          t7 += v * b4;
          t8 += v * b5;
          t9 += v * b6;
          t10 += v * b7;
          t11 += v * b8;
          t12 += v * b9;
          t13 += v * b10;
          t14 += v * b11;
          t15 += v * b12;
          t16 += v * b13;
          t17 += v * b14;
          t18 += v * b15;
          v = a[4];
          t4 += v * b0;
          t5 += v * b1;
          t6 += v * b2;
          t7 += v * b3;
          t8 += v * b4;
          t9 += v * b5;
          t10 += v * b6;
          t11 += v * b7;
          t12 += v * b8;
          t13 += v * b9;
          t14 += v * b10;
          t15 += v * b11;
          t16 += v * b12;
          t17 += v * b13;
          t18 += v * b14;
          t19 += v * b15;
          v = a[5];
          t5 += v * b0;
          t6 += v * b1;
          t7 += v * b2;
          t8 += v * b3;
          t9 += v * b4;
          t10 += v * b5;
          t11 += v * b6;
          t12 += v * b7;
          t13 += v * b8;
          t14 += v * b9;
          t15 += v * b10;
          t16 += v * b11;
          t17 += v * b12;
          t18 += v * b13;
          t19 += v * b14;
          t20 += v * b15;
          v = a[6];
          t6 += v * b0;
          t7 += v * b1;
          t8 += v * b2;
          t9 += v * b3;
          t10 += v * b4;
          t11 += v * b5;
          t12 += v * b6;
          t13 += v * b7;
          t14 += v * b8;
          t15 += v * b9;
          t16 += v * b10;
          t17 += v * b11;
          t18 += v * b12;
          t19 += v * b13;
          t20 += v * b14;
          t21 += v * b15;
          v = a[7];
          t7 += v * b0;
          t8 += v * b1;
          t9 += v * b2;
          t10 += v * b3;
          t11 += v * b4;
          t12 += v * b5;
          t13 += v * b6;
          t14 += v * b7;
          t15 += v * b8;
          t16 += v * b9;
          t17 += v * b10;
          t18 += v * b11;
          t19 += v * b12;
          t20 += v * b13;
          t21 += v * b14;
          t22 += v * b15;
          v = a[8];
          t8 += v * b0;
          t9 += v * b1;
          t10 += v * b2;
          t11 += v * b3;
          t12 += v * b4;
          t13 += v * b5;
          t14 += v * b6;
          t15 += v * b7;
          t16 += v * b8;
          t17 += v * b9;
          t18 += v * b10;
          t19 += v * b11;
          t20 += v * b12;
          t21 += v * b13;
          t22 += v * b14;
          t23 += v * b15;
          v = a[9];
          t9 += v * b0;
          t10 += v * b1;
          t11 += v * b2;
          t12 += v * b3;
          t13 += v * b4;
          t14 += v * b5;
          t15 += v * b6;
          t16 += v * b7;
          t17 += v * b8;
          t18 += v * b9;
          t19 += v * b10;
          t20 += v * b11;
          t21 += v * b12;
          t22 += v * b13;
          t23 += v * b14;
          t24 += v * b15;
          v = a[10];
          t10 += v * b0;
          t11 += v * b1;
          t12 += v * b2;
          t13 += v * b3;
          t14 += v * b4;
          t15 += v * b5;
          t16 += v * b6;
          t17 += v * b7;
          t18 += v * b8;
          t19 += v * b9;
          t20 += v * b10;
          t21 += v * b11;
          t22 += v * b12;
          t23 += v * b13;
          t24 += v * b14;
          t25 += v * b15;
          v = a[11];
          t11 += v * b0;
          t12 += v * b1;
          t13 += v * b2;
          t14 += v * b3;
          t15 += v * b4;
          t16 += v * b5;
          t17 += v * b6;
          t18 += v * b7;
          t19 += v * b8;
          t20 += v * b9;
          t21 += v * b10;
          t22 += v * b11;
          t23 += v * b12;
          t24 += v * b13;
          t25 += v * b14;
          t26 += v * b15;
          v = a[12];
          t12 += v * b0;
          t13 += v * b1;
          t14 += v * b2;
          t15 += v * b3;
          t16 += v * b4;
          t17 += v * b5;
          t18 += v * b6;
          t19 += v * b7;
          t20 += v * b8;
          t21 += v * b9;
          t22 += v * b10;
          t23 += v * b11;
          t24 += v * b12;
          t25 += v * b13;
          t26 += v * b14;
          t27 += v * b15;
          v = a[13];
          t13 += v * b0;
          t14 += v * b1;
          t15 += v * b2;
          t16 += v * b3;
          t17 += v * b4;
          t18 += v * b5;
          t19 += v * b6;
          t20 += v * b7;
          t21 += v * b8;
          t22 += v * b9;
          t23 += v * b10;
          t24 += v * b11;
          t25 += v * b12;
          t26 += v * b13;
          t27 += v * b14;
          t28 += v * b15;
          v = a[14];
          t14 += v * b0;
          t15 += v * b1;
          t16 += v * b2;
          t17 += v * b3;
          t18 += v * b4;
          t19 += v * b5;
          t20 += v * b6;
          t21 += v * b7;
          t22 += v * b8;
          t23 += v * b9;
          t24 += v * b10;
          t25 += v * b11;
          t26 += v * b12;
          t27 += v * b13;
          t28 += v * b14;
          t29 += v * b15;
          v = a[15];
          t15 += v * b0;
          t16 += v * b1;
          t17 += v * b2;
          t18 += v * b3;
          t19 += v * b4;
          t20 += v * b5;
          t21 += v * b6;
          t22 += v * b7;
          t23 += v * b8;
          t24 += v * b9;
          t25 += v * b10;
          t26 += v * b11;
          t27 += v * b12;
          t28 += v * b13;
          t29 += v * b14;
          t30 += v * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          c = 1;
          v = t0 + c + 65535;
          c = Math.floor(v / 65536);
          t0 = v - c * 65536;
          v = t1 + c + 65535;
          c = Math.floor(v / 65536);
          t1 = v - c * 65536;
          v = t2 + c + 65535;
          c = Math.floor(v / 65536);
          t2 = v - c * 65536;
          v = t3 + c + 65535;
          c = Math.floor(v / 65536);
          t3 = v - c * 65536;
          v = t4 + c + 65535;
          c = Math.floor(v / 65536);
          t4 = v - c * 65536;
          v = t5 + c + 65535;
          c = Math.floor(v / 65536);
          t5 = v - c * 65536;
          v = t6 + c + 65535;
          c = Math.floor(v / 65536);
          t6 = v - c * 65536;
          v = t7 + c + 65535;
          c = Math.floor(v / 65536);
          t7 = v - c * 65536;
          v = t8 + c + 65535;
          c = Math.floor(v / 65536);
          t8 = v - c * 65536;
          v = t9 + c + 65535;
          c = Math.floor(v / 65536);
          t9 = v - c * 65536;
          v = t10 + c + 65535;
          c = Math.floor(v / 65536);
          t10 = v - c * 65536;
          v = t11 + c + 65535;
          c = Math.floor(v / 65536);
          t11 = v - c * 65536;
          v = t12 + c + 65535;
          c = Math.floor(v / 65536);
          t12 = v - c * 65536;
          v = t13 + c + 65535;
          c = Math.floor(v / 65536);
          t13 = v - c * 65536;
          v = t14 + c + 65535;
          c = Math.floor(v / 65536);
          t14 = v - c * 65536;
          v = t15 + c + 65535;
          c = Math.floor(v / 65536);
          t15 = v - c * 65536;
          t0 += c - 1 + 37 * (c - 1);
          o[0] = t0;
          o[1] = t1;
          o[2] = t2;
          o[3] = t3;
          o[4] = t4;
          o[5] = t5;
          o[6] = t6;
          o[7] = t7;
          o[8] = t8;
          o[9] = t9;
          o[10] = t10;
          o[11] = t11;
          o[12] = t12;
          o[13] = t13;
          o[14] = t14;
          o[15] = t15;
        }
        function S(o, a) {
          M(o, a, a);
        }
        function inv25519(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; a++)
            c[a] = i[a];
          for (a = 253; a >= 0; a--) {
            S(c, c);
            if (a !== 2 && a !== 4)
              M(c, c, i);
          }
          for (a = 0; a < 16; a++)
            o[a] = c[a];
        }
        function pow2523(o, i) {
          var c = gf();
          var a;
          for (a = 0; a < 16; a++)
            c[a] = i[a];
          for (a = 250; a >= 0; a--) {
            S(c, c);
            if (a !== 1)
              M(c, c, i);
          }
          for (a = 0; a < 16; a++)
            o[a] = c[a];
        }
        function crypto_scalarmult(q, n, p) {
          var z = new Uint8Array(32);
          var x = new Float64Array(80), r, i;
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
          for (i = 0; i < 31; i++)
            z[i] = n[i];
          z[31] = n[31] & 127 | 64;
          z[0] &= 248;
          unpack25519(x, p);
          for (i = 0; i < 16; i++) {
            b[i] = x[i];
            d[i] = a[i] = c[i] = 0;
          }
          a[0] = d[0] = 1;
          for (i = 254; i >= 0; --i) {
            r = z[i >>> 3] >>> (i & 7) & 1;
            sel25519(a, b, r);
            sel25519(c, d, r);
            A(e, a, c);
            Z(a, a, c);
            A(c, b, d);
            Z(b, b, d);
            S(d, e);
            S(f, a);
            M(a, c, a);
            M(c, b, e);
            A(e, a, c);
            Z(a, a, c);
            S(b, a);
            Z(c, d, f);
            M(a, c, _121665);
            A(a, a, d);
            M(c, c, a);
            M(a, d, f);
            M(d, b, x);
            S(b, e);
            sel25519(a, b, r);
            sel25519(c, d, r);
          }
          for (i = 0; i < 16; i++) {
            x[i + 16] = a[i];
            x[i + 32] = c[i];
            x[i + 48] = b[i];
            x[i + 64] = d[i];
          }
          var x32 = x.subarray(32);
          var x16 = x.subarray(16);
          inv25519(x32, x32);
          M(x16, x16, x32);
          pack25519(q, x16);
          return 0;
        }
        function crypto_scalarmult_base(q, n) {
          return crypto_scalarmult(q, n, _9);
        }
        function crypto_box_keypair(y, x) {
          randombytes(x, 32);
          return crypto_scalarmult_base(y, x);
        }
        function crypto_box_beforenm(k, y, x) {
          var s = new Uint8Array(32);
          crypto_scalarmult(s, x, y);
          return crypto_core_hsalsa20(k, _0, s, sigma);
        }
        var crypto_box_afternm = crypto_secretbox;
        var crypto_box_open_afternm = crypto_secretbox_open;
        function crypto_box(c, m, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_afternm(c, m, d, n, k);
        }
        function crypto_box_open(m, c, d, n, y, x) {
          var k = new Uint8Array(32);
          crypto_box_beforenm(k, y, x);
          return crypto_box_open_afternm(m, c, d, n, k);
        }
        var K = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        function crypto_hashblocks_hl(hh, hl, m, n) {
          var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
          var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
          var pos = 0;
          while (n >= 128) {
            for (i = 0; i < 16; i++) {
              j = 8 * i + pos;
              wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
              wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
            }
            for (i = 0; i < 80; i++) {
              bh0 = ah0;
              bh1 = ah1;
              bh2 = ah2;
              bh3 = ah3;
              bh4 = ah4;
              bh5 = ah5;
              bh6 = ah6;
              bh7 = ah7;
              bl0 = al0;
              bl1 = al1;
              bl2 = al2;
              bl3 = al3;
              bl4 = al4;
              bl5 = al5;
              bl6 = al6;
              bl7 = al7;
              h = ah7;
              l = al7;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
              l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah4 & ah5 ^ ~ah4 & ah6;
              l = al4 & al5 ^ ~al4 & al6;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = K[i * 2];
              l = K[i * 2 + 1];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = wh[i % 16];
              l = wl[i % 16];
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              th = c & 65535 | d << 16;
              tl = a & 65535 | b << 16;
              h = th;
              l = tl;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
              l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
              l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh7 = c & 65535 | d << 16;
              bl7 = a & 65535 | b << 16;
              h = bh3;
              l = bl3;
              a = l & 65535;
              b = l >>> 16;
              c = h & 65535;
              d = h >>> 16;
              h = th;
              l = tl;
              a += l & 65535;
              b += l >>> 16;
              c += h & 65535;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              bh3 = c & 65535 | d << 16;
              bl3 = a & 65535 | b << 16;
              ah1 = bh0;
              ah2 = bh1;
              ah3 = bh2;
              ah4 = bh3;
              ah5 = bh4;
              ah6 = bh5;
              ah7 = bh6;
              ah0 = bh7;
              al1 = bl0;
              al2 = bl1;
              al3 = bl2;
              al4 = bl3;
              al5 = bl4;
              al6 = bl5;
              al7 = bl6;
              al0 = bl7;
              if (i % 16 === 15) {
                for (j = 0; j < 16; j++) {
                  h = wh[j];
                  l = wl[j];
                  a = l & 65535;
                  b = l >>> 16;
                  c = h & 65535;
                  d = h >>> 16;
                  h = wh[(j + 9) % 16];
                  l = wl[(j + 9) % 16];
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 1) % 16];
                  tl = wl[(j + 1) % 16];
                  h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                  l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  th = wh[(j + 14) % 16];
                  tl = wl[(j + 14) % 16];
                  h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                  l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                  a += l & 65535;
                  b += l >>> 16;
                  c += h & 65535;
                  d += h >>> 16;
                  b += a >>> 16;
                  c += b >>> 16;
                  d += c >>> 16;
                  wh[j] = c & 65535 | d << 16;
                  wl[j] = a & 65535 | b << 16;
                }
              }
            }
            h = ah0;
            l = al0;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[0];
            l = hl[0];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[0] = ah0 = c & 65535 | d << 16;
            hl[0] = al0 = a & 65535 | b << 16;
            h = ah1;
            l = al1;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[1];
            l = hl[1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[1] = ah1 = c & 65535 | d << 16;
            hl[1] = al1 = a & 65535 | b << 16;
            h = ah2;
            l = al2;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[2];
            l = hl[2];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[2] = ah2 = c & 65535 | d << 16;
            hl[2] = al2 = a & 65535 | b << 16;
            h = ah3;
            l = al3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[3];
            l = hl[3];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[3] = ah3 = c & 65535 | d << 16;
            hl[3] = al3 = a & 65535 | b << 16;
            h = ah4;
            l = al4;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[4];
            l = hl[4];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[4] = ah4 = c & 65535 | d << 16;
            hl[4] = al4 = a & 65535 | b << 16;
            h = ah5;
            l = al5;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[5];
            l = hl[5];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[5] = ah5 = c & 65535 | d << 16;
            hl[5] = al5 = a & 65535 | b << 16;
            h = ah6;
            l = al6;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[6];
            l = hl[6];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[6] = ah6 = c & 65535 | d << 16;
            hl[6] = al6 = a & 65535 | b << 16;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = hh[7];
            l = hl[7];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[7] = ah7 = c & 65535 | d << 16;
            hl[7] = al7 = a & 65535 | b << 16;
            pos += 128;
            n -= 128;
          }
          return n;
        }
        function crypto_hash(out, m, n) {
          var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
          hh[0] = 1779033703;
          hh[1] = 3144134277;
          hh[2] = 1013904242;
          hh[3] = 2773480762;
          hh[4] = 1359893119;
          hh[5] = 2600822924;
          hh[6] = 528734635;
          hh[7] = 1541459225;
          hl[0] = 4089235720;
          hl[1] = 2227873595;
          hl[2] = 4271175723;
          hl[3] = 1595750129;
          hl[4] = 2917565137;
          hl[5] = 725511199;
          hl[6] = 4215389547;
          hl[7] = 327033209;
          crypto_hashblocks_hl(hh, hl, m, n);
          n %= 128;
          for (i = 0; i < n; i++)
            x[i] = m[b - n + i];
          x[n] = 128;
          n = 256 - 128 * (n < 112 ? 1 : 0);
          x[n - 9] = 0;
          ts64(x, n - 8, b / 536870912 | 0, b << 3);
          crypto_hashblocks_hl(hh, hl, x, n);
          for (i = 0; i < 8; i++)
            ts64(out, 8 * i, hh[i], hl[i]);
          return 0;
        }
        function add(p, q) {
          var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
          Z(a, p[1], p[0]);
          Z(t, q[1], q[0]);
          M(a, a, t);
          A(b, p[0], p[1]);
          A(t, q[0], q[1]);
          M(b, b, t);
          M(c, p[3], q[3]);
          M(c, c, D2);
          M(d, p[2], q[2]);
          A(d, d, d);
          Z(e, b, a);
          Z(f, d, c);
          A(g, d, c);
          A(h, b, a);
          M(p[0], e, f);
          M(p[1], h, g);
          M(p[2], g, f);
          M(p[3], e, h);
        }
        function cswap(p, q, b) {
          var i;
          for (i = 0; i < 4; i++) {
            sel25519(p[i], q[i], b);
          }
        }
        function pack(r, p) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p[2]);
          M(tx, p[0], zi);
          M(ty, p[1], zi);
          pack25519(r, ty);
          r[31] ^= par25519(tx) << 7;
        }
        function scalarmult(p, q, s) {
          var b, i;
          set25519(p[0], gf0);
          set25519(p[1], gf1);
          set25519(p[2], gf1);
          set25519(p[3], gf0);
          for (i = 255; i >= 0; --i) {
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
          }
        }
        function scalarbase(p, s) {
          var q = [gf(), gf(), gf(), gf()];
          set25519(q[0], X);
          set25519(q[1], Y);
          set25519(q[2], gf1);
          M(q[3], X, Y);
          scalarmult(p, q, s);
        }
        function crypto_sign_keypair(pk, sk, seeded) {
          var d = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()];
          var i;
          if (!seeded)
            randombytes(sk, 32);
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          scalarbase(p, d);
          pack(pk, p);
          for (i = 0; i < 32; i++)
            sk[i + 32] = pk[i];
          return 0;
        }
        var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function modL(r, x) {
          var carry, i, j, k;
          for (i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
              x[j] += carry - 16 * x[i] * L[j - (i - 32)];
              carry = Math.floor((x[j] + 128) / 256);
              x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
          }
          carry = 0;
          for (j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
          }
          for (j = 0; j < 32; j++)
            x[j] -= carry * L[j];
          for (i = 0; i < 32; i++) {
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
          }
        }
        function reduce(r) {
          var x = new Float64Array(64), i;
          for (i = 0; i < 64; i++)
            x[i] = r[i];
          for (i = 0; i < 64; i++)
            r[i] = 0;
          modL(r, x);
        }
        function crypto_sign(sm, m, n, sk) {
          var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
          var i, j, x = new Float64Array(64);
          var p = [gf(), gf(), gf(), gf()];
          crypto_hash(d, sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          var smlen = n + 64;
          for (i = 0; i < n; i++)
            sm[64 + i] = m[i];
          for (i = 0; i < 32; i++)
            sm[32 + i] = d[32 + i];
          crypto_hash(r, sm.subarray(32), n + 32);
          reduce(r);
          scalarbase(p, r);
          pack(sm, p);
          for (i = 32; i < 64; i++)
            sm[i] = sk[i];
          crypto_hash(h, sm, n + 64);
          reduce(h);
          for (i = 0; i < 64; i++)
            x[i] = 0;
          for (i = 0; i < 32; i++)
            x[i] = r[i];
          for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
              x[i + j] += h[i] * d[j];
            }
          }
          modL(sm.subarray(32), x);
          return smlen;
        }
        function unpackneg(r, p) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r[2], gf1);
          unpack25519(r[1], p);
          S(num, r[1]);
          M(den, num, D);
          Z(num, num, r[2]);
          A(den, r[2], den);
          S(den2, den);
          S(den4, den2);
          M(den6, den4, den2);
          M(t, den6, num);
          M(t, t, den);
          pow2523(t, t);
          M(t, t, num);
          M(t, t, den);
          M(t, t, den);
          M(r[0], t, den);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            M(r[0], r[0], I);
          S(chk, r[0]);
          M(chk, chk, den);
          if (neq25519(chk, num))
            return -1;
          if (par25519(r[0]) === p[31] >> 7)
            Z(r[0], gf0, r[0]);
          M(r[3], r[0], r[1]);
          return 0;
        }
        function crypto_sign_open(m, sm, n, pk) {
          var i;
          var t = new Uint8Array(32), h = new Uint8Array(64);
          var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
          if (n < 64)
            return -1;
          if (unpackneg(q, pk))
            return -1;
          for (i = 0; i < n; i++)
            m[i] = sm[i];
          for (i = 0; i < 32; i++)
            m[i + 32] = pk[i];
          crypto_hash(h, m, n);
          reduce(h);
          scalarmult(p, q, h);
          scalarbase(q, sm.subarray(32));
          add(p, q);
          pack(t, p);
          n -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i = 0; i < n; i++)
              m[i] = 0;
            return -1;
          }
          for (i = 0; i < n; i++)
            m[i] = sm[i + 64];
          return n;
        }
        var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
        nacl.lowlevel = {
          crypto_core_hsalsa20,
          crypto_stream_xor,
          crypto_stream,
          crypto_stream_salsa20_xor,
          crypto_stream_salsa20,
          crypto_onetimeauth,
          crypto_onetimeauth_verify,
          crypto_verify_16,
          crypto_verify_32,
          crypto_secretbox,
          crypto_secretbox_open,
          crypto_scalarmult,
          crypto_scalarmult_base,
          crypto_box_beforenm,
          crypto_box_afternm,
          crypto_box,
          crypto_box_open,
          crypto_box_keypair,
          crypto_hash,
          crypto_sign,
          crypto_sign_keypair,
          crypto_sign_open,
          crypto_secretbox_KEYBYTES,
          crypto_secretbox_NONCEBYTES,
          crypto_secretbox_ZEROBYTES,
          crypto_secretbox_BOXZEROBYTES,
          crypto_scalarmult_BYTES,
          crypto_scalarmult_SCALARBYTES,
          crypto_box_PUBLICKEYBYTES,
          crypto_box_SECRETKEYBYTES,
          crypto_box_BEFORENMBYTES,
          crypto_box_NONCEBYTES,
          crypto_box_ZEROBYTES,
          crypto_box_BOXZEROBYTES,
          crypto_sign_BYTES,
          crypto_sign_PUBLICKEYBYTES,
          crypto_sign_SECRETKEYBYTES,
          crypto_sign_SEEDBYTES,
          crypto_hash_BYTES,
          gf,
          D,
          L,
          pack25519,
          unpack25519,
          M,
          A,
          S,
          Z,
          pow2523,
          add,
          set25519,
          modL,
          scalarmult,
          scalarbase
        };
        function checkLengths(k, n) {
          if (k.length !== crypto_secretbox_KEYBYTES)
            throw new Error("bad key size");
          if (n.length !== crypto_secretbox_NONCEBYTES)
            throw new Error("bad nonce size");
        }
        function checkBoxLengths(pk, sk) {
          if (pk.length !== crypto_box_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          if (sk.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
        }
        function checkArrayTypes() {
          for (var i = 0; i < arguments.length; i++) {
            if (!(arguments[i] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
          }
        }
        function cleanup(arr) {
          for (var i = 0; i < arr.length; i++)
            arr[i] = 0;
        }
        nacl.randomBytes = function(n) {
          var b = new Uint8Array(n);
          randombytes(b, n);
          return b;
        };
        nacl.secretbox = function(msg, nonce, key) {
          checkArrayTypes(msg, nonce, key);
          checkLengths(key, nonce);
          var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
          var c = new Uint8Array(m.length);
          for (var i = 0; i < msg.length; i++)
            m[i + crypto_secretbox_ZEROBYTES] = msg[i];
          crypto_secretbox(c, m, m.length, nonce, key);
          return c.subarray(crypto_secretbox_BOXZEROBYTES);
        };
        nacl.secretbox.open = function(box, nonce, key) {
          checkArrayTypes(box, nonce, key);
          checkLengths(key, nonce);
          var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
          var m = new Uint8Array(c.length);
          for (var i = 0; i < box.length; i++)
            c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
          if (c.length < 32)
            return null;
          if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
            return null;
          return m.subarray(crypto_secretbox_ZEROBYTES);
        };
        nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
        nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
        nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
        nacl.scalarMult = function(n, p) {
          checkArrayTypes(n, p);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          if (p.length !== crypto_scalarmult_BYTES)
            throw new Error("bad p size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult(q, n, p);
          return q;
        };
        nacl.scalarMult.base = function(n) {
          checkArrayTypes(n);
          if (n.length !== crypto_scalarmult_SCALARBYTES)
            throw new Error("bad n size");
          var q = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult_base(q, n);
          return q;
        };
        nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
        nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
        nacl.box = function(msg, nonce, publicKey, secretKey) {
          var k = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox(msg, nonce, k);
        };
        nacl.box.before = function(publicKey, secretKey) {
          checkArrayTypes(publicKey, secretKey);
          checkBoxLengths(publicKey, secretKey);
          var k = new Uint8Array(crypto_box_BEFORENMBYTES);
          crypto_box_beforenm(k, publicKey, secretKey);
          return k;
        };
        nacl.box.after = nacl.secretbox;
        nacl.box.open = function(msg, nonce, publicKey, secretKey) {
          var k = nacl.box.before(publicKey, secretKey);
          return nacl.secretbox.open(msg, nonce, k);
        };
        nacl.box.open.after = nacl.secretbox.open;
        nacl.box.keyPair = function() {
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
          crypto_box_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.box.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          crypto_scalarmult_base(pk, secretKey);
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
        nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
        nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
        nacl.box.nonceLength = crypto_box_NONCEBYTES;
        nacl.box.overheadLength = nacl.secretbox.overheadLength;
        nacl.sign = function(msg, secretKey) {
          checkArrayTypes(msg, secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
          crypto_sign(signedMsg, msg, msg.length, secretKey);
          return signedMsg;
        };
        nacl.sign.open = function(signedMsg, publicKey) {
          checkArrayTypes(signedMsg, publicKey);
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var tmp = new Uint8Array(signedMsg.length);
          var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
          if (mlen < 0)
            return null;
          var m = new Uint8Array(mlen);
          for (var i = 0; i < m.length; i++)
            m[i] = tmp[i];
          return m;
        };
        nacl.sign.detached = function(msg, secretKey) {
          var signedMsg = nacl.sign(msg, secretKey);
          var sig = new Uint8Array(crypto_sign_BYTES);
          for (var i = 0; i < sig.length; i++)
            sig[i] = signedMsg[i];
          return sig;
        };
        nacl.sign.detached.verify = function(msg, sig, publicKey) {
          checkArrayTypes(msg, sig, publicKey);
          if (sig.length !== crypto_sign_BYTES)
            throw new Error("bad signature size");
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
          var m = new Uint8Array(crypto_sign_BYTES + msg.length);
          var i;
          for (i = 0; i < crypto_sign_BYTES; i++)
            sm[i] = sig[i];
          for (i = 0; i < msg.length; i++)
            sm[i + crypto_sign_BYTES] = msg[i];
          return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
        };
        nacl.sign.keyPair = function() {
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.sign.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          for (var i = 0; i < pk.length; i++)
            pk[i] = secretKey[32 + i];
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl.sign.keyPair.fromSeed = function(seed) {
          checkArrayTypes(seed);
          if (seed.length !== crypto_sign_SEEDBYTES)
            throw new Error("bad seed size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          for (var i = 0; i < 32; i++)
            sk[i] = seed[i];
          crypto_sign_keypair(pk, sk, true);
          return { publicKey: pk, secretKey: sk };
        };
        nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
        nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
        nacl.sign.seedLength = crypto_sign_SEEDBYTES;
        nacl.sign.signatureLength = crypto_sign_BYTES;
        nacl.hash = function(msg) {
          checkArrayTypes(msg);
          var h = new Uint8Array(crypto_hash_BYTES);
          crypto_hash(h, msg, msg.length);
          return h;
        };
        nacl.hash.hashLength = crypto_hash_BYTES;
        nacl.verify = function(x, y) {
          checkArrayTypes(x, y);
          if (x.length === 0 || y.length === 0)
            return false;
          if (x.length !== y.length)
            return false;
          return vn(x, 0, y, 0, x.length) === 0 ? true : false;
        };
        nacl.setPRNG = function(fn) {
          randombytes = fn;
        };
        (function() {
          var crypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (crypto && crypto.getRandomValues) {
            var QUOTA = 65536;
            nacl.setPRNG(function(x, n) {
              var i, v = new Uint8Array(n);
              for (i = 0; i < n; i += QUOTA) {
                crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
              }
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          } else if (typeof __require !== "undefined") {
            crypto = require_crypto();
            if (crypto && crypto.randomBytes) {
              nacl.setPRNG(function(x, n) {
                var i, v = crypto.randomBytes(n);
                for (i = 0; i < n; i++)
                  x[i] = v[i];
                cleanup(v);
              });
            }
          }
        })();
      })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
    }
  });

  // node_modules/base-x/src/index.js
  var require_src = __commonJS({
    "node_modules/base-x/src/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Buffer = require_safe_buffer().Buffer;
      function base2(ALPHABET) {
        if (ALPHABET.length >= 255) {
          throw new TypeError("Alphabet too long");
        }
        var BASE_MAP = new Uint8Array(256);
        for (var j = 0; j < BASE_MAP.length; j++) {
          BASE_MAP[j] = 255;
        }
        for (var i = 0; i < ALPHABET.length; i++) {
          var x = ALPHABET.charAt(i);
          var xc = x.charCodeAt(0);
          if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
          }
          BASE_MAP[xc] = i;
        }
        var BASE = ALPHABET.length;
        var LEADER = ALPHABET.charAt(0);
        var FACTOR = Math.log(BASE) / Math.log(256);
        var iFACTOR = Math.log(256) / Math.log(BASE);
        function encode3(source) {
          if (Array.isArray(source) || source instanceof Uint8Array) {
            source = _Buffer.from(source);
          }
          if (!_Buffer.isBuffer(source)) {
            throw new TypeError("Expected Buffer");
          }
          if (source.length === 0) {
            return "";
          }
          var zeroes = 0;
          var length = 0;
          var pbegin = 0;
          var pend = source.length;
          while (pbegin !== pend && source[pbegin] === 0) {
            pbegin++;
            zeroes++;
          }
          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
          var b58 = new Uint8Array(size);
          while (pbegin !== pend) {
            var carry = source[pbegin];
            var i2 = 0;
            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
              carry += 256 * b58[it1] >>> 0;
              b58[it1] = carry % BASE >>> 0;
              carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            pbegin++;
          }
          var it2 = size - length;
          while (it2 !== size && b58[it2] === 0) {
            it2++;
          }
          var str = LEADER.repeat(zeroes);
          for (; it2 < size; ++it2) {
            str += ALPHABET.charAt(b58[it2]);
          }
          return str;
        }
        function decodeUnsafe(source) {
          if (typeof source !== "string") {
            throw new TypeError("Expected String");
          }
          if (source.length === 0) {
            return _Buffer.alloc(0);
          }
          var psz = 0;
          var zeroes = 0;
          var length = 0;
          while (source[psz] === LEADER) {
            zeroes++;
            psz++;
          }
          var size = (source.length - psz) * FACTOR + 1 >>> 0;
          var b256 = new Uint8Array(size);
          while (source[psz]) {
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
              return;
            }
            var i2 = 0;
            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
              carry += BASE * b256[it3] >>> 0;
              b256[it3] = carry % 256 >>> 0;
              carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
              throw new Error("Non-zero carry");
            }
            length = i2;
            psz++;
          }
          var it4 = size - length;
          while (it4 !== size && b256[it4] === 0) {
            it4++;
          }
          var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
          vch.fill(0, 0, zeroes);
          var j2 = zeroes;
          while (it4 !== size) {
            vch[j2++] = b256[it4++];
          }
          return vch;
        }
        function decode2(string) {
          var buffer = decodeUnsafe(string);
          if (buffer) {
            return buffer;
          }
          throw new Error("Non-base" + BASE + " character");
        }
        return {
          encode: encode3,
          decodeUnsafe,
          decode: decode2
        };
      }
      module.exports = base2;
    }
  });

  // node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "node_modules/bs58/index.js"(exports, module) {
      init_esbuild_inject();
      var basex = require_src();
      var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      module.exports = basex(ALPHABET);
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js
  var require_stream_browser12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_events().EventEmitter;
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/buffer_list.js
  var require_buffer_list12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _require = require_buffer();
      var Buffer4 = _require.Buffer;
      var _require2 = require_util2();
      var inspect3 = _require2.inspect;
      var custom = inspect3 && inspect3.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer4.prototype.copy.call(src, target, offset);
      }
      module.exports = /* @__PURE__ */ function() {
        function BufferList2() {
          _classCallCheck(this, BufferList2);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass(BufferList2, [{
          key: "push",
          value: function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          }
        }, {
          key: "unshift",
          value: function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          }
        }, {
          key: "shift",
          value: function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          }
        }, {
          key: "clear",
          value: function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }
        }, {
          key: "join",
          value: function join2(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          }
        }, {
          key: "concat",
          value: function concat2(n) {
            if (this.length === 0)
              return Buffer4.alloc(0);
            var ret = Buffer4.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
        }, {
          key: "consume",
          value: function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }
        }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer4.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
        }, {
          key: custom,
          value: function value(_, options) {
            return inspect3(this, _objectSpread({}, options, {
              depth: 0,
              customInspect: false
            }));
          }
        }]);
        return BufferList2;
      }();
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js
  var require_destroy12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err) {
            if (!this._writableState) {
              process.nextTick(emitErrorNT, this, err);
            } else if (!this._writableState.errorEmitted) {
              this._writableState.errorEmitted = true;
              process.nextTick(emitErrorNT, this, err);
            }
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            if (!_this._writableState) {
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else if (!_this._writableState.errorEmitted) {
              _this._writableState.errorEmitted = true;
              process.nextTick(emitErrorAndCloseNT, _this, err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          } else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        });
        return this;
      }
      function emitErrorAndCloseNT(self2, err) {
        emitErrorNT(self2, err);
        emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        if (self2._writableState && !self2._writableState.emitClose)
          return;
        if (self2._readableState && !self2._readableState.emitClose)
          return;
        self2.emit("close");
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finalCalled = false;
          this._writableState.prefinished = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      function errorOrDestroy(stream, err) {
        var rState = stream._readableState;
        var wState = stream._writableState;
        if (rState && rState.autoDestroy || wState && wState.autoDestroy)
          stream.destroy(err);
        else
          stream.emit("error", err);
      }
      module.exports = {
        destroy,
        undestroy,
        errorOrDestroy
      };
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/errors-browser.js
  var require_errors_browser12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/errors-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes2(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type2 = includes2(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(typeof actual);
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module.exports.codes = codes;
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js
  var require_state12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_INVALID_OPT_VALUE = require_errors_browser12().codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module.exports = {
        getHighWaterMark
      };
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js
  var require_stream_writable12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Writable2;
      function CorkedRequest2(state) {
        var _this = this;
        this.next = null;
        this.entry = null;
        this.finish = function() {
          onCorkedFinish(_this, state);
        };
      }
      var Duplex2;
      Writable2.WritableState = WritableState2;
      var internalUtil = {
        deprecate: require_browser3()
      };
      var Stream2 = require_stream_browser12();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var destroyImpl = require_destroy12();
      var _require = require_state12();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser12().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
      var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
      var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      require_inherits_browser()(Writable2, Stream2);
      function nop2() {
      }
      function WritableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex12();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.writableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
        this.finalCalled = false;
        this.needDrain = false;
        this.ending = false;
        this.ended = false;
        this.finished = false;
        this.destroyed = false;
        var noDecode = options.decodeStrings === false;
        this.decodeStrings = !noDecode;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.length = 0;
        this.writing = false;
        this.corked = 0;
        this.sync = true;
        this.bufferProcessing = false;
        this.onwrite = function(er) {
          onwrite2(stream, er);
        };
        this.writecb = null;
        this.writelen = 0;
        this.bufferedRequest = null;
        this.lastBufferedRequest = null;
        this.pendingcb = 0;
        this.prefinished = false;
        this.errorEmitted = false;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.bufferedRequestCount = 0;
        this.corkedRequestsFree = new CorkedRequest2(this);
      }
      WritableState2.prototype.getBuffer = function getBuffer() {
        var current = this.bufferedRequest;
        var out = [];
        while (current) {
          out.push(current);
          current = current.next;
        }
        return out;
      };
      (function() {
        try {
          Object.defineProperty(WritableState2.prototype, "buffer", {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          });
        } catch (_) {
        }
      })();
      var realHasInstance;
      if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
        realHasInstance = Function.prototype[Symbol.hasInstance];
        Object.defineProperty(Writable2, Symbol.hasInstance, {
          value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable2)
              return false;
            return object && object._writableState instanceof WritableState2;
          }
        });
      } else {
        realHasInstance = function realHasInstance2(object) {
          return object instanceof this;
        };
      }
      function Writable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex12();
        var isDuplex = this instanceof Duplex2;
        if (!isDuplex && !realHasInstance.call(Writable2, this))
          return new Writable2(options);
        this._writableState = new WritableState2(options, this, isDuplex);
        this.writable = true;
        if (options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
        }
        Stream2.call(this);
      }
      Writable2.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
      };
      function writeAfterEnd2(stream, cb) {
        var er = new ERR_STREAM_WRITE_AFTER_END();
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
      }
      function validChunk2(stream, state, chunk, cb) {
        var er;
        if (chunk === null) {
          er = new ERR_STREAM_NULL_VALUES();
        } else if (typeof chunk !== "string" && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
        }
        if (er) {
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
          return false;
        }
        return true;
      }
      Writable2.prototype.write = function(chunk, encoding, cb) {
        var state = this._writableState;
        var ret = false;
        var isBuf = !state.objectMode && _isUint8Array(chunk);
        if (isBuf && !Buffer4.isBuffer(chunk)) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (isBuf)
          encoding = "buffer";
        else if (!encoding)
          encoding = state.defaultEncoding;
        if (typeof cb !== "function")
          cb = nop2;
        if (state.ending)
          writeAfterEnd2(this, cb);
        else if (isBuf || validChunk2(this, state, chunk, cb)) {
          state.pendingcb++;
          ret = writeOrBuffer2(this, state, isBuf, chunk, encoding, cb);
        }
        return ret;
      };
      Writable2.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable2.prototype.uncork = function() {
        var state = this._writableState;
        if (state.corked) {
          state.corked--;
          if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer2(this, state);
        }
      };
      Writable2.prototype.setDefaultEncoding = function setDefaultEncoding2(encoding) {
        if (typeof encoding === "string")
          encoding = encoding.toLowerCase();
        if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        this._writableState.defaultEncoding = encoding;
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      function decodeChunk2(state, chunk, encoding) {
        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
          chunk = Buffer4.from(chunk, encoding);
        }
        return chunk;
      }
      Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      function writeOrBuffer2(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = decodeChunk2(state, chunk, encoding);
          if (chunk !== newChunk) {
            isBuf = true;
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        var ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk,
            encoding,
            isBuf,
            callback: cb,
            next: null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite2(stream, state, false, len, chunk, encoding, cb);
        }
        return ret;
      }
      function doWrite2(stream, state, writev, len, chunk, encoding, cb) {
        state.writelen = len;
        state.writecb = cb;
        state.writing = true;
        state.sync = true;
        if (state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream._writev(chunk, state.onwrite);
        else
          stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError2(stream, state, sync, er, cb) {
        --state.pendingcb;
        if (sync) {
          process.nextTick(cb, er);
          process.nextTick(finishMaybe2, stream, state);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
        } else {
          cb(er);
          stream._writableState.errorEmitted = true;
          errorOrDestroy(stream, er);
          finishMaybe2(stream, state);
        }
      }
      function onwriteStateUpdate2(state) {
        state.writing = false;
        state.writecb = null;
        state.length -= state.writelen;
        state.writelen = 0;
      }
      function onwrite2(stream, er) {
        var state = stream._writableState;
        var sync = state.sync;
        var cb = state.writecb;
        if (typeof cb !== "function")
          throw new ERR_MULTIPLE_CALLBACK();
        onwriteStateUpdate2(state);
        if (er)
          onwriteError2(stream, state, sync, er, cb);
        else {
          var finished = needFinish2(state) || stream.destroyed;
          if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer2(stream, state);
          }
          if (sync) {
            process.nextTick(afterWrite2, stream, state, finished, cb);
          } else {
            afterWrite2(stream, state, finished, cb);
          }
        }
      }
      function afterWrite2(stream, state, finished, cb) {
        if (!finished)
          onwriteDrain2(stream, state);
        state.pendingcb--;
        cb();
        finishMaybe2(stream, state);
      }
      function onwriteDrain2(stream, state) {
        if (state.length === 0 && state.needDrain) {
          state.needDrain = false;
          stream.emit("drain");
        }
      }
      function clearBuffer2(stream, state) {
        state.bufferProcessing = true;
        var entry = state.bufferedRequest;
        if (stream._writev && entry && entry.next) {
          var l = state.bufferedRequestCount;
          var buffer = new Array(l);
          var holder = state.corkedRequestsFree;
          holder.entry = entry;
          var count = 0;
          var allBuffers = true;
          while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
              allBuffers = false;
            entry = entry.next;
            count += 1;
          }
          buffer.allBuffers = allBuffers;
          doWrite2(stream, state, true, state.length, buffer, "", holder.finish);
          state.pendingcb++;
          state.lastBufferedRequest = null;
          if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
          } else {
            state.corkedRequestsFree = new CorkedRequest2(state);
          }
          state.bufferedRequestCount = 0;
        } else {
          while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite2(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--;
            if (state.writing) {
              break;
            }
          }
          if (entry === null)
            state.lastBufferedRequest = null;
        }
        state.bufferedRequest = entry;
        state.bufferProcessing = false;
      }
      Writable2.prototype._write = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
      };
      Writable2.prototype._writev = null;
      Writable2.prototype.end = function(chunk, encoding, cb) {
        var state = this._writableState;
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = null;
          encoding = null;
        } else if (typeof encoding === "function") {
          cb = encoding;
          encoding = null;
        }
        if (chunk !== null && chunk !== void 0)
          this.write(chunk, encoding);
        if (state.corked) {
          state.corked = 1;
          this.uncork();
        }
        if (!state.ending)
          endWritable2(this, state, cb);
        return this;
      };
      Object.defineProperty(Writable2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function needFinish2(state) {
        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
      }
      function callFinal(stream, state) {
        stream._final(function(err) {
          state.pendingcb--;
          if (err) {
            errorOrDestroy(stream, err);
          }
          state.prefinished = true;
          stream.emit("prefinish");
          finishMaybe2(stream, state);
        });
      }
      function prefinish2(stream, state) {
        if (!state.prefinished && !state.finalCalled) {
          if (typeof stream._final === "function" && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
          } else {
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }
      function finishMaybe2(stream, state) {
        var need = needFinish2(state);
        if (need) {
          prefinish2(stream, state);
          if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit("finish");
            if (state.autoDestroy) {
              var rState = stream._readableState;
              if (!rState || rState.autoDestroy && rState.endEmitted) {
                stream.destroy();
              }
            }
          }
        }
        return need;
      }
      function endWritable2(stream, state, cb) {
        state.ending = true;
        finishMaybe2(stream, state);
        if (cb) {
          if (state.finished)
            process.nextTick(cb);
          else
            stream.once("finish", cb);
        }
        state.ended = true;
        stream.writable = false;
      }
      function onCorkedFinish(corkReq, state, err) {
        var entry = corkReq.entry;
        corkReq.entry = null;
        while (entry) {
          var cb = entry.callback;
          state.pendingcb--;
          cb(err);
          entry = entry.next;
        }
        state.corkedRequestsFree.next = corkReq;
      }
      Object.defineProperty(Writable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        },
        set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        }
      });
      Writable2.prototype.destroy = destroyImpl.destroy;
      Writable2.prototype._undestroy = destroyImpl.undestroy;
      Writable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js
  var require_stream_duplex12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var objectKeys2 = Object.keys || function(obj) {
        var keys3 = [];
        for (var key in obj) {
          keys3.push(key);
        }
        return keys3;
      };
      module.exports = Duplex2;
      var Readable2 = require_stream_readable12();
      var Writable2 = require_stream_writable12();
      require_inherits_browser()(Duplex2, Readable2);
      {
        keys2 = objectKeys2(Writable2.prototype);
        for (v = 0; v < keys2.length; v++) {
          method = keys2[v];
          if (!Duplex2.prototype[method])
            Duplex2.prototype[method] = Writable2.prototype[method];
        }
      }
      var keys2;
      var method;
      var v;
      function Duplex2(options) {
        if (!(this instanceof Duplex2))
          return new Duplex2(options);
        Readable2.call(this, options);
        Writable2.call(this, options);
        this.allowHalfOpen = true;
        if (options) {
          if (options.readable === false)
            this.readable = false;
          if (options.writable === false)
            this.writable = false;
          if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once("end", onend2);
          }
        }
      }
      Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._writableState.highWaterMark;
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._writableState && this._writableState.getBuffer();
        }
      });
      Object.defineProperty(Duplex2.prototype, "writableLength", {
        enumerable: false,
        get: function get3() {
          return this._writableState.length;
        }
      });
      function onend2() {
        if (this._writableState.ended)
          return;
        process.nextTick(onEndNT2, this);
      }
      function onEndNT2(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function set(value) {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return;
          }
          this._readableState.destroyed = value;
          this._writableState.destroyed = value;
        }
      });
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
  var require_end_of_stream13 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser12().codes.ERR_STREAM_PREMATURE_CLOSE;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop2() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once3(callback || noop2);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend2 = function onend3() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend2);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend2);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module.exports = eos;
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/async_iterator.js
  var require_async_iterator12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _Object$setPrototypeO;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var finished = require_end_of_stream13();
      var kLastResolve = Symbol("lastResolve");
      var kLastReject = Symbol("lastReject");
      var kError = Symbol("error");
      var kEnded = Symbol("ended");
      var kLastPromise = Symbol("lastPromise");
      var kHandlePromise = Symbol("handlePromise");
      var kStream = Symbol("stream");
      function createIterResult(value, done2) {
        return {
          value,
          done: done2
        };
      }
      function readAndResolve(iter) {
        var resolve2 = iter[kLastResolve];
        if (resolve2 !== null) {
          var data = iter[kStream].read();
          if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve2(createIterResult(data, false));
          }
        }
      }
      function onReadable(iter) {
        process.nextTick(readAndResolve, iter);
      }
      function wrapForNext(lastPromise, iter) {
        return function(resolve2, reject) {
          lastPromise.then(function() {
            if (iter[kEnded]) {
              resolve2(createIterResult(void 0, true));
              return;
            }
            iter[kHandlePromise](resolve2, reject);
          }, reject);
        };
      }
      var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
      });
      var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
        get stream() {
          return this[kStream];
        },
        next: function next() {
          var _this = this;
          var error2 = this[kError];
          if (error2 !== null) {
            return Promise.reject(error2);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve2, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve2(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        }
      }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
        return this;
      }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
        var _this2 = this;
        return new Promise(function(resolve2, reject) {
          _this2[kStream].destroy(null, function(err) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(createIterResult(void 0, true));
          });
        });
      }), _Object$setPrototypeO), AsyncIteratorPrototype);
      var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
        var _Object$create;
        var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
          value: stream,
          writable: true
        }), _defineProperty(_Object$create, kLastResolve, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kLastReject, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kError, {
          value: null,
          writable: true
        }), _defineProperty(_Object$create, kEnded, {
          value: stream._readableState.endEmitted,
          writable: true
        }), _defineProperty(_Object$create, kHandlePromise, {
          value: function value(resolve2, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve2(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve2;
              iterator[kLastReject] = reject;
            }
          },
          writable: true
        }), _Object$create));
        iterator[kLastPromise] = null;
        finished(stream, function(err) {
          if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
            var reject = iterator[kLastReject];
            if (reject !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              reject(err);
            }
            iterator[kError] = err;
            return;
          }
          var resolve2 = iterator[kLastResolve];
          if (resolve2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(void 0, true));
          }
          iterator[kEnded] = true;
        });
        stream.on("readable", onReadable.bind(null, iterator));
        return iterator;
      };
      module.exports = createReadableStreamAsyncIterator;
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/from-browser.js
  var require_from_browser12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
      init_esbuild_inject();
      module.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js
  var require_stream_readable12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Readable2;
      var Duplex2;
      Readable2.ReadableState = ReadableState2;
      var EE = require_events().EventEmitter;
      var EElistenerCount = function EElistenerCount2(emitter, type2) {
        return emitter.listeners(type2).length;
      };
      var Stream2 = require_stream_browser12();
      var Buffer4 = require_buffer().Buffer;
      var OurUint8Array = globalThis.Uint8Array || function() {
      };
      function _uint8ArrayToBuffer(chunk) {
        return Buffer4.from(chunk);
      }
      function _isUint8Array(obj) {
        return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
      }
      var debugUtil = require_util2();
      var debug2;
      if (debugUtil && debugUtil.debuglog) {
        debug2 = debugUtil.debuglog("stream");
      } else {
        debug2 = function debug3() {
        };
      }
      var BufferList2 = require_buffer_list12();
      var destroyImpl = require_destroy12();
      var _require = require_state12();
      var getHighWaterMark = _require.getHighWaterMark;
      var _require$codes = require_errors_browser12().codes;
      var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
      var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
      var StringDecoder2;
      var createReadableStreamAsyncIterator;
      var from2;
      require_inherits_browser()(Readable2, Stream2);
      var errorOrDestroy = destroyImpl.errorOrDestroy;
      var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
      function prependListener3(emitter, event, fn) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn);
        else if (Array.isArray(emitter._events[event]))
          emitter._events[event].unshift(fn);
        else
          emitter._events[event] = [fn, emitter._events[event]];
      }
      function ReadableState2(options, stream, isDuplex) {
        Duplex2 = Duplex2 || require_stream_duplex12();
        options = options || {};
        if (typeof isDuplex !== "boolean")
          isDuplex = stream instanceof Duplex2;
        this.objectMode = !!options.objectMode;
        if (isDuplex)
          this.objectMode = this.objectMode || !!options.readableObjectMode;
        this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
        this.buffer = new BufferList2();
        this.length = 0;
        this.pipes = null;
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;
        this.sync = true;
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;
        this.resumeScheduled = false;
        this.paused = true;
        this.emitClose = options.emitClose !== false;
        this.autoDestroy = !!options.autoDestroy;
        this.destroyed = false;
        this.defaultEncoding = options.defaultEncoding || "utf8";
        this.awaitDrain = 0;
        this.readingMore = false;
        this.decoder = null;
        this.encoding = null;
        if (options.encoding) {
          if (!StringDecoder2)
            StringDecoder2 = require_string_decoder().StringDecoder;
          this.decoder = new StringDecoder2(options.encoding);
          this.encoding = options.encoding;
        }
      }
      function Readable2(options) {
        Duplex2 = Duplex2 || require_stream_duplex12();
        if (!(this instanceof Readable2))
          return new Readable2(options);
        var isDuplex = this instanceof Duplex2;
        this._readableState = new ReadableState2(options, this, isDuplex);
        this.readable = true;
        if (options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
        }
        Stream2.call(this);
      }
      Object.defineProperty(Readable2.prototype, "destroyed", {
        enumerable: false,
        get: function get3() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        },
        set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      });
      Readable2.prototype.destroy = destroyImpl.destroy;
      Readable2.prototype._undestroy = destroyImpl.undestroy;
      Readable2.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable2.prototype.push = function(chunk, encoding) {
        var state = this._readableState;
        var skipChunkCheck;
        if (!state.objectMode) {
          if (typeof chunk === "string") {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
              chunk = Buffer4.from(chunk, encoding);
              encoding = "";
            }
            skipChunkCheck = true;
          }
        } else {
          skipChunkCheck = true;
        }
        return readableAddChunk2(this, chunk, encoding, false, skipChunkCheck);
      };
      Readable2.prototype.unshift = function(chunk) {
        return readableAddChunk2(this, chunk, null, true, false);
      };
      function readableAddChunk2(stream, chunk, encoding, addToFront, skipChunkCheck) {
        debug2("readableAddChunk", chunk);
        var state = stream._readableState;
        if (chunk === null) {
          state.reading = false;
          onEofChunk2(stream, state);
        } else {
          var er;
          if (!skipChunkCheck)
            er = chunkInvalid2(state, chunk);
          if (er) {
            errorOrDestroy(stream, er);
          } else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
              if (state.endEmitted)
                errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
              else
                addChunk(stream, state, chunk, true);
            } else if (state.ended) {
              errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            } else if (state.destroyed) {
              return false;
            } else {
              state.reading = false;
              if (state.decoder && !encoding) {
                chunk = state.decoder.write(chunk);
                if (state.objectMode || chunk.length !== 0)
                  addChunk(stream, state, chunk, false);
                else
                  maybeReadMore2(stream, state);
              } else {
                addChunk(stream, state, chunk, false);
              }
            }
          } else if (!addToFront) {
            state.reading = false;
            maybeReadMore2(stream, state);
          }
        }
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream, state, chunk, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync) {
          state.awaitDrain = 0;
          stream.emit("data", chunk);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable2(stream);
        }
        maybeReadMore2(stream, state);
      }
      function chunkInvalid2(state, chunk) {
        var er;
        if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
          er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
        return er;
      }
      Readable2.prototype.isPaused = function() {
        return this._readableState.flowing === false;
      };
      Readable2.prototype.setEncoding = function(enc) {
        if (!StringDecoder2)
          StringDecoder2 = require_string_decoder().StringDecoder;
        var decoder = new StringDecoder2(enc);
        this._readableState.decoder = decoder;
        this._readableState.encoding = this._readableState.decoder.encoding;
        var p = this._readableState.buffer.head;
        var content = "";
        while (p !== null) {
          content += decoder.write(p.data);
          p = p.next;
        }
        this._readableState.buffer.clear();
        if (content !== "")
          this._readableState.buffer.push(content);
        this._readableState.length = content.length;
        return this;
      };
      var MAX_HWM2 = 1073741824;
      function computeNewHighWaterMark2(n) {
        if (n >= MAX_HWM2) {
          n = MAX_HWM2;
        } else {
          n--;
          n |= n >>> 1;
          n |= n >>> 2;
          n |= n >>> 4;
          n |= n >>> 8;
          n |= n >>> 16;
          n++;
        }
        return n;
      }
      function howMuchToRead2(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if (state.objectMode)
          return 1;
        if (n !== n) {
          if (state.flowing && state.length)
            return state.buffer.head.data.length;
          else
            return state.length;
        }
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark2(n);
        if (n <= state.length)
          return n;
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        }
        return state.length;
      }
      Readable2.prototype.read = function(n) {
        debug2("read", n);
        n = parseInt(n, 10);
        var state = this._readableState;
        var nOrig = n;
        if (n !== 0)
          state.emittedReadable = false;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          debug2("read: emitReadable", state.length, state.ended);
          if (state.length === 0 && state.ended)
            endReadable2(this);
          else
            emitReadable2(this);
          return null;
        }
        n = howMuchToRead2(n, state);
        if (n === 0 && state.ended) {
          if (state.length === 0)
            endReadable2(this);
          return null;
        }
        var doRead = state.needReadable;
        debug2("need readable", doRead);
        if (state.length === 0 || state.length - n < state.highWaterMark) {
          doRead = true;
          debug2("length less than watermark", doRead);
        }
        if (state.ended || state.reading) {
          doRead = false;
          debug2("reading or ended", doRead);
        } else if (doRead) {
          debug2("do read");
          state.reading = true;
          state.sync = true;
          if (state.length === 0)
            state.needReadable = true;
          this._read(state.highWaterMark);
          state.sync = false;
          if (!state.reading)
            n = howMuchToRead2(nOrig, state);
        }
        var ret;
        if (n > 0)
          ret = fromList2(n, state);
        else
          ret = null;
        if (ret === null) {
          state.needReadable = state.length <= state.highWaterMark;
          n = 0;
        } else {
          state.length -= n;
          state.awaitDrain = 0;
        }
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable2(this);
        }
        if (ret !== null)
          this.emit("data", ret);
        return ret;
      };
      function onEofChunk2(stream, state) {
        debug2("onEofChunk");
        if (state.ended)
          return;
        if (state.decoder) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
          }
        }
        state.ended = true;
        if (state.sync) {
          emitReadable2(stream);
        } else {
          state.needReadable = false;
          if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_2(stream);
          }
        }
      }
      function emitReadable2(stream) {
        var state = stream._readableState;
        debug2("emitReadable", state.needReadable, state.emittedReadable);
        state.needReadable = false;
        if (!state.emittedReadable) {
          debug2("emitReadable", state.flowing);
          state.emittedReadable = true;
          process.nextTick(emitReadable_2, stream);
        }
      }
      function emitReadable_2(stream) {
        var state = stream._readableState;
        debug2("emitReadable_", state.destroyed, state.length, state.ended);
        if (!state.destroyed && (state.length || state.ended)) {
          stream.emit("readable");
          state.emittedReadable = false;
        }
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
        flow2(stream);
      }
      function maybeReadMore2(stream, state) {
        if (!state.readingMore) {
          state.readingMore = true;
          process.nextTick(maybeReadMore_2, stream, state);
        }
      }
      function maybeReadMore_2(stream, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          var len = state.length;
          debug2("maybeReadMore read 0");
          stream.read(0);
          if (len === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable2.prototype._read = function(n) {
        errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
      };
      Readable2.prototype.pipe = function(dest, pipeOpts) {
        var src = this;
        var state = this._readableState;
        switch (state.pipesCount) {
          case 0:
            state.pipes = dest;
            break;
          case 1:
            state.pipes = [state.pipes, dest];
            break;
          default:
            state.pipes.push(dest);
            break;
        }
        state.pipesCount += 1;
        debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
        var endFn = doEnd ? onend2 : unpipe;
        if (state.endEmitted)
          process.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          debug2("onunpipe");
          if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
              unpipeInfo.hasUnpiped = true;
              cleanup();
            }
          }
        }
        function onend2() {
          debug2("onend");
          dest.end();
        }
        var ondrain = pipeOnDrain2(src);
        dest.on("drain", ondrain);
        var cleanedUp = false;
        function cleanup() {
          debug2("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onfinish);
          dest.removeListener("drain", ondrain);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", onunpipe);
          src.removeListener("end", onend2);
          src.removeListener("end", unpipe);
          src.removeListener("data", ondata);
          cleanedUp = true;
          if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        src.on("data", ondata);
        function ondata(chunk) {
          debug2("ondata");
          var ret = dest.write(chunk);
          debug2("dest.write", ret);
          if (ret === false) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
              debug2("false write response, pause", state.awaitDrain);
              state.awaitDrain++;
            }
            src.pause();
          }
        }
        function onerror(er) {
          debug2("onerror", er);
          unpipe();
          dest.removeListener("error", onerror);
          if (EElistenerCount(dest, "error") === 0)
            errorOrDestroy(dest, er);
        }
        prependListener3(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish);
          unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug2("onfinish");
          dest.removeListener("close", onclose);
          unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug2("unpipe");
          src.unpipe(dest);
        }
        dest.emit("pipe", src);
        if (!state.flowing) {
          debug2("pipe resume");
          src.resume();
        }
        return dest;
      };
      function pipeOnDrain2(src) {
        return function pipeOnDrainFunctionResult() {
          var state = src._readableState;
          debug2("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain)
            state.awaitDrain--;
          if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
            state.flowing = true;
            flow2(src);
          }
        };
      }
      Readable2.prototype.unpipe = function(dest) {
        var state = this._readableState;
        var unpipeInfo = {
          hasUnpiped: false
        };
        if (state.pipesCount === 0)
          return this;
        if (state.pipesCount === 1) {
          if (dest && dest !== state.pipes)
            return this;
          if (!dest)
            dest = state.pipes;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          if (dest)
            dest.emit("unpipe", this, unpipeInfo);
          return this;
        }
        if (!dest) {
          var dests = state.pipes;
          var len = state.pipesCount;
          state.pipes = null;
          state.pipesCount = 0;
          state.flowing = false;
          for (var i = 0; i < len; i++) {
            dests[i].emit("unpipe", this, {
              hasUnpiped: false
            });
          }
          return this;
        }
        var index = indexOf3(state.pipes, dest);
        if (index === -1)
          return this;
        state.pipes.splice(index, 1);
        state.pipesCount -= 1;
        if (state.pipesCount === 1)
          state.pipes = state.pipes[0];
        dest.emit("unpipe", this, unpipeInfo);
        return this;
      };
      Readable2.prototype.on = function(ev, fn) {
        var res = Stream2.prototype.on.call(this, ev, fn);
        var state = this._readableState;
        if (ev === "data") {
          state.readableListening = this.listenerCount("readable") > 0;
          if (state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug2("on readable", state.length, state.reading);
            if (state.length) {
              emitReadable2(this);
            } else if (!state.reading) {
              process.nextTick(nReadingNextTick2, this);
            }
          }
        }
        return res;
      };
      Readable2.prototype.addListener = Readable2.prototype.on;
      Readable2.prototype.removeListener = function(ev, fn) {
        var res = Stream2.prototype.removeListener.call(this, ev, fn);
        if (ev === "readable") {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      Readable2.prototype.removeAllListeners = function(ev) {
        var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === void 0) {
          process.nextTick(updateReadableListening, this);
        }
        return res;
      };
      function updateReadableListening(self2) {
        var state = self2._readableState;
        state.readableListening = self2.listenerCount("readable") > 0;
        if (state.resumeScheduled && !state.paused) {
          state.flowing = true;
        } else if (self2.listenerCount("data") > 0) {
          self2.resume();
        }
      }
      function nReadingNextTick2(self2) {
        debug2("readable nexttick read 0");
        self2.read(0);
      }
      Readable2.prototype.resume = function() {
        var state = this._readableState;
        if (!state.flowing) {
          debug2("resume");
          state.flowing = !state.readableListening;
          resume2(this, state);
        }
        state.paused = false;
        return this;
      };
      function resume2(stream, state) {
        if (!state.resumeScheduled) {
          state.resumeScheduled = true;
          process.nextTick(resume_2, stream, state);
        }
      }
      function resume_2(stream, state) {
        debug2("resume", state.reading);
        if (!state.reading) {
          stream.read(0);
        }
        state.resumeScheduled = false;
        stream.emit("resume");
        flow2(stream);
        if (state.flowing && !state.reading)
          stream.read(0);
      }
      Readable2.prototype.pause = function() {
        debug2("call pause flowing=%j", this._readableState.flowing);
        if (this._readableState.flowing !== false) {
          debug2("pause");
          this._readableState.flowing = false;
          this.emit("pause");
        }
        this._readableState.paused = true;
        return this;
      };
      function flow2(stream) {
        var state = stream._readableState;
        debug2("flow", state.flowing);
        while (state.flowing && stream.read() !== null) {
          ;
        }
      }
      Readable2.prototype.wrap = function(stream) {
        var _this = this;
        var state = this._readableState;
        var paused = false;
        stream.on("end", function() {
          debug2("wrapped end");
          if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
              _this.push(chunk);
          }
          _this.push(null);
        });
        stream.on("data", function(chunk) {
          debug2("wrapped data");
          if (state.decoder)
            chunk = state.decoder.write(chunk);
          if (state.objectMode && (chunk === null || chunk === void 0))
            return;
          else if (!state.objectMode && (!chunk || !chunk.length))
            return;
          var ret = _this.push(chunk);
          if (!ret) {
            paused = true;
            stream.pause();
          }
        });
        for (var i in stream) {
          if (this[i] === void 0 && typeof stream[i] === "function") {
            this[i] = function methodWrap(method) {
              return function methodWrapReturnFunction() {
                return stream[method].apply(stream, arguments);
              };
            }(i);
          }
        }
        for (var n = 0; n < kProxyEvents.length; n++) {
          stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
        }
        this._read = function(n2) {
          debug2("wrapped _read", n2);
          if (paused) {
            paused = false;
            stream.resume();
          }
        };
        return this;
      };
      if (typeof Symbol === "function") {
        Readable2.prototype[Symbol.asyncIterator] = function() {
          if (createReadableStreamAsyncIterator === void 0) {
            createReadableStreamAsyncIterator = require_async_iterator12();
          }
          return createReadableStreamAsyncIterator(this);
        };
      }
      Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
        enumerable: false,
        get: function get3() {
          return this._readableState.highWaterMark;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableBuffer", {
        enumerable: false,
        get: function get3() {
          return this._readableState && this._readableState.buffer;
        }
      });
      Object.defineProperty(Readable2.prototype, "readableFlowing", {
        enumerable: false,
        get: function get3() {
          return this._readableState.flowing;
        },
        set: function set(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      });
      Readable2._fromList = fromList2;
      Object.defineProperty(Readable2.prototype, "readableLength", {
        enumerable: false,
        get: function get3() {
          return this._readableState.length;
        }
      });
      function fromList2(n, state) {
        if (state.length === 0)
          return null;
        var ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else {
          ret = state.buffer.consume(n, state.decoder);
        }
        return ret;
      }
      function endReadable2(stream) {
        var state = stream._readableState;
        debug2("endReadable", state.endEmitted);
        if (!state.endEmitted) {
          state.ended = true;
          process.nextTick(endReadableNT2, state, stream);
        }
      }
      function endReadableNT2(state, stream) {
        debug2("endReadableNT", state.endEmitted, state.length);
        if (!state.endEmitted && state.length === 0) {
          state.endEmitted = true;
          stream.readable = false;
          stream.emit("end");
          if (state.autoDestroy) {
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
              stream.destroy();
            }
          }
        }
      }
      if (typeof Symbol === "function") {
        Readable2.from = function(iterable, opts) {
          if (from2 === void 0) {
            from2 = require_from_browser12();
          }
          return from2(Readable2, iterable, opts);
        };
      }
      function indexOf3(xs, x) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (xs[i] === x)
            return i;
        }
        return -1;
      }
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js
  var require_stream_transform12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = Transform2;
      var _require$codes = require_errors_browser12().codes;
      var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
      var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
      var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
      var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex2 = require_stream_duplex12();
      require_inherits_browser()(Transform2, Duplex2);
      function afterTransform2(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform2(options) {
        if (!(this instanceof Transform2))
          return new Transform2(options);
        Duplex2.call(this, options);
        this._transformState = {
          afterTransform: afterTransform2.bind(this),
          needTransform: false,
          transforming: false,
          writecb: null,
          writechunk: null,
          writeencoding: null
        };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish2);
      }
      function prefinish2() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done2(_this, er, data);
          });
        } else {
          done2(this, null, null);
        }
      }
      Transform2.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex2.prototype.push.call(this, chunk, encoding);
      };
      Transform2.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform2.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform2.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform2.prototype._destroy = function(err, cb) {
        Duplex2.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done2(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/_stream_passthrough.js
  var require_stream_passthrough12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = PassThrough2;
      var Transform2 = require_stream_transform12();
      require_inherits_browser()(PassThrough2, Transform2);
      function PassThrough2(options) {
        if (!(this instanceof PassThrough2))
          return new PassThrough2(options);
        Transform2.call(this, options);
      }
      PassThrough2.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/pipeline.js
  var require_pipeline12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var eos;
      function once3(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require_errors_browser12().codes;
      var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
      var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop2(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once3(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require_end_of_stream13();
        eos(stream, {
          readable: reading,
          writable: writing
        }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from2, to) {
        return from2.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop2;
        if (typeof streams[streams.length - 1] !== "function")
          return noop2;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error2;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error2)
              error2 = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error2);
          });
        });
        return streams.reduce(pipe);
      }
      module.exports = pipeline;
    }
  });

  // node_modules/hash-base/node_modules/readable-stream/readable-browser.js
  var require_readable_browser12 = __commonJS({
    "node_modules/hash-base/node_modules/readable-stream/readable-browser.js"(exports, module) {
      init_esbuild_inject();
      exports = module.exports = require_stream_readable12();
      exports.Stream = exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable12();
      exports.Duplex = require_stream_duplex12();
      exports.Transform = require_stream_transform12();
      exports.PassThrough = require_stream_passthrough12();
      exports.finished = require_end_of_stream13();
      exports.pipeline = require_pipeline12();
    }
  });

  // node_modules/hash-base/index.js
  var require_hash_base = __commonJS({
    "node_modules/hash-base/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var Buffer4 = require_safe_buffer().Buffer;
      var Transform2 = require_readable_browser12().Transform;
      var inherits2 = require_inherits_browser();
      function throwIfNotStringOrBuffer(val, prefix) {
        if (!Buffer4.isBuffer(val) && typeof val !== "string") {
          throw new TypeError(prefix + " must be a string or a buffer");
        }
      }
      function HashBase(blockSize) {
        Transform2.call(this);
        this._block = Buffer4.allocUnsafe(blockSize);
        this._blockSize = blockSize;
        this._blockOffset = 0;
        this._length = [0, 0, 0, 0];
        this._finalized = false;
      }
      inherits2(HashBase, Transform2);
      HashBase.prototype._transform = function(chunk, encoding, callback) {
        var error2 = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error2 = err;
        }
        callback(error2);
      };
      HashBase.prototype._flush = function(callback) {
        var error2 = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error2 = err;
        }
        callback(error2);
      };
      HashBase.prototype.update = function(data, encoding) {
        throwIfNotStringOrBuffer(data, "Data");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer4.isBuffer(data))
          data = Buffer4.from(data, encoding);
        var block = this._block;
        var offset = 0;
        while (this._blockOffset + data.length - offset >= this._blockSize) {
          for (var i = this._blockOffset; i < this._blockSize; )
            block[i++] = data[offset++];
          this._update();
          this._blockOffset = 0;
        }
        while (offset < data.length)
          block[this._blockOffset++] = data[offset++];
        for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
          this._length[j] += carry;
          carry = this._length[j] / 4294967296 | 0;
          if (carry > 0)
            this._length[j] -= 4294967296 * carry;
        }
        return this;
      };
      HashBase.prototype._update = function() {
        throw new Error("_update is not implemented");
      };
      HashBase.prototype.digest = function(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        var digest = this._digest();
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._block.fill(0);
        this._blockOffset = 0;
        for (var i = 0; i < 4; ++i)
          this._length[i] = 0;
        return digest;
      };
      HashBase.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      };
      module.exports = HashBase;
    }
  });

  // node_modules/md5.js/index.js
  var require_md5 = __commonJS({
    "node_modules/md5.js/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var inherits2 = require_inherits_browser();
      var HashBase = require_hash_base();
      var Buffer4 = require_safe_buffer().Buffer;
      var ARRAY16 = new Array(16);
      function MD5() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
      }
      inherits2(MD5, HashBase);
      MD5.prototype._update = function() {
        var M = ARRAY16;
        for (var i = 0; i < 16; ++i)
          M[i] = this._block.readInt32LE(i * 4);
        var a = this._a;
        var b = this._b;
        var c = this._c;
        var d = this._d;
        a = fnF(a, b, c, d, M[0], 3614090360, 7);
        d = fnF(d, a, b, c, M[1], 3905402710, 12);
        c = fnF(c, d, a, b, M[2], 606105819, 17);
        b = fnF(b, c, d, a, M[3], 3250441966, 22);
        a = fnF(a, b, c, d, M[4], 4118548399, 7);
        d = fnF(d, a, b, c, M[5], 1200080426, 12);
        c = fnF(c, d, a, b, M[6], 2821735955, 17);
        b = fnF(b, c, d, a, M[7], 4249261313, 22);
        a = fnF(a, b, c, d, M[8], 1770035416, 7);
        d = fnF(d, a, b, c, M[9], 2336552879, 12);
        c = fnF(c, d, a, b, M[10], 4294925233, 17);
        b = fnF(b, c, d, a, M[11], 2304563134, 22);
        a = fnF(a, b, c, d, M[12], 1804603682, 7);
        d = fnF(d, a, b, c, M[13], 4254626195, 12);
        c = fnF(c, d, a, b, M[14], 2792965006, 17);
        b = fnF(b, c, d, a, M[15], 1236535329, 22);
        a = fnG(a, b, c, d, M[1], 4129170786, 5);
        d = fnG(d, a, b, c, M[6], 3225465664, 9);
        c = fnG(c, d, a, b, M[11], 643717713, 14);
        b = fnG(b, c, d, a, M[0], 3921069994, 20);
        a = fnG(a, b, c, d, M[5], 3593408605, 5);
        d = fnG(d, a, b, c, M[10], 38016083, 9);
        c = fnG(c, d, a, b, M[15], 3634488961, 14);
        b = fnG(b, c, d, a, M[4], 3889429448, 20);
        a = fnG(a, b, c, d, M[9], 568446438, 5);
        d = fnG(d, a, b, c, M[14], 3275163606, 9);
        c = fnG(c, d, a, b, M[3], 4107603335, 14);
        b = fnG(b, c, d, a, M[8], 1163531501, 20);
        a = fnG(a, b, c, d, M[13], 2850285829, 5);
        d = fnG(d, a, b, c, M[2], 4243563512, 9);
        c = fnG(c, d, a, b, M[7], 1735328473, 14);
        b = fnG(b, c, d, a, M[12], 2368359562, 20);
        a = fnH(a, b, c, d, M[5], 4294588738, 4);
        d = fnH(d, a, b, c, M[8], 2272392833, 11);
        c = fnH(c, d, a, b, M[11], 1839030562, 16);
        b = fnH(b, c, d, a, M[14], 4259657740, 23);
        a = fnH(a, b, c, d, M[1], 2763975236, 4);
        d = fnH(d, a, b, c, M[4], 1272893353, 11);
        c = fnH(c, d, a, b, M[7], 4139469664, 16);
        b = fnH(b, c, d, a, M[10], 3200236656, 23);
        a = fnH(a, b, c, d, M[13], 681279174, 4);
        d = fnH(d, a, b, c, M[0], 3936430074, 11);
        c = fnH(c, d, a, b, M[3], 3572445317, 16);
        b = fnH(b, c, d, a, M[6], 76029189, 23);
        a = fnH(a, b, c, d, M[9], 3654602809, 4);
        d = fnH(d, a, b, c, M[12], 3873151461, 11);
        c = fnH(c, d, a, b, M[15], 530742520, 16);
        b = fnH(b, c, d, a, M[2], 3299628645, 23);
        a = fnI(a, b, c, d, M[0], 4096336452, 6);
        d = fnI(d, a, b, c, M[7], 1126891415, 10);
        c = fnI(c, d, a, b, M[14], 2878612391, 15);
        b = fnI(b, c, d, a, M[5], 4237533241, 21);
        a = fnI(a, b, c, d, M[12], 1700485571, 6);
        d = fnI(d, a, b, c, M[3], 2399980690, 10);
        c = fnI(c, d, a, b, M[10], 4293915773, 15);
        b = fnI(b, c, d, a, M[1], 2240044497, 21);
        a = fnI(a, b, c, d, M[8], 1873313359, 6);
        d = fnI(d, a, b, c, M[15], 4264355552, 10);
        c = fnI(c, d, a, b, M[6], 2734768916, 15);
        b = fnI(b, c, d, a, M[13], 1309151649, 21);
        a = fnI(a, b, c, d, M[4], 4149444226, 6);
        d = fnI(d, a, b, c, M[11], 3174756917, 10);
        c = fnI(c, d, a, b, M[2], 718787259, 15);
        b = fnI(b, c, d, a, M[9], 3951481745, 21);
        this._a = this._a + a | 0;
        this._b = this._b + b | 0;
        this._c = this._c + c | 0;
        this._d = this._d + d | 0;
      };
      MD5.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer4.allocUnsafe(16);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fnF(a, b, c, d, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
      }
      function fnG(a, b, c, d, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
      }
      function fnH(a, b, c, d, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
      }
      function fnI(a, b, c, d, m, k, s) {
        return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
      }
      module.exports = MD5;
    }
  });

  // node_modules/ripemd160/index.js
  var require_ripemd160 = __commonJS({
    "node_modules/ripemd160/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var Buffer4 = require_buffer().Buffer;
      var inherits2 = require_inherits_browser();
      var HashBase = require_hash_base();
      var ARRAY16 = new Array(16);
      var zl = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var zr = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var sl = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sr = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
      var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
      var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
      function RIPEMD160() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
      }
      inherits2(RIPEMD160, HashBase);
      RIPEMD160.prototype._update = function() {
        var words = ARRAY16;
        for (var j = 0; j < 16; ++j)
          words[j] = this._block.readInt32LE(j * 4);
        var al = this._a | 0;
        var bl = this._b | 0;
        var cl = this._c | 0;
        var dl = this._d | 0;
        var el = this._e | 0;
        var ar = this._a | 0;
        var br = this._b | 0;
        var cr = this._c | 0;
        var dr = this._d | 0;
        var er = this._e | 0;
        for (var i = 0; i < 80; i += 1) {
          var tl;
          var tr;
          if (i < 16) {
            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
          } else if (i < 32) {
            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
          } else if (i < 48) {
            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
          } else if (i < 64) {
            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
          } else {
            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
          }
          al = el;
          el = dl;
          dl = rotl(cl, 10);
          cl = bl;
          bl = tl;
          ar = er;
          er = dr;
          dr = rotl(cr, 10);
          cr = br;
          br = tr;
        }
        var t = this._b + cl + dr | 0;
        this._b = this._c + dl + er | 0;
        this._c = this._d + el + ar | 0;
        this._d = this._e + al + br | 0;
        this._e = this._a + bl + cr | 0;
        this._a = t;
      };
      RIPEMD160.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer4.alloc ? Buffer4.alloc(20) : new Buffer4(20);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        buffer.writeInt32LE(this._e, 16);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fn1(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
      }
      function fn2(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
      }
      function fn3(a, b, c, d, e, m, k, s) {
        return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
      }
      function fn4(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
      }
      function fn5(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
      }
      module.exports = RIPEMD160;
    }
  });

  // node_modules/sha.js/hash.js
  var require_hash = __commonJS({
    "node_modules/sha.js/hash.js"(exports, module) {
      init_esbuild_inject();
      var Buffer4 = require_safe_buffer().Buffer;
      function Hash(blockSize, finalSize) {
        this._block = Buffer4.alloc(blockSize);
        this._finalSize = finalSize;
        this._blockSize = blockSize;
        this._len = 0;
      }
      Hash.prototype.update = function(data, enc) {
        if (typeof data === "string") {
          enc = enc || "utf8";
          data = Buffer4.from(data, enc);
        }
        var block = this._block;
        var blockSize = this._blockSize;
        var length = data.length;
        var accum = this._len;
        for (var offset = 0; offset < length; ) {
          var assigned = accum % blockSize;
          var remainder = Math.min(length - offset, blockSize - assigned);
          for (var i = 0; i < remainder; i++) {
            block[assigned + i] = data[offset + i];
          }
          accum += remainder;
          offset += remainder;
          if (accum % blockSize === 0) {
            this._update(block);
          }
        }
        this._len += length;
        return this;
      };
      Hash.prototype.digest = function(enc) {
        var rem = this._len % this._blockSize;
        this._block[rem] = 128;
        this._block.fill(0, rem + 1);
        if (rem >= this._finalSize) {
          this._update(this._block);
          this._block.fill(0);
        }
        var bits = this._len * 8;
        if (bits <= 4294967295) {
          this._block.writeUInt32BE(bits, this._blockSize - 4);
        } else {
          var lowBits = (bits & 4294967295) >>> 0;
          var highBits = (bits - lowBits) / 4294967296;
          this._block.writeUInt32BE(highBits, this._blockSize - 8);
          this._block.writeUInt32BE(lowBits, this._blockSize - 4);
        }
        this._update(this._block);
        var hash = this._hash();
        return enc ? hash.toString(enc) : hash;
      };
      Hash.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
      };
      module.exports = Hash;
    }
  });

  // node_modules/sha.js/sha.js
  var require_sha = __commonJS({
    "node_modules/sha.js/sha.js"(exports, module) {
      init_esbuild_inject();
      var inherits2 = require_inherits_browser();
      var Hash = require_hash();
      var Buffer4 = require_safe_buffer().Buffer;
      var K = [
        1518500249,
        1859775393,
        2400959708 | 0,
        3395469782 | 0
      ];
      var W = new Array(80);
      function Sha() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha, Hash);
      Sha.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 80; ++i)
          W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha.prototype._hash = function() {
        var H = Buffer4.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module.exports = Sha;
    }
  });

  // node_modules/sha.js/sha1.js
  var require_sha1 = __commonJS({
    "node_modules/sha.js/sha1.js"(exports, module) {
      init_esbuild_inject();
      var inherits2 = require_inherits_browser();
      var Hash = require_hash();
      var Buffer4 = require_safe_buffer().Buffer;
      var K = [
        1518500249,
        1859775393,
        2400959708 | 0,
        3395469782 | 0
      ];
      var W = new Array(80);
      function Sha1() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha1, Hash);
      Sha1.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl1(num) {
        return num << 1 | num >>> 31;
      }
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha1.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 80; ++i)
          W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha1.prototype._hash = function() {
        var H = Buffer4.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module.exports = Sha1;
    }
  });

  // node_modules/sha.js/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/sha.js/sha256.js"(exports, module) {
      init_esbuild_inject();
      var inherits2 = require_inherits_browser();
      var Hash = require_hash();
      var Buffer4 = require_safe_buffer().Buffer;
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var W = new Array(64);
      function Sha256() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha256, Hash);
      Sha256.prototype.init = function() {
        this._a = 1779033703;
        this._b = 3144134277;
        this._c = 1013904242;
        this._d = 2773480762;
        this._e = 1359893119;
        this._f = 2600822924;
        this._g = 528734635;
        this._h = 1541459225;
        return this;
      };
      function ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x) {
        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
      }
      function sigma1(x) {
        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
      }
      function gamma0(x) {
        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
      }
      function gamma1(x) {
        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
      }
      Sha256.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        var f = this._f | 0;
        var g = this._g | 0;
        var h = this._h | 0;
        for (var i = 0; i < 16; ++i)
          W2[i] = M.readInt32BE(i * 4);
        for (; i < 64; ++i)
          W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
        for (var j = 0; j < 64; ++j) {
          var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
          var T2 = sigma0(a) + maj(a, b, c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + T1 | 0;
          d = c;
          c = b;
          b = a;
          a = T1 + T2 | 0;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
        this._f = f + this._f | 0;
        this._g = g + this._g | 0;
        this._h = h + this._h | 0;
      };
      Sha256.prototype._hash = function() {
        var H = Buffer4.allocUnsafe(32);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        H.writeInt32BE(this._h, 28);
        return H;
      };
      module.exports = Sha256;
    }
  });

  // node_modules/sha.js/sha224.js
  var require_sha224 = __commonJS({
    "node_modules/sha.js/sha224.js"(exports, module) {
      init_esbuild_inject();
      var inherits2 = require_inherits_browser();
      var Sha256 = require_sha256();
      var Hash = require_hash();
      var Buffer4 = require_safe_buffer().Buffer;
      var W = new Array(64);
      function Sha224() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits2(Sha224, Sha256);
      Sha224.prototype.init = function() {
        this._a = 3238371032;
        this._b = 914150663;
        this._c = 812702999;
        this._d = 4144912697;
        this._e = 4290775857;
        this._f = 1750603025;
        this._g = 1694076839;
        this._h = 3204075428;
        return this;
      };
      Sha224.prototype._hash = function() {
        var H = Buffer4.allocUnsafe(28);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        return H;
      };
      module.exports = Sha224;
    }
  });

  // node_modules/sha.js/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/sha.js/sha512.js"(exports, module) {
      init_esbuild_inject();
      var inherits2 = require_inherits_browser();
      var Hash = require_hash();
      var Buffer4 = require_safe_buffer().Buffer;
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var W = new Array(160);
      function Sha512() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits2(Sha512, Hash);
      Sha512.prototype.init = function() {
        this._ah = 1779033703;
        this._bh = 3144134277;
        this._ch = 1013904242;
        this._dh = 2773480762;
        this._eh = 1359893119;
        this._fh = 2600822924;
        this._gh = 528734635;
        this._hh = 1541459225;
        this._al = 4089235720;
        this._bl = 2227873595;
        this._cl = 4271175723;
        this._dl = 1595750129;
        this._el = 2917565137;
        this._fl = 725511199;
        this._gl = 4215389547;
        this._hl = 327033209;
        return this;
      };
      function Ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x, xl) {
        return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
      }
      function sigma1(x, xl) {
        return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
      }
      function Gamma0(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
      }
      function Gamma0l(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
      }
      function Gamma1(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
      }
      function Gamma1l(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
      }
      function getCarry(a, b) {
        return a >>> 0 < b >>> 0 ? 1 : 0;
      }
      Sha512.prototype._update = function(M) {
        var W2 = this._w;
        var ah = this._ah | 0;
        var bh = this._bh | 0;
        var ch = this._ch | 0;
        var dh = this._dh | 0;
        var eh = this._eh | 0;
        var fh = this._fh | 0;
        var gh = this._gh | 0;
        var hh = this._hh | 0;
        var al = this._al | 0;
        var bl = this._bl | 0;
        var cl = this._cl | 0;
        var dl = this._dl | 0;
        var el = this._el | 0;
        var fl = this._fl | 0;
        var gl = this._gl | 0;
        var hl = this._hl | 0;
        for (var i = 0; i < 32; i += 2) {
          W2[i] = M.readInt32BE(i * 4);
          W2[i + 1] = M.readInt32BE(i * 4 + 4);
        }
        for (; i < 160; i += 2) {
          var xh = W2[i - 15 * 2];
          var xl = W2[i - 15 * 2 + 1];
          var gamma0 = Gamma0(xh, xl);
          var gamma0l = Gamma0l(xl, xh);
          xh = W2[i - 2 * 2];
          xl = W2[i - 2 * 2 + 1];
          var gamma1 = Gamma1(xh, xl);
          var gamma1l = Gamma1l(xl, xh);
          var Wi7h = W2[i - 7 * 2];
          var Wi7l = W2[i - 7 * 2 + 1];
          var Wi16h = W2[i - 16 * 2];
          var Wi16l = W2[i - 16 * 2 + 1];
          var Wil = gamma0l + Wi7l | 0;
          var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
          Wil = Wil + gamma1l | 0;
          Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
          Wil = Wil + Wi16l | 0;
          Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
          W2[i] = Wih;
          W2[i + 1] = Wil;
        }
        for (var j = 0; j < 160; j += 2) {
          Wih = W2[j];
          Wil = W2[j + 1];
          var majh = maj(ah, bh, ch);
          var majl = maj(al, bl, cl);
          var sigma0h = sigma0(ah, al);
          var sigma0l = sigma0(al, ah);
          var sigma1h = sigma1(eh, el);
          var sigma1l = sigma1(el, eh);
          var Kih = K[j];
          var Kil = K[j + 1];
          var chh = Ch(eh, fh, gh);
          var chl = Ch(el, fl, gl);
          var t1l = hl + sigma1l | 0;
          var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
          t1l = t1l + chl | 0;
          t1h = t1h + chh + getCarry(t1l, chl) | 0;
          t1l = t1l + Kil | 0;
          t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
          t1l = t1l + Wil | 0;
          t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
          var t2l = sigma0l + majl | 0;
          var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          el = dl + t1l | 0;
          eh = dh + t1h + getCarry(el, dl) | 0;
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          al = t1l + t2l | 0;
          ah = t1h + t2h + getCarry(al, t1l) | 0;
        }
        this._al = this._al + al | 0;
        this._bl = this._bl + bl | 0;
        this._cl = this._cl + cl | 0;
        this._dl = this._dl + dl | 0;
        this._el = this._el + el | 0;
        this._fl = this._fl + fl | 0;
        this._gl = this._gl + gl | 0;
        this._hl = this._hl + hl | 0;
        this._ah = this._ah + ah + getCarry(this._al, al) | 0;
        this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
        this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
        this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
        this._eh = this._eh + eh + getCarry(this._el, el) | 0;
        this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
        this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
        this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
      };
      Sha512.prototype._hash = function() {
        var H = Buffer4.allocUnsafe(64);
        function writeInt64BE(h, l, offset) {
          H.writeInt32BE(h, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        writeInt64BE(this._gh, this._gl, 48);
        writeInt64BE(this._hh, this._hl, 56);
        return H;
      };
      module.exports = Sha512;
    }
  });

  // node_modules/sha.js/sha384.js
  var require_sha384 = __commonJS({
    "node_modules/sha.js/sha384.js"(exports, module) {
      init_esbuild_inject();
      var inherits2 = require_inherits_browser();
      var SHA512 = require_sha512();
      var Hash = require_hash();
      var Buffer4 = require_safe_buffer().Buffer;
      var W = new Array(160);
      function Sha384() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits2(Sha384, SHA512);
      Sha384.prototype.init = function() {
        this._ah = 3418070365;
        this._bh = 1654270250;
        this._ch = 2438529370;
        this._dh = 355462360;
        this._eh = 1731405415;
        this._fh = 2394180231;
        this._gh = 3675008525;
        this._hh = 1203062813;
        this._al = 3238371032;
        this._bl = 914150663;
        this._cl = 812702999;
        this._dl = 4144912697;
        this._el = 4290775857;
        this._fl = 1750603025;
        this._gl = 1694076839;
        this._hl = 3204075428;
        return this;
      };
      Sha384.prototype._hash = function() {
        var H = Buffer4.allocUnsafe(48);
        function writeInt64BE(h, l, offset) {
          H.writeInt32BE(h, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        return H;
      };
      module.exports = Sha384;
    }
  });

  // node_modules/sha.js/index.js
  var require_sha2 = __commonJS({
    "node_modules/sha.js/index.js"(exports, module) {
      init_esbuild_inject();
      var exports = module.exports = function SHA(algorithm) {
        algorithm = algorithm.toLowerCase();
        var Algorithm = exports[algorithm];
        if (!Algorithm)
          throw new Error(algorithm + " is not supported (we accept pull requests)");
        return new Algorithm();
      };
      exports.sha = require_sha();
      exports.sha1 = require_sha1();
      exports.sha224 = require_sha224();
      exports.sha256 = require_sha256();
      exports.sha384 = require_sha384();
      exports.sha512 = require_sha512();
    }
  });

  // node-modules-polyfills-commonjs:string_decoder
  var require_string_decoder2 = __commonJS({
    "node-modules-polyfills-commonjs:string_decoder"(exports, module) {
      init_esbuild_inject();
      var polyfill = (init_string_decoder(), __toCommonJS(string_decoder_exports));
      if (polyfill && polyfill.default) {
        module.exports = polyfill.default;
        for (let k in polyfill) {
          module.exports[k] = polyfill[k];
        }
      } else if (polyfill) {
        module.exports = polyfill;
      }
    }
  });

  // node_modules/cipher-base/index.js
  var require_cipher_base = __commonJS({
    "node_modules/cipher-base/index.js"(exports, module) {
      init_esbuild_inject();
      var Buffer4 = require_safe_buffer().Buffer;
      var Transform2 = require_stream().Transform;
      var StringDecoder2 = require_string_decoder2().StringDecoder;
      var inherits2 = require_inherits_browser();
      function CipherBase(hashMode) {
        Transform2.call(this);
        this.hashMode = typeof hashMode === "string";
        if (this.hashMode) {
          this[hashMode] = this._finalOrDigest;
        } else {
          this.final = this._finalOrDigest;
        }
        if (this._final) {
          this.__final = this._final;
          this._final = null;
        }
        this._decoder = null;
        this._encoding = null;
      }
      inherits2(CipherBase, Transform2);
      CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
        if (typeof data === "string") {
          data = Buffer4.from(data, inputEnc);
        }
        var outData = this._update(data);
        if (this.hashMode)
          return this;
        if (outputEnc) {
          outData = this._toString(outData, outputEnc);
        }
        return outData;
      };
      CipherBase.prototype.setAutoPadding = function() {
      };
      CipherBase.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
      };
      CipherBase.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
      };
      CipherBase.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
      };
      CipherBase.prototype._transform = function(data, _, next) {
        var err;
        try {
          if (this.hashMode) {
            this._update(data);
          } else {
            this.push(this._update(data));
          }
        } catch (e) {
          err = e;
        } finally {
          next(err);
        }
      };
      CipherBase.prototype._flush = function(done2) {
        var err;
        try {
          this.push(this.__final());
        } catch (e) {
          err = e;
        }
        done2(err);
      };
      CipherBase.prototype._finalOrDigest = function(outputEnc) {
        var outData = this.__final() || Buffer4.alloc(0);
        if (outputEnc) {
          outData = this._toString(outData, outputEnc, true);
        }
        return outData;
      };
      CipherBase.prototype._toString = function(value, enc, fin) {
        if (!this._decoder) {
          this._decoder = new StringDecoder2(enc);
          this._encoding = enc;
        }
        if (this._encoding !== enc)
          throw new Error("can't switch encodings");
        var out = this._decoder.write(value);
        if (fin) {
          out += this._decoder.end();
        }
        return out;
      };
      module.exports = CipherBase;
    }
  });

  // node_modules/create-hash/browser.js
  var require_browser9 = __commonJS({
    "node_modules/create-hash/browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var inherits2 = require_inherits_browser();
      var MD5 = require_md5();
      var RIPEMD160 = require_ripemd160();
      var sha = require_sha2();
      var Base = require_cipher_base();
      function Hash(hash) {
        Base.call(this, "digest");
        this._hash = hash;
      }
      inherits2(Hash, Base);
      Hash.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hash.prototype._final = function() {
        return this._hash.digest();
      };
      module.exports = function createHash(alg) {
        alg = alg.toLowerCase();
        if (alg === "md5")
          return new MD5();
        if (alg === "rmd160" || alg === "ripemd160")
          return new RIPEMD160();
        return new Hash(sha(alg));
      };
    }
  });

  // node_modules/bs58check/base.js
  var require_base = __commonJS({
    "node_modules/bs58check/base.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var base58 = require_bs58();
      var Buffer4 = require_safe_buffer().Buffer;
      module.exports = function(checksumFn) {
        function encode3(payload) {
          var checksum = checksumFn(payload);
          return base58.encode(Buffer4.concat([
            payload,
            checksum
          ], payload.length + 4));
        }
        function decodeRaw(buffer) {
          var payload = buffer.slice(0, -4);
          var checksum = buffer.slice(-4);
          var newChecksum = checksumFn(payload);
          if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3])
            return;
          return payload;
        }
        function decodeUnsafe(string) {
          var buffer = base58.decodeUnsafe(string);
          if (!buffer)
            return;
          return decodeRaw(buffer);
        }
        function decode2(string) {
          var buffer = base58.decode(string);
          var payload = decodeRaw(buffer, checksumFn);
          if (!payload)
            throw new Error("Invalid checksum");
          return payload;
        }
        return {
          encode: encode3,
          decode: decode2,
          decodeUnsafe
        };
      };
    }
  });

  // node_modules/bs58check/index.js
  var require_bs58check = __commonJS({
    "node_modules/bs58check/index.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var createHash = require_browser9();
      var bs58checkBase = require_base();
      function sha256x2(buffer) {
        var tmp = createHash("sha256").update(buffer).digest();
        return createHash("sha256").update(tmp).digest();
      }
      module.exports = bs58checkBase(sha256x2);
    }
  });

  // node_modules/bugout/index.js
  var require_bugout = __commonJS({
    "node_modules/bugout/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = Bugout2;
      var debug2 = require_browser2()("bugout");
      var WebTorrent = require_webtorrent();
      var bencode = require_lib();
      var nacl = require_nacl_fast();
      var EventEmitter2 = require_events().EventEmitter;
      var inherits2 = require_inherits_browser();
      var bs58 = require_bs58();
      var bs58check = require_bs58check();
      var ripemd160 = require_ripemd160();
      inherits2(Bugout2, EventEmitter2);
      var EXT = "bo_channel";
      var PEERTIMEOUT = 5 * 60 * 1e3;
      var SEEDPREFIX = "490a";
      var ADDRESSPREFIX = "55";
      function Bugout2(identifier, opts) {
        if (identifier && typeof identifier == "object") {
          opts = identifier;
          identifier = null;
        }
        var opts = opts || {};
        if (!(this instanceof Bugout2))
          return new Bugout2(identifier, opts);
        var trackeropts = opts.tracker || {};
        if (opts.iceServers) {
          trackeropts.rtcConfig = { iceServers: opts.iceServers };
        }
        this.announce = opts.announce || ["wss://hub.bugout.link", "wss://tracker.openwebtorrent.com", "wss://tracker.btorrent.xyz"];
        this.wt = opts.wt;
        this.nacl = nacl;
        if (opts["seed"]) {
          this.seed = opts["seed"];
        } else {
          this.seed = this.encodeseed(nacl.randomBytes(32));
        }
        this.timeout = opts["timeout"] || PEERTIMEOUT;
        this.keyPair = opts["keyPair"] || nacl.sign.keyPair.fromSeed(Uint8Array.from(bs58check.decode(this.seed)).slice(2));
        this.keyPairEncrypt = nacl.box.keyPair();
        this.pk = bs58.encode(Buffer3.from(this.keyPair.publicKey));
        this.ek = bs58.encode(Buffer3.from(this.keyPairEncrypt.publicKey));
        this.identifier = identifier || this.address();
        this.peers = {};
        this.seen = {};
        this.lastwirecount = null;
        this.api = {};
        this.callbacks = {};
        this.serveraddress = null;
        this.heartbeattimer = null;
        debug2("address", this.address());
        debug2("identifier", this.identifier);
        debug2("public key", this.pk);
        debug2("encryption key", this.ek);
        if (typeof File == "object") {
          var blob = new File([this.identifier], this.identifier);
        } else {
          var blob = new Buffer3.from(this.identifier);
          blob.name = this.identifier;
        }
        if (opts.torrent) {
          this.torrent = opts.torrent;
          this.torrentCreated = false;
          if (this.torrent.ready) {
            this._onTorrent();
          } else {
            this.torrent.on("ready", this._onTorrent.bind(this));
          }
          this.torrent.wires.forEach((wire) => {
            attach(this, this.identifier, wire, wire.addr);
          });
        } else {
          this.wt = this.wt || new WebTorrent(Object.assign({ tracker: trackeropts }, opts["wtOpts"] || {}));
          this.torrent = this.wt.seed(blob, Object.assign({ "name": this.identifier, "announce": this.announce }, opts["torrentOpts"] || {}), partial(function(bugout, torrent) {
            bugout._onTorrent();
          }, this));
          this.torrentCreated = true;
        }
        this.torrent.on("wire", partial(attach, this, this.identifier));
        if (opts.heartbeat) {
          this.heartbeat(opts.heartbeat);
        }
      }
      Bugout2.prototype.WebTorrent = WebTorrent;
      Bugout2.prototype._onTorrent = function() {
        debug2("torrent", this.identifier, this.torrent);
        this.emit("torrent", this.identifier, this.torrent);
        if (this.torrent.discovery.tracker) {
          this.torrent.discovery.tracker.on("update", partial(function(bugout, update) {
            bugout.emit("tracker", bugout.identifier, update);
          }, this));
        }
        this.torrent.discovery.on("trackerAnnounce", partial(function(bugout) {
          bugout.emit("announce", bugout.identifier);
          bugout.connections();
        }, this));
      };
      Bugout2.encodeseed = Bugout2.prototype.encodeseed = function(material) {
        return bs58check.encode(Buffer3.concat([Buffer3.from(SEEDPREFIX, "hex"), Buffer3.from(material)]));
      };
      Bugout2.encodeaddress = Bugout2.prototype.encodeaddress = function(material) {
        return bs58check.encode(Buffer3.concat([Buffer3.from(ADDRESSPREFIX, "hex"), new ripemd160().update(Buffer3.from(nacl.hash(material))).digest()]));
      };
      Bugout2.prototype.heartbeat = function(interval) {
        var interval = interval || 3e4;
        this.heartbeattimer = setInterval(partial(function(bugout) {
          bugout.ping();
          var t = now();
          for (var p in bugout.peers) {
            var pk = bugout.peers[p].pk;
            var address = bugout.address(pk);
            var last = bugout.peers[p].last;
            if (last + interval < t) {
              delete bugout.peers[p];
              bugout.emit("timeout", address);
              bugout.emit("left", address);
            }
          }
        }, this), interval);
      };
      Bugout2.prototype.destroy = function(cb) {
        clearInterval(this.heartbeattimer);
        var packet = makePacket(this, { "y": "x" });
        sendRaw(this, packet);
        if (this.wt && this.torrentCreated) {
          this.wt.remove(this.torrent, cb);
        }
      };
      Bugout2.prototype.close = Bugout2.prototype.destroy;
      Bugout2.prototype.connections = function() {
        if (this.torrent.wires.length != this.lastwirecount) {
          this.lastwirecount = this.torrent.wires.length;
          this.emit("connections", this.torrent.wires.length);
        }
        return this.lastwirecount;
      };
      Bugout2.prototype.address = function(pk) {
        if (pk && typeof pk == "string") {
          pk = bs58.decode(pk);
        } else if (pk && pk.length == 32) {
          pk = pk;
        } else {
          pk = this.keyPair.publicKey;
        }
        return this.encodeaddress(pk);
      };
      Bugout2.address = Bugout2.prototype.address;
      Bugout2.prototype.ping = function() {
        var packet = makePacket(this, { "y": "p" });
        sendRaw(this, packet);
      };
      Bugout2.prototype.send = function(address, message) {
        if (!message) {
          var message = address;
          var address = null;
        }
        var packet = makePacket(this, { "y": "m", "v": JSON.stringify(message) });
        if (address) {
          if (this.peers[address]) {
            packet = encryptPacket(this, this.peers[address].pk, packet);
          } else {
            throw address + " not seen - no public key.";
          }
        }
        sendRaw(this, packet);
      };
      Bugout2.prototype.register = function(call, fn, docstring) {
        this.api[call] = fn;
        this.api[call].docstring = docstring;
      };
      Bugout2.prototype.rpc = function(address, call, args, callback) {
        if (this.serveraddress && typeof args == "function") {
          callback = args;
          args = call;
          call = address;
          address = this.serveraddress;
        }
        if (this.peers[address]) {
          var pk = this.peers[address].pk;
          var callnonce = nacl.randomBytes(8);
          this.callbacks[toHex2(callnonce)] = callback;
          makeEncryptSendPacket(this, pk, { "y": "r", "c": call, "a": JSON.stringify(args), "rn": callnonce });
        } else {
          throw address + " not seen - no public key.";
        }
      };
      function makePacket(bugout, params) {
        var p = {
          "t": now(),
          "i": bugout.identifier,
          "pk": bugout.pk,
          "ek": bugout.ek,
          "n": nacl.randomBytes(8)
        };
        for (var k in params) {
          p[k] = params[k];
        }
        var pe = bencode.encode(p);
        return bencode.encode({
          "s": nacl.sign.detached(pe, bugout.keyPair.secretKey),
          "p": pe
        });
      }
      function encryptPacket(bugout, pk, packet) {
        if (bugout.peers[bugout.address(pk)]) {
          var nonce = nacl.randomBytes(nacl.box.nonceLength);
          packet = bencode.encode({
            "n": nonce,
            "ek": bs58.encode(Buffer3.from(bugout.keyPairEncrypt.publicKey)),
            "e": nacl.box(packet, nonce, bs58.decode(bugout.peers[bugout.address(pk)].ek), bugout.keyPairEncrypt.secretKey)
          });
        } else {
          throw bugout.address(pk) + " not seen - no encryption key.";
        }
        return packet;
      }
      function sendRaw(bugout, message) {
        var wires = bugout.torrent.wires;
        for (var w = 0; w < wires.length; w++) {
          var extendedhandshake = wires[w]["peerExtendedHandshake"];
          if (extendedhandshake && extendedhandshake.m && extendedhandshake.m[EXT]) {
            wires[w].extended(EXT, message);
          }
        }
        var hash = toHex2(nacl.hash(message).slice(16));
        debug2("sent", hash, "to", wires.length, "wires");
      }
      function makeEncryptSendPacket(bugout, pk, packet) {
        packet = makePacket(bugout, packet);
        packet = encryptPacket(bugout, pk, packet);
        sendRaw(bugout, packet);
      }
      function onMessage(bugout, identifier, wire, message) {
        var hash = toHex2(nacl.hash(message).slice(16));
        var t = now();
        debug2("raw message", identifier, message.length, hash);
        if (!bugout.seen[hash]) {
          var unpacked = bencode.decode(message);
          if (unpacked.e && unpacked.n && unpacked.ek) {
            var ek = unpacked.ek.toString();
            debug2("message encrypted by", ek, unpacked);
            var decrypted = nacl.box.open(unpacked.e, unpacked.n, bs58.decode(ek), bugout.keyPairEncrypt.secretKey);
            if (decrypted) {
              unpacked = bencode.decode(decrypted);
            } else {
              unpacked = null;
            }
          }
          if (unpacked && unpacked.p) {
            debug2("unpacked message", unpacked);
            var packet = bencode.decode(unpacked.p);
            var pk = packet.pk.toString();
            var id = packet.i.toString();
            var checksig = nacl.sign.detached.verify(unpacked.p, unpacked.s, bs58.decode(pk));
            var checkid = id == identifier;
            var checktime = packet.t + bugout.timeout > t;
            debug2("packet", packet);
            if (checksig && checkid && checktime) {
              var ek = packet.ek.toString();
              sawPeer(bugout, pk, ek, identifier);
              if (packet.y == "m") {
                debug2("message", identifier, packet);
                var messagestring = packet.v.toString();
                var messagejson = null;
                try {
                  var messagejson = JSON.parse(messagestring);
                } catch (e) {
                  debug2("Malformed message JSON: " + messagestring);
                }
                if (messagejson) {
                  bugout.emit("message", bugout.address(pk), messagejson, packet);
                }
              } else if (packet.y == "r") {
                debug2("rpc", identifier, packet);
                var call = packet.c.toString();
                var argsstring = packet.a.toString();
                try {
                  var args = JSON.parse(argsstring);
                } catch (e) {
                  var args = null;
                  debug2("Malformed args JSON: " + argsstring);
                }
                var nonce = packet.rn;
                bugout.emit("rpc", bugout.address(pk), call, args, toHex2(nonce));
                rpcCall(bugout, pk, call, args, nonce);
              } else if (packet.y == "rr") {
                var nonce = toHex2(packet.rn);
                if (bugout.callbacks[nonce]) {
                  if (typeof packet["rr"] != "undefined") {
                    var responsestring = packet.rr.toString();
                  } else {
                    debug2("Empty rr in rpc response.");
                  }
                  try {
                    var responsestringstruct = JSON.parse(responsestring);
                  } catch (e) {
                    debug2("Malformed response JSON: " + responsestring);
                    var responsestringstruct = null;
                  }
                  if (bugout.callbacks[nonce] && responsestringstruct) {
                    debug2("rpc-response", bugout.address(pk), nonce, responsestringstruct);
                    bugout.emit("rpc-response", bugout.address(pk), nonce, responsestringstruct);
                    bugout.callbacks[nonce](responsestringstruct);
                    delete bugout.callbacks[nonce];
                  } else {
                    debug2("RPC response nonce not known:", nonce);
                  }
                } else {
                  debug2("dropped response with no callback.", nonce);
                }
              } else if (packet.y == "p") {
                var address = bugout.address(pk);
                debug2("ping from", address);
                bugout.emit("ping", address);
              } else if (packet.y == "x") {
                var address = bugout.address(pk);
                debug2("got left from", address);
                delete bugout.peers[address];
                bugout.emit("left", address);
              } else {
                debug2("unknown packet type");
              }
            } else {
              debug2("dropping bad packet", hash, checksig, checkid, checktime);
            }
          } else {
            debug2("skipping packet with no payload", hash, unpacked);
          }
          sendRaw(bugout, message);
        } else {
          debug2("already seen", hash);
        }
        bugout.seen[hash] = now();
      }
      function rpcCall(bugout, pk, call, args, nonce, callback) {
        var packet = { "y": "rr", "rn": nonce };
        if (bugout.api[call]) {
          bugout.api[call](bugout.address(pk), args, function(result) {
            packet["rr"] = JSON.stringify(result);
            makeEncryptSendPacket(bugout, pk, packet);
          });
        } else {
          packet["rr"] = JSON.stringify({ "error": "No such API call." });
          makeEncryptSendPacket(bugout, pk, packet);
        }
      }
      function sawPeer(bugout, pk, ek, identifier) {
        debug2("sawPeer", bugout.address(pk), ek);
        var t = now();
        var address = bugout.address(pk);
        if (address != bugout.address()) {
          if (!bugout.peers[address] || bugout.peers[address].last + bugout.timeout < t) {
            bugout.peers[address] = {
              "ek": ek,
              "pk": pk,
              "last": t
            };
            debug2("seen", bugout.address(pk));
            bugout.emit("seen", bugout.address(pk));
            if (bugout.address(pk) == bugout.identifier) {
              bugout.serveraddress = address;
              debug2("seen server", bugout.address(pk));
              bugout.emit("server", bugout.address(pk));
            }
            var packet = makePacket(bugout, { "y": "p" });
            sendRaw(bugout, packet);
          } else {
            bugout.peers[address].ek = ek;
            bugout.peers[address].last = t;
          }
        }
      }
      function attach(bugout, identifier, wire, addr) {
        debug2("saw wire", wire.peerId, identifier);
        wire.use(extension(bugout, identifier, wire));
        wire.on("close", partial(detach, bugout, identifier, wire));
      }
      function detach(bugout, identifier, wire) {
        debug2("wire left", wire.peerId, identifier);
        bugout.emit("wireleft", bugout.torrent.wires.length, wire);
        bugout.connections();
      }
      function extension(bugout, identifier, wire) {
        var ext = partial(wirefn, bugout, identifier);
        ext.prototype.name = EXT;
        ext.prototype.onExtendedHandshake = partial(onExtendedHandshake, bugout, identifier, wire);
        ext.prototype.onMessage = partial(onMessage, bugout, identifier, wire);
        return ext;
      }
      function wirefn(bugout, identifier, wire) {
        wire.extendedHandshake.id = identifier;
        wire.extendedHandshake.pk = bugout.pk;
        wire.extendedHandshake.ek = bugout.ek;
      }
      function onExtendedHandshake(bugout, identifier, wire, handshake) {
        debug2("wire extended handshake", bugout.address(handshake.pk.toString()), wire.peerId, handshake);
        bugout.emit("wireseen", bugout.torrent.wires.length, wire);
        bugout.connections();
        sawPeer(bugout, handshake.pk.toString(), handshake.ek.toString(), identifier);
      }
      function now() {
        return new Date().getTime();
      }
      function toHex2(x) {
        return x.reduce(function(memo, i) {
          return memo + ("0" + i.toString(16)).slice(-2);
        }, "");
      }
      function partial(fn) {
        var slice2 = Array.prototype.slice;
        var stored_args = slice2.call(arguments, 1);
        return function() {
          var new_args = slice2.call(arguments);
          var args = stored_args.concat(new_args);
          return fn.apply(null, args);
        };
      }
    }
  });

  // node_modules/octokat/dist/node/deprecate.js
  var require_deprecate = __commonJS({
    "node_modules/octokat/dist/node/deprecate.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = function(message) {
        if (console && console.warn) {
          console.warn("Octokat Deprecation: " + message);
        }
      };
    }
  });

  // node_modules/octokat/dist/node/adapters/fetch-browser.js
  var require_fetch_browser = __commonJS({
    "node_modules/octokat/dist/node/adapters/fetch-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      if (typeof window.fetch === "function") {
        module.exports = window.fetch.bind(window);
      } else {
        module.exports = function() {
          throw new Error("Octokat Error: window.fetch function not found. Either use the https://npmjs.com/package/whatwg-fetch polyfill or set Octokat.Fetch variable to be the fetch function");
        };
      }
    }
  });

  // node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/lodash/_arrayFilter.js"(exports, module) {
      init_esbuild_inject();
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module.exports = arrayFilter;
    }
  });

  // node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "node_modules/lodash/_arrayEach.js"(exports, module) {
      init_esbuild_inject();
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      module.exports = arrayEach;
    }
  });

  // node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/lodash/_arrayMap.js"(exports, module) {
      init_esbuild_inject();
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      module.exports = arrayMap;
    }
  });

  // node_modules/octokat/dist/node/plus.js
  var require_plus = __commonJS({
    "node_modules/octokat/dist/node/plus.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var filter2 = require_arrayFilter();
      var forEach2 = require_arrayEach();
      var map3 = require_arrayMap();
      var plus = {
        camelize: function camelize(string) {
          if (string) {
            return string.replace(/[_-]+(\w)/g, function(m) {
              return m[1].toUpperCase();
            });
          } else {
            return "";
          }
        },
        uncamelize: function uncamelize(string) {
          if (!string) {
            return "";
          }
          return string.replace(/([A-Z])+/g, function(match) {
            var letter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            return "_" + letter.toLowerCase();
          });
        },
        dasherize: function dasherize(string) {
          if (!string) {
            return "";
          }
          string = string[0].toLowerCase() + string.slice(1);
          return string.replace(/([A-Z])|(_)/g, function(m, letter) {
            if (letter) {
              return "-" + letter.toLowerCase();
            } else {
              return "-";
            }
          });
        },
        extend: function extend(target, source) {
          if (source) {
            return Object.keys(source).map(function(key) {
              target[key] = source[key];
            });
          }
        },
        forOwn: function forOwn(obj, iterator) {
          return Object.keys(obj).map(function(key) {
            return iterator(obj[key], key);
          });
        },
        filter: filter2,
        forEach: forEach2,
        map: map3
      };
      module.exports = plus;
    }
  });

  // node_modules/octokat/dist/node/grammar/tree-options.js
  var require_tree_options = __commonJS({
    "node_modules/octokat/dist/node/grammar/tree-options.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _module$exports;
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var REPO_FIELDS = {
        "readme": false,
        "tarball": false,
        "zipball": false,
        "compare": false,
        "deployments": {
          "statuses": false
        },
        "hooks": {
          "tests": false
        },
        "assignees": false,
        "languages": false,
        "teams": false,
        "tags": false,
        "branches": false,
        "contributors": false,
        "subscribers": false,
        "subscription": false,
        "stargazers": false,
        "comments": false,
        "downloads": false,
        "forks": false,
        "milestones": {
          "labels": false
        },
        "labels": false,
        "releases": {
          "assets": false,
          "latest": false,
          "tags": false
        },
        "events": false,
        "notifications": false,
        "merges": false,
        "statuses": false,
        "pulls": {
          "merge": false,
          "comments": false,
          "commits": false,
          "files": false,
          "events": false,
          "labels": false,
          "requested_reviewers": false,
          "reviews": {
            "comments": false,
            "events": false,
            "dismissals": false
          }
        },
        "pages": {
          "builds": {
            "latest": false
          }
        },
        "commits": {
          "comments": false,
          "status": false,
          "statuses": false
        },
        "contents": false,
        "collaborators": {
          "permission": false
        },
        "projects": false,
        "issues": {
          "events": false,
          "comments": false,
          "labels": false
        },
        "git": {
          "refs": {
            "heads": false,
            "tags": false
          },
          "trees": false,
          "blobs": false,
          "commits": false
        },
        "stats": {
          "contributors": false,
          "commit_activity": false,
          "code_frequency": false,
          "participation": false,
          "punch_card": false
        },
        "traffic": {
          "popular": {
            "referrers": false,
            "paths": false
          },
          "views": false,
          "clones": false
        }
      };
      module.exports = (_module$exports = {
        "zen": false,
        "octocat": false,
        "organizations": false,
        "issues": false,
        "emojis": false,
        "markdown": false,
        "meta": false,
        "rate_limit": false,
        "feeds": false,
        "events": false,
        "repositories": false,
        "notifications": {
          "threads": {
            "subscription": false
          }
        },
        "gitignore": {
          "templates": false
        },
        "user": {
          "repos": false,
          "orgs": false,
          "followers": false,
          "following": false,
          "emails": false,
          "issues": false,
          "public_emails": false,
          "starred": false,
          "teams": false
        },
        "orgs": {
          "repos": false,
          "issues": false,
          "members": false,
          "events": false,
          "projects": false,
          "teams": false
        },
        "projects": {
          "columns": {
            "moves": false,
            "cards": {
              "moves": false
            }
          }
        },
        "teams": {
          "members": false,
          "memberships": false,
          "repos": false
        },
        "users": {
          "repos": false,
          "orgs": false,
          "gists": false,
          "followers": false,
          "following": false,
          "keys": false,
          "starred": false,
          "received_events": {
            "public": false
          },
          "events": {
            "public": false,
            "orgs": false
          },
          "site_admin": false,
          "suspended": false
        },
        "search": {
          "repositories": false,
          "commits": false,
          "issues": false,
          "users": false,
          "code": false
        },
        "gists": {
          "public": false,
          "starred": false,
          "star": false,
          "comments": false,
          "forks": false
        },
        "repos": REPO_FIELDS
      }, _defineProperty(_module$exports, "repositories", REPO_FIELDS), _defineProperty(_module$exports, "licenses", false), _defineProperty(_module$exports, "authorizations", {
        "clients": false
      }), _defineProperty(_module$exports, "applications", {
        "tokens": false
      }), _defineProperty(_module$exports, "enterprise", {
        "settings": {
          "license": false
        },
        "stats": {
          "issues": false,
          "hooks": false,
          "milestones": false,
          "orgs": false,
          "comments": false,
          "pages": false,
          "users": false,
          "gists": false,
          "pulls": false,
          "repos": false,
          "all": false
        }
      }), _defineProperty(_module$exports, "staff", {
        "indexing_jobs": false
      }), _defineProperty(_module$exports, "setup", {
        "api": {
          "start": false,
          "upgrade": false,
          "configcheck": false,
          "configure": false,
          "settings": {
            "authorized-keys": false
          },
          "maintenance": false
        }
      }), _module$exports);
    }
  });

  // node_modules/octokat/dist/node/chainer.js
  var require_chainer = __commonJS({
    "node_modules/octokat/dist/node/chainer.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var plus = require_plus();
      module.exports = function() {
        function Chainer(_verbMethods) {
          _classCallCheck(this, Chainer);
          this._verbMethods = _verbMethods;
        }
        _createClass(Chainer, [{
          key: "chain",
          value: function chain(path, name, contextTree, fn) {
            var _this = this;
            if (typeof fn === "undefined" || fn === null) {
              fn = function fn2() {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                if (!args.length) {
                  throw new Error("BUG! must be called with at least one argument");
                }
                var separator = "/";
                if (name === "compare") {
                  separator = "...";
                }
                return _this.chain(path + "/" + args.join(separator), name, contextTree);
              };
            }
            this._verbMethods.injectVerbMethods(path, fn);
            if (typeof fn === "function" || (typeof fn === "undefined" ? "undefined" : _typeof(fn)) === "object") {
              for (name in contextTree || {}) {
                (function(name2) {
                  delete fn[plus.camelize(name2)];
                  return Object.defineProperty(fn, plus.camelize(name2), {
                    configurable: true,
                    enumerable: true,
                    get: function get3() {
                      return _this.chain(path + "/" + name2, name2, contextTree[name2]);
                    }
                  });
                })(name);
              }
            }
            return fn;
          }
        }]);
        return Chainer;
      }();
    }
  });

  // node_modules/octokat/dist/node/verb-methods.js
  var require_verb_methods = __commonJS({
    "node_modules/octokat/dist/node/verb-methods.js"(exports) {
      "use strict";
      init_esbuild_inject();
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _require = require_plus();
      var filter2 = _require.filter;
      var forOwn = _require.forOwn;
      var extend = _require.extend;
      var toPromise = function toPromise2(orig) {
        return function() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var last = args[args.length - 1];
          if (typeof last === "function") {
            args.pop();
            return orig.apply(void 0, args).then(function(v) {
              last(null, v);
            }).catch(function(err) {
              last(err);
            });
          } else if (typeof Promise !== "undefined") {
            return orig.apply(void 0, args);
          } else {
            throw new Error("You must specify a callback or have a promise library loaded");
          }
        };
      };
      var VerbMethods = function() {
        function VerbMethods2(plugins, _requester) {
          _classCallCheck(this, VerbMethods2);
          this._requester = _requester;
          if (!this._requester) {
            throw new Error("Octokat BUG: request is required");
          }
          var promisePlugins = filter2(plugins, function(_ref) {
            var promiseCreator = _ref.promiseCreator;
            return promiseCreator;
          });
          if (promisePlugins) {
            this._promisePlugin = promisePlugins[0];
          }
          this._syncVerbs = {};
          var iterable = filter2(plugins, function(_ref2) {
            var verbs = _ref2.verbs;
            return verbs;
          });
          for (var i = 0; i < iterable.length; i++) {
            var plugin = iterable[i];
            extend(this._syncVerbs, plugin.verbs);
          }
          this._asyncVerbs = {};
          var iterable1 = filter2(plugins, function(_ref3) {
            var asyncVerbs = _ref3.asyncVerbs;
            return asyncVerbs;
          });
          for (var j = 0; j < iterable1.length; j++) {
            var _plugin = iterable1[j];
            extend(this._asyncVerbs, _plugin.asyncVerbs);
          }
        }
        _createClass(VerbMethods2, [{
          key: "injectVerbMethods",
          value: function injectVerbMethods(path, obj) {
            var _this = this;
            if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" || typeof obj === "function") {
              obj.url = path;
              forOwn(this._syncVerbs, function(verbFunc, verbName) {
                obj[verbName] = function() {
                  var makeRequest = function makeRequest2() {
                    for (var _len2 = arguments.length, originalArgs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                      originalArgs[_key2] = arguments[_key2];
                    }
                    var data = void 0, method = void 0, options = void 0;
                    var _verbFunc = verbFunc.apply(void 0, [path].concat(originalArgs));
                    method = _verbFunc.method;
                    path = _verbFunc.path;
                    data = _verbFunc.data;
                    options = _verbFunc.options;
                    return _this._requester.request(method, path, data, options);
                  };
                  return toPromise(makeRequest).apply(void 0, arguments);
                };
              });
              forOwn(this._asyncVerbs, function(verbFunc, verbName) {
                obj[verbName] = function() {
                  var makeRequest = verbFunc(_this._requester, path);
                  return toPromise(makeRequest).apply(void 0, arguments);
                };
              });
            } else {
            }
            return obj;
          }
        }]);
        return VerbMethods2;
      }();
      exports.VerbMethods = VerbMethods;
      exports.toPromise = toPromise;
    }
  });

  // node_modules/octokat/dist/node/helpers/querystring.js
  var require_querystring2 = __commonJS({
    "node_modules/octokat/dist/node/helpers/querystring.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var toQueryString = function toQueryString2(options, omitQuestionMark) {
        if (!options || options === {}) {
          return "";
        }
        var params = [];
        var object = options || {};
        for (var key in object) {
          var value = object[key];
          if (value) {
            params.push(key + "=" + encodeURIComponent(value));
          }
        }
        if (params.length) {
          if (omitQuestionMark) {
            return "&" + params.join("&");
          } else {
            return "?" + params.join("&");
          }
        } else {
          return "";
        }
      };
      module.exports = toQueryString;
    }
  });

  // node_modules/octokat/dist/node/plugins/simple-verbs.js
  var require_simple_verbs = __commonJS({
    "node_modules/octokat/dist/node/plugins/simple-verbs.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var toQueryString = require_querystring2();
      module.exports = {
        verbs: {
          fetch: function fetch2(path, query) {
            return { method: "GET", path: "" + path + toQueryString(query) };
          },
          read: function read2(path, query) {
            return { method: "GET", path: "" + path + toQueryString(query), options: { isRaw: true } };
          },
          remove: function remove(path, data) {
            return { method: "DELETE", path, data, options: { isBoolean: true } };
          },
          create: function create(path, data, contentType) {
            if (contentType) {
              return { method: "POST", path, data, options: { isRaw: true, contentType } };
            } else {
              return { method: "POST", path, data };
            }
          },
          update: function update(path, data) {
            return { method: "PATCH", path, data };
          },
          add: function add(path, data) {
            return { method: "PUT", path, data, options: { isBoolean: true } };
          },
          contains: function contains(path) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return { method: "GET", path: path + "/" + args.join("/"), options: { isBoolean: true } };
          }
        }
      };
    }
  });

  // node_modules/octokat/dist/node/requester.js
  var require_requester = __commonJS({
    "node_modules/octokat/dist/node/requester.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var _require = require_plus();
      var filter2 = _require.filter;
      var map3 = _require.map;
      var EVENT_ID = 0;
      module.exports = function() {
        function Requester(_instance) {
          var _clientOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var plugins = arguments[2];
          var fetchImpl = arguments[3];
          _classCallCheck(this, Requester);
          this._instance = _instance;
          this._clientOptions = _clientOptions;
          if (this._clientOptions.rootURL == null) {
            this._clientOptions.rootURL = "https://api.github.com";
          }
          if (this._clientOptions.useETags == null) {
            this._clientOptions.useETags = true;
          }
          if (this._clientOptions.usePostInsteadOfPatch == null) {
            this._clientOptions.usePostInsteadOfPatch = false;
          }
          if (this._clientOptions.userAgent == null) {
            if (typeof window === "undefined" || window === null) {
              this._clientOptions.userAgent = "octokat.js";
            }
          }
          if (typeof this._clientOptions.emitter === "function") {
            this._emit = this._clientOptions.emitter;
          }
          this._pluginMiddlewareAsync = map3(filter2(plugins, function(_ref) {
            var requestMiddlewareAsync = _ref.requestMiddlewareAsync;
            return requestMiddlewareAsync;
          }), function(plugin) {
            return plugin.requestMiddlewareAsync.bind(plugin);
          });
          this._plugins = plugins;
          this._fetchImpl = fetchImpl;
        }
        _createClass(Requester, [{
          key: "request",
          value: function request3(method, path, data) {
            var _this = this;
            var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : { isRaw: false, isBase64: false, isBoolean: false, contentType: "application/json" };
            var cb = arguments[4];
            if (typeof options === "undefined" || options === null) {
              options = {};
            }
            if (options.isRaw == null) {
              options.isRaw = false;
            }
            if (options.isBase64 == null) {
              options.isBase64 = false;
            }
            if (options.isBoolean == null) {
              options.isBoolean = false;
            }
            if (options.contentType == null) {
              options.contentType = "application/json";
            }
            if (!/^http/.test(path)) {
              path = "" + this._clientOptions.rootURL + path;
            }
            var headers = {
              "Accept": this._clientOptions.acceptHeader || "application/json"
            };
            if (this._clientOptions.userAgent) {
              headers["User-Agent"] = this._clientOptions.userAgent;
            }
            var acc = {
              method,
              path,
              headers,
              options,
              clientOptions: this._clientOptions
            };
            var initial = Promise.resolve(acc);
            var prev = initial;
            this._pluginMiddlewareAsync.forEach(function(p) {
              prev = prev.then(p);
            });
            return prev.then(function(acc2) {
              var _acc = acc2;
              method = _acc.method;
              headers = _acc.headers;
              if (options.isRaw) {
                headers["Accept"] = "application/vnd.github.raw";
              }
              var fetchArgs = {
                method,
                headers,
                body: !options.isRaw && data && JSON.stringify(data) || data
              };
              var eventId = ++EVENT_ID;
              __guardFunc__(_this._emit, function(f) {
                return f("start", eventId, { method, path, data, options });
              });
              return _this._fetchImpl(path, fetchArgs).then(function(response) {
                var jqXHR = response;
                if (_this._emit) {
                  if (response.headers.get("X-RateLimit-Limit")) {
                    var rateLimit = parseFloat(response.headers.get("X-RateLimit-Limit"));
                    var rateLimitRemaining = parseFloat(response.headers.get("X-RateLimit-Remaining"));
                    var rateLimitReset = parseFloat(response.headers.get("X-RateLimit-Reset"));
                    var emitterRate = {
                      remaining: rateLimitRemaining,
                      limit: rateLimit,
                      reset: rateLimitReset
                    };
                    if (response.headers.get("X-OAuth-Scopes")) {
                      emitterRate.scopes = response.headers.get("X-OAuth-Scopes").split(", ");
                    }
                  }
                  _this._emit("end", eventId, { method, path, data, options }, response.status, emitterRate);
                }
                if (response.status === 302) {
                  return response.headers.get("Location");
                } else if (options.isBoolean && response.status === 204) {
                  return true;
                } else if (options.isBoolean && response.status === 404) {
                  return false;
                } else if (response.status >= 200 && response.status < 300 || response.status === 304 || response.status === 302 || response.status === 0) {
                  var dataPromise = void 0;
                  if (response.status === 304) {
                    dataPromise = Promise.resolve(null);
                  } else {
                    var contentType = response.headers.get("content-type") || "";
                    if (contentType.indexOf("application/json") === 0) {
                      dataPromise = response.json();
                    } else {
                      dataPromise = response.text();
                    }
                  }
                  return dataPromise.then(function(data2) {
                    acc2 = {
                      clientOptions: _this._clientOptions,
                      plugins: _this._plugins,
                      data: data2,
                      options,
                      jqXHR,
                      status: response.status,
                      request: acc2,
                      requester: _this,
                      instance: _this._instance
                    };
                    return _this._instance._parseWithContextPromise("", acc2);
                  });
                } else {
                  return response.text().then(function(text) {
                    return Promise.reject(new Error(text + " " + fetchArgs.method + " " + path + " Status: " + response.status));
                  });
                }
              });
            });
          }
        }]);
        return Requester;
      }();
      function __guardFunc__(func, transform) {
        return typeof func === "function" ? transform(func) : void 0;
      }
    }
  });

  // node_modules/octokat/dist/node/helpers/hypermedia.js
  var require_hypermedia = __commonJS({
    "node_modules/octokat/dist/node/helpers/hypermedia.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var toQueryString = require_querystring2();
      var deprecate2 = require_deprecate();
      module.exports = function(url) {
        var m = void 0;
        if ((arguments.length <= 1 ? 0 : arguments.length - 1) === 0) {
          var templateParams = {};
        } else {
          if ((arguments.length <= 1 ? 0 : arguments.length - 1) > 1) {
            deprecate2("When filling in a template URL pass all the field to fill in 1 object instead of comma-separated args");
          }
          var templateParams = arguments.length <= 1 ? void 0 : arguments[1];
        }
        var i = 0;
        while (m = /(\{[^\}]+\})/.exec(url)) {
          var match = m[1];
          var param = "";
          switch (match[1]) {
            case "/":
              var fieldName = match.slice(2, match.length - 1);
              var fieldValue = templateParams[fieldName];
              if (fieldValue) {
                if (/\//.test(fieldValue)) {
                  throw new Error("Octokat Error: this field must not contain slashes: " + fieldName);
                }
                param = "/" + fieldValue;
              }
              break;
            case "+":
              fieldName = match.slice(2, match.length - 1);
              fieldValue = templateParams[fieldName];
              if (fieldValue) {
                param = fieldValue;
              }
              break;
            case "?":
              var optionalNames = match.slice(2, -2 + 1).split(",");
              var optionalParams = {};
              for (var j = 0; j < optionalNames.length; j++) {
                fieldName = optionalNames[j];
                optionalParams[fieldName] = templateParams[fieldName];
              }
              param = toQueryString(optionalParams);
              break;
            case "&":
              optionalNames = match.slice(2, -2 + 1).split(",");
              optionalParams = {};
              for (var k = 0; k < optionalNames.length; k++) {
                fieldName = optionalNames[k];
                optionalParams[fieldName] = templateParams[fieldName];
              }
              param = toQueryString(optionalParams, true);
              break;
            default:
              fieldName = match.slice(1, match.length - 1);
              if (templateParams[fieldName]) {
                param = templateParams[fieldName];
              } else {
                throw new Error("Octokat Error: Required parameter is missing: " + fieldName);
              }
          }
          url = url.replace(match, param);
          i++;
        }
        return url;
      };
    }
  });

  // node_modules/octokat/dist/node/base.js
  var require_base2 = __commonJS({
    "node_modules/octokat/dist/node/base.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var fetch2 = require_fetch_browser();
      var plus = require_plus();
      var deprecate2 = require_deprecate();
      var TREE_OPTIONS = require_tree_options();
      var Chainer = require_chainer();
      var _require = require_verb_methods();
      var VerbMethods = _require.VerbMethods;
      var toPromise = _require.toPromise;
      var SimpleVerbsPlugin = require_simple_verbs();
      var Requester = require_requester();
      var applyHypermedia = require_hypermedia();
      var isBuffer3 = function isBuffer4(data) {
        if (typeof globalThis["Buffer"] !== "undefined") {
          return globalThis["Buffer"].isBuffer(data);
        } else {
          return false;
        }
      };
      var uncamelizeObj = function uncamelizeObj2(obj) {
        if (Array.isArray(obj)) {
          return obj.map(function(i) {
            return uncamelizeObj2(i);
          });
        } else if (obj === Object(obj)) {
          var o = {};
          var iterable = Object.keys(obj);
          for (var j = 0; j < iterable.length; j++) {
            var key = iterable[j];
            var value = obj[key];
            o[plus.uncamelize(key)] = uncamelizeObj2(value);
          }
          return o;
        } else {
          return obj;
        }
      };
      var OctokatBase = function OctokatBase2() {
        var clientOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var plugins = clientOptions.plugins || [SimpleVerbsPlugin];
        var disableHypermedia = clientOptions.disableHypermedia;
        if (typeof disableHypermedia === "undefined" || disableHypermedia === null) {
          disableHypermedia = false;
        }
        var instance = {};
        var fetchImpl = OctokatBase2.Fetch || fetch2;
        var request3 = function request4(method, path, data) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : { raw: false, isBase64: false, isBoolean: false };
          var cb = arguments[4];
          if (data && !isBuffer3(data)) {
            data = uncamelizeObj(data);
          }
          var requester = new Requester(instance, clientOptions, plugins, fetchImpl);
          return requester.request(method, path, data, options).then(function(val) {
            if ((options || {}).raw) {
              return val;
            }
            if (!disableHypermedia) {
              var context = {
                data: val,
                plugins,
                requester,
                instance,
                clientOptions
              };
              return instance._parseWithContextPromise(path, context);
            } else {
              return val;
            }
          });
        };
        var verbMethods = new VerbMethods(plugins, { request: request3 });
        new Chainer(verbMethods).chain("", null, TREE_OPTIONS, instance);
        instance.me = instance.user;
        instance.parse = function(data) {
          var context = {
            requester: { request: request3 },
            plugins,
            data,
            instance,
            clientOptions
          };
          return instance._parseWithContextPromise("", context);
        };
        instance.parse = toPromise(instance.parse);
        instance._parseWithContextPromise = function(path, context) {
          var data = context.data;
          if (data) {
            context.url = data.url || path;
          }
          var responseMiddlewareAsyncs = plus.map(plus.filter(plugins, function(_ref) {
            var responseMiddlewareAsync = _ref.responseMiddlewareAsync;
            return responseMiddlewareAsync;
          }), function(plugin) {
            return plugin.responseMiddlewareAsync.bind(plugin);
          });
          var prev = Promise.resolve(context);
          responseMiddlewareAsyncs.forEach(function(p) {
            prev = prev.then(p);
          });
          return prev.then(function(val) {
            return val.data;
          });
        };
        instance._fromUrlWithDefault = function(path, defaultFn) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          path = applyHypermedia.apply(void 0, [path].concat(args));
          verbMethods.injectVerbMethods(path, defaultFn);
          return defaultFn;
        };
        instance.fromUrl = function(path) {
          for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          var defaultFn = function defaultFn2() {
            deprecate2("call ....fetch() explicitly instead of ...()");
            return defaultFn2.fetch.apply(defaultFn2, arguments);
          };
          return instance._fromUrlWithDefault.apply(instance, [path, defaultFn].concat(args));
        };
        instance._fromUrlCurried = function(path, defaultFn) {
          var fn = function fn2() {
            for (var _len3 = arguments.length, templateArgs = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              templateArgs[_key3] = arguments[_key3];
            }
            if (defaultFn && templateArgs.length === 0) {
              return defaultFn.apply(fn2);
            } else {
              return instance.fromUrl.apply(instance, [path].concat(templateArgs));
            }
          };
          if (!/\{/.test(path)) {
            verbMethods.injectVerbMethods(path, fn);
          }
          return fn;
        };
        instance.status = instance.fromUrl("https://status.github.com/api/status.json");
        instance.status.api = instance.fromUrl("https://status.github.com/api.json");
        instance.status.lastMessage = instance.fromUrl("https://status.github.com/api/last-message.json");
        instance.status.messages = instance.fromUrl("https://status.github.com/api/messages.json");
        return instance;
      };
      module.exports = OctokatBase;
    }
  });

  // node_modules/octokat/dist/node/plugins/hypermedia.js
  var require_hypermedia2 = __commonJS({
    "node_modules/octokat/dist/node/plugins/hypermedia.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var deprecate2 = require_deprecate();
      module.exports = new (function() {
        function HyperMedia() {
          _classCallCheck(this, HyperMedia);
        }
        _createClass(HyperMedia, [{
          key: "replace",
          value: function replace(instance, data) {
            if (Array.isArray(data)) {
              return this._replaceArray(instance, data);
            } else if (typeof data === "function") {
              return data;
            } else if (data instanceof Date) {
              return data;
            } else if (data === Object(data)) {
              return this._replaceObject(instance, data);
            } else {
              return data;
            }
          }
        }, {
          key: "_replaceObject",
          value: function _replaceObject(instance, orig) {
            var acc = {};
            var iterable = Object.keys(orig);
            for (var i = 0; i < iterable.length; i++) {
              var key = iterable[i];
              var value = orig[key];
              this._replaceKeyValue(instance, acc, key, value);
            }
            return acc;
          }
        }, {
          key: "_replaceArray",
          value: function _replaceArray(instance, orig) {
            var _this = this;
            var arr = orig.map(function(item) {
              return _this.replace(instance, item);
            });
            var iterable = Object.keys(orig);
            for (var i = 0; i < iterable.length; i++) {
              var key = iterable[i];
              var value = orig[key];
              this._replaceKeyValue(instance, arr, key, value);
            }
            return arr;
          }
        }, {
          key: "_replaceKeyValue",
          value: function _replaceKeyValue(instance, acc, key, value) {
            if (/_url$/.test(key)) {
              if (/^upload_url$/.test(key)) {
                var defaultFn = function defaultFn2() {
                  deprecate2("call .upload({name, label}).create(data, contentType) instead of .upload(name, data, contentType)");
                  return defaultFn2.create.apply(defaultFn2, arguments);
                };
                var fn = function fn2() {
                  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  return instance._fromUrlWithDefault.apply(instance, [value, defaultFn].concat(args))();
                };
              } else {
                var defaultFn = function defaultFn2() {
                  deprecate2("instead of directly calling methods like .nextPage(), use .nextPage.fetch()");
                  return this.fetch();
                };
                var fn = instance._fromUrlCurried(value, defaultFn);
              }
              var newKey = key.substring(0, key.length - "_url".length);
              acc[newKey] = fn;
              if (!/\{/.test(value)) {
                return acc[key] = value;
              }
            } else if (/_at$/.test(key)) {
              return acc[key] = value ? new Date(value) : null;
            } else {
              return acc[key] = this.replace(instance, value);
            }
          }
        }, {
          key: "responseMiddlewareAsync",
          value: function responseMiddlewareAsync(input) {
            var instance = input.instance, data = input.data;
            data = this.replace(instance, data);
            input.data = data;
            return Promise.resolve(input);
          }
        }]);
        return HyperMedia;
      }())();
    }
  });

  // node_modules/octokat/dist/node/grammar/object-matcher.js
  var require_object_matcher = __commonJS({
    "node_modules/octokat/dist/node/grammar/object-matcher.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      (function() {
        module.exports = {
          "repos": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/(repos(\/[^\/]+){2}|repositories\/([0-9]+))$/,
          "gists": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/gists\/[^\/]+$/,
          "issues": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/(repos(\/[^\/]+){2}|repositories\/([0-9]+))\/(issues|pulls)\/[^\/]+$/,
          "users": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/users\/[^\/]+$/,
          "orgs": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/orgs\/[^\/]+$/,
          "teams": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/teams\/[^\/]+$/,
          "repos.comments": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/repos\/[^\/]+\/[^\/]+\/comments\/[^\/]+$/
        };
      }).call(void 0);
    }
  });

  // node_modules/octokat/dist/node/plugins/object-chainer.js
  var require_object_chainer = __commonJS({
    "node_modules/octokat/dist/node/plugins/object-chainer.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var OBJECT_MATCHER = require_object_matcher();
      var TREE_OPTIONS = require_tree_options();
      var _require = require_verb_methods();
      var VerbMethods = _require.VerbMethods;
      var Chainer = require_chainer();
      module.exports = new (function() {
        function ObjectChainer() {
          _classCallCheck(this, ObjectChainer);
        }
        _createClass(ObjectChainer, [{
          key: "chainChildren",
          value: function chainChildren(chainer, url, obj) {
            return function() {
              var result = [];
              for (var key in OBJECT_MATCHER) {
                var re = OBJECT_MATCHER[key];
                var item = void 0;
                if (re.test(obj.url)) {
                  var context = TREE_OPTIONS;
                  var iterable = key.split(".");
                  for (var i = 0; i < iterable.length; i++) {
                    var k = iterable[i];
                    context = context[k];
                  }
                  item = chainer.chain(url, k, context, obj);
                }
                result.push(item);
              }
              return result;
            }();
          }
        }, {
          key: "responseMiddlewareAsync",
          value: function responseMiddlewareAsync(input) {
            var plugins = input.plugins, requester = input.requester, data = input.data, url = input.url;
            var verbMethods = new VerbMethods(plugins, requester);
            var chainer = new Chainer(verbMethods);
            if (url) {
              chainer.chain(url, true, {}, data);
              this.chainChildren(chainer, url, data);
            } else {
              chainer.chain("", null, {}, data);
              if (Array.isArray(data)) {
                for (var i = 0; i < data.length; i++) {
                  var datum = data[i];
                  this.chainChildren(chainer, datum.url, datum);
                }
              }
            }
            return Promise.resolve(input);
          }
        }]);
        return ObjectChainer;
      }())();
    }
  });

  // node_modules/octokat/dist/node/grammar/url-validator.js
  var require_url_validator = __commonJS({
    "node_modules/octokat/dist/node/grammar/url-validator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      (function() {
        module.exports = /^(https:\/\/status.github.com\/api\/(status.json|last-message.json|messages.json)$)|(https?:\/\/[^\/]+)?(\/api\/v3)?\/(zen|octocat|users|issues|gists|emojis|markdown|meta|rate_limit|feeds|events|repositories(\/\d+)?|notifications|notifications\/threads(\/[^\/]+)|notifications\/threads(\/[^\/]+)\/subscription|gitignore\/templates(\/[^\/]+)?|user(\/\d+)?|user(\/\d+)?\/(|repos|orgs|followers|following(\/[^\/]+)?|emails(\/[^\/]+)?|issues|public_emails|starred|starred(\/[^\/]+){2}|teams)|(orgs\/[^\/]+)|((organizations)(\/\d+)?)|(orgs\/[^\/]+)|(organizations\/\d+)\/(repos|issues|members|events|teams|projects)|projects\/[0-9]+|projects\/[0-9]+\/columns|projects\/columns\/[0-9]+|projects\/columns\/[0-9]+\/moves|projects\/columns\/[0-9]+\/cards|projects\/columns\/cards\/[0-9]+|projects\/columns\/cards\/[0-9]+\/moves|teams\/[^\/]+|teams\/[^\/]+\/(members(\/[^\/]+)?|memberships\/[^\/]+|repos|repos(\/[^\/]+){2})|users\/[^\/]+|users\/[^\/]+\/(repos|orgs|gists|followers|following(\/[^\/]+){0,2}|keys|starred|received_events(\/public)?|events(\/public)?|events\/orgs\/[^\/]+)|search\/(repositories|commits|issues|users|code)|gists\/(public|starred|([a-f0-9]{20,32}|[0-9]+)|([a-f0-9]{20,32}|[0-9]+)\/forks|([a-f0-9]{20,32}|[0-9]+)\/comments(\/[0-9]+)?|([a-f0-9]{20,32}|[0-9]+)\/star)|repos(\/[^\/]+){2}|(repos(\/[^\/]+){2}|repositories\/([0-9]+))\/(readme|tarball(\/[^\/]+)?|zipball(\/[^\/]+)?|compare\/([^\.{3}]+)\.{3}([^\.{3}]+)|deployments(\/[0-9]+)?|deployments\/[0-9]+\/statuses(\/[0-9]+)?|hooks|hooks\/[^\/]+|hooks\/[^\/]+\/tests|assignees|languages|teams|tags|branches(\/[^\/]+){0,2}|contributors|subscribers|subscription|stargazers|comments(\/[0-9]+)?|downloads(\/[0-9]+)?|forks|milestones|milestones\/[0-9]+|milestones\/[0-9]+\/labels|labels(\/[^\/]+)?|releases|releases\/([0-9]+)|releases\/([0-9]+)\/assets|releases\/latest|releases\/tags\/([^\/]+)|releases\/assets\/([0-9]+)|events|notifications|merges|statuses\/[a-f0-9]{40}|pages|pages\/builds|pages\/builds\/latest|commits|commits\/[a-f0-9]{40}|commits\/[a-f0-9]{40}\/(comments|status|statuses)?|contents\/|contents(\/[^\/]+)*|collaborators(\/[^\/]+)?|collaborators\/([^\/]+)\/permission|projects|(issues|pulls)|(issues|pulls)\/(events|events\/[0-9]+|comments(\/[0-9]+)?|[0-9]+|[0-9]+\/events|[0-9]+\/comments|[0-9]+\/labels(\/[^\/]+)?)|pulls\/[0-9]+\/(files|commits|merge|requested_reviewers|reviews(\/[0-9]+)?|reviews(\/[0-9]+)\/(comments|events|dismissals))|git\/(refs|refs\/(.+|heads(\/[^\/]+)?|tags(\/[^\/]+)?)|trees(\/[^\/]+)?|blobs(\/[a-f0-9]{40}$)?|commits(\/[a-f0-9]{40}$)?)|stats\/(contributors|commit_activity|code_frequency|participation|punch_card)|traffic\/(popular\/(referrers|paths)|views|clones))|licenses|licenses\/([^\/]+)|authorizations|authorizations\/((\d+)|clients\/([^\/]{20})|clients\/([^\/]{20})\/([^\/]+))|applications\/([^\/]{20})\/tokens|applications\/([^\/]{20})\/tokens\/([^\/]+)|enterprise\/(settings\/license|stats\/(issues|hooks|milestones|orgs|comments|pages|users|gists|pulls|repos|all))|staff\/indexing_jobs|users\/[^\/]+\/(site_admin|suspended)|setup\/api\/(start|upgrade|configcheck|configure|settings(authorized-keys)?|maintenance))(\?.*)?$/;
      }).call(void 0);
    }
  });

  // node_modules/octokat/dist/node/plugins/path-validator.js
  var require_path_validator = __commonJS({
    "node_modules/octokat/dist/node/plugins/path-validator.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var URL_VALIDATOR = require_url_validator();
      module.exports = new (function() {
        function PathValidator() {
          _classCallCheck(this, PathValidator);
        }
        _createClass(PathValidator, [{
          key: "requestMiddlewareAsync",
          value: function requestMiddlewareAsync(input) {
            var path = input.path;
            if (!URL_VALIDATOR.test(path)) {
              var err = "Octokat BUG: Invalid Path. If this is actually a valid path then please update the URL_VALIDATOR. path=" + path;
              console.warn(err);
            }
            return Promise.resolve(input);
          }
        }]);
        return PathValidator;
      }())();
    }
  });

  // node_modules/octokat/dist/node/adapters/base64-browser.js
  var require_base64_browser = __commonJS({
    "node_modules/octokat/dist/node/adapters/base64-browser.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      module.exports = btoa;
    }
  });

  // node_modules/octokat/dist/node/plugins/authorization.js
  var require_authorization = __commonJS({
    "node_modules/octokat/dist/node/plugins/authorization.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var base64encode = require_base64_browser();
      module.exports = new (function() {
        function Authorization() {
          _classCallCheck(this, Authorization);
        }
        _createClass(Authorization, [{
          key: "requestMiddlewareAsync",
          value: function requestMiddlewareAsync(input) {
            if (input.headers == null) {
              input.headers = {};
            }
            var headers = input.headers, _input$clientOptions = input.clientOptions, token = _input$clientOptions.token, username = _input$clientOptions.username, password = _input$clientOptions.password;
            if (token || username && password) {
              if (token) {
                var auth = "token " + token;
              } else {
                var auth = "Basic " + base64encode(username + ":" + password);
              }
              input.headers["Authorization"] = auth;
            }
            return Promise.resolve(input);
          }
        }]);
        return Authorization;
      }())();
    }
  });

  // node_modules/octokat/dist/node/grammar/preview-headers.js
  var require_preview_headers = __commonJS({
    "node_modules/octokat/dist/node/grammar/preview-headers.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      (function() {
        module.exports = {
          "application/vnd.github.drax-preview+json": /^(https?:\/\/[^\/]+)?(\/api\/v3)?(\/licenses|\/licenses\/([^\/]+)|\/repos\/([^\/]+)\/([^\/]+))$/,
          "application/vnd.github.v3.star+json": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/users\/([^\/]+)\/starred$/,
          "application/vnd.github.cloak-preview+json": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/search\/commits$/,
          "application/vnd.github.black-cat-preview+json": /^(https?:\/\/[^\/]+)?(\/api\/v3)?\/repos(\/[^\/]+){2}\/pulls\/[0-9]+\/(|requested_reviewers|reviews(\/[0-9]+)?|reviews(\/[0-9]+)\/(comments|events|dismissals))$/,
          "application/vnd.github.inertia-preview+json": /^(https?:\/\/[^\/]+)?(\/api\/v3)?(\/repos(\/[^\/]+){2}\/projects|\/orgs\/([^\/]+)\/projects|\/projects\/([0-9]+|[0-9]+\/columns|columns|columns\/[0-9]+|columns\/[0-9]+\/moves|columns\/[0-9]+\/cards|columns\/cards\/[0-9]+|columns\/cards\/[0-9]+\/moves))$/
        };
      }).call(void 0);
    }
  });

  // node_modules/octokat/dist/node/plugins/preview-apis.js
  var require_preview_apis = __commonJS({
    "node_modules/octokat/dist/node/plugins/preview-apis.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var PREVIEW_HEADERS = require_preview_headers();
      var DEFAULT_HEADER = function DEFAULT_HEADER2(url) {
        for (var key in PREVIEW_HEADERS) {
          var val = PREVIEW_HEADERS[key];
          if (val.test(url)) {
            return key;
          }
        }
      };
      module.exports = new (function() {
        function PreviewApis() {
          _classCallCheck(this, PreviewApis);
        }
        _createClass(PreviewApis, [{
          key: "requestMiddlewareAsync",
          value: function requestMiddlewareAsync(input) {
            var path = input.path;
            var acceptHeader = DEFAULT_HEADER(path);
            if (acceptHeader) {
              input.headers["Accept"] = acceptHeader;
            }
            return Promise.resolve(input);
          }
        }]);
        return PreviewApis;
      }())();
    }
  });

  // node_modules/octokat/dist/node/plugins/use-post-instead-of-patch.js
  var require_use_post_instead_of_patch = __commonJS({
    "node_modules/octokat/dist/node/plugins/use-post-instead-of-patch.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      module.exports = new (function() {
        function UsePostInsteadOfPatch() {
          _classCallCheck(this, UsePostInsteadOfPatch);
        }
        _createClass(UsePostInsteadOfPatch, [{
          key: "requestMiddlewareAsync",
          value: function requestMiddlewareAsync(input, cb) {
            var usePostInsteadOfPatch = input.clientOptions.usePostInsteadOfPatch, method = input.method;
            if (usePostInsteadOfPatch && method === "PATCH") {
              input.method = "POST";
            }
            return Promise.resolve(input);
          }
        }]);
        return UsePostInsteadOfPatch;
      }())();
    }
  });

  // node_modules/octokat/dist/node/plugins/fetch-all.js
  var require_fetch_all = __commonJS({
    "node_modules/octokat/dist/node/plugins/fetch-all.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var toQueryString = require_querystring2();
      var pushAll = function pushAll2(target, source) {
        if (!Array.isArray(source)) {
          throw new Error("Octokat Error: Calling fetchAll on a request that does not yield an array");
        }
        return target.push.apply(target, source);
      };
      var getMore = function getMore2(fetchable, requester, acc) {
        var nextPagePromise = fetchNextPage(fetchable, requester);
        if (nextPagePromise) {
          return nextPagePromise.then(function(results) {
            pushAll(acc, results.items);
            return getMore2(results, requester, acc);
          });
        } else {
          return acc;
        }
      };
      var fetchNextPage = function fetchNextPage2(obj, requester) {
        if (typeof obj.next_page_url === "string") {
          return requester.request("GET", obj.next_page_url, null, null);
        } else if (obj.next_page) {
          return obj.next_page.fetch();
        } else if (typeof obj.nextPageUrl === "string") {
          return requester.request("GET", obj.nextPageUrl, null, null);
        } else if (obj.nextPage) {
          return obj.nextPage.fetch();
        } else {
          return false;
        }
      };
      module.exports = {
        asyncVerbs: {
          fetchAll: function fetchAll(requester, path) {
            return function(query) {
              return requester.request("GET", "" + path + toQueryString(query), null, null).then(function(results) {
                var acc = [];
                pushAll(acc, results.items);
                return getMore(results, requester, acc);
              });
            };
          }
        }
      };
    }
  });

  // node_modules/octokat/dist/node/plugins/pagination.js
  var require_pagination = __commonJS({
    "node_modules/octokat/dist/node/plugins/pagination.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      module.exports = new (function() {
        function Pagination() {
          _classCallCheck(this, Pagination);
        }
        _createClass(Pagination, [{
          key: "responseMiddlewareAsync",
          value: function responseMiddlewareAsync(input) {
            var jqXHR = input.jqXHR, data = input.data;
            if (!jqXHR) {
              return Promise.resolve(input);
            }
            if (Array.isArray(data)) {
              data = {
                items: data.slice()
              };
              var linksHeader = jqXHR.headers.get("Link");
              if (linksHeader) {
                linksHeader.split(",").forEach(function(part) {
                  var _part$match = part.match(/<([^>]+)>; rel="([^"]+)"/), _part$match2 = _slicedToArray(_part$match, 3), unusedField = _part$match2[0], href = _part$match2[1], rel = _part$match2[2];
                  data[rel + "_page_url"] = href;
                });
              }
              input.data = data;
            }
            return Promise.resolve(input);
          }
        }]);
        return Pagination;
      }())();
    }
  });

  // node_modules/octokat/dist/node/plugins/cache-handler.js
  var require_cache_handler = __commonJS({
    "node_modules/octokat/dist/node/plugins/cache-handler.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      module.exports = new (function() {
        function CacheHandler() {
          _classCallCheck(this, CacheHandler);
          this._cachedETags = {};
        }
        _createClass(CacheHandler, [{
          key: "get",
          value: function get3(method, path) {
            return this._cachedETags[method + " " + path];
          }
        }, {
          key: "add",
          value: function add(method, path, eTag, data, status) {
            return this._cachedETags[method + " " + path] = { eTag, data, status };
          }
        }, {
          key: "requestMiddlewareAsync",
          value: function requestMiddlewareAsync(input) {
            var clientOptions = input.clientOptions, method = input.method, path = input.path;
            if (input.headers == null) {
              input.headers = {};
            }
            var cacheHandler = clientOptions.cacheHandler || this;
            if (cacheHandler.get(method, path)) {
              input.headers["If-None-Match"] = cacheHandler.get(method, path).eTag;
            } else {
              input.headers["If-Modified-Since"] = "Thu, 01 Jan 1970 00:00:00 GMT";
            }
            return Promise.resolve(input);
          }
        }, {
          key: "responseMiddlewareAsync",
          value: function responseMiddlewareAsync(input, cb) {
            var clientOptions = input.clientOptions, request3 = input.request, status = input.status, jqXHR = input.jqXHR, data = input.data;
            if (!jqXHR) {
              return Promise.resolve(input);
            }
            if (jqXHR) {
              var method = request3.method, path = request3.path;
              var cacheHandler = clientOptions.cacheHandler || this;
              if (status === 304 || status === 0) {
                var ref = cacheHandler.get(method, path);
                if (ref) {
                  var eTag;
                  data = ref.data;
                  status = ref.status;
                  eTag = ref.eTag;
                } else {
                  throw new Error("ERROR: Bug in Octokat cacheHandler for path '" + method + " " + path + "'. It had an eTag but not the cached response.");
                }
              } else {
                if (method === "GET" && jqXHR.headers.get("ETag")) {
                  var eTag = jqXHR.headers.get("ETag");
                  cacheHandler.add(method, path, eTag, data, jqXHR.status);
                }
              }
              input.data = data;
              input.status = status;
              return Promise.resolve(input);
            }
          }
        }]);
        return CacheHandler;
      }())();
    }
  });

  // node_modules/octokat/dist/node/plugins/read-binary.js
  var require_read_binary = __commonJS({
    "node_modules/octokat/dist/node/plugins/read-binary.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var toQueryString = require_querystring2();
      module.exports = new (function() {
        function ReadBinary() {
          _classCallCheck(this, ReadBinary);
          this.verbs = {
            readBinary: function readBinary(path, query) {
              return { method: "GET", path: "" + path + toQueryString(query), options: { isRaw: true, isBase64: true } };
            }
          };
        }
        _createClass(ReadBinary, [{
          key: "requestMiddlewareAsync",
          value: function requestMiddlewareAsync(input) {
            var options = input.options;
            if (options) {
              var isBase64 = options.isBase64;
              if (isBase64) {
                input.headers["Accept"] = "application/vnd.github.raw";
                input.mimeType = "text/plain; charset=x-user-defined";
              }
            }
            return Promise.resolve(input);
          }
        }, {
          key: "responseMiddlewareAsync",
          value: function responseMiddlewareAsync(input) {
            var options = input.options, data = input.data;
            if (options) {
              var isBase64 = options.isBase64;
              if (isBase64) {
                var converted = "";
                var iterable = __range__(0, data.length, false);
                for (var j = 0; j < iterable.length; j++) {
                  var i = iterable[j];
                  converted += String.fromCharCode(data.charCodeAt(i) & 255);
                }
                input.data = converted;
              }
            }
            return Promise.resolve(input);
          }
        }]);
        return ReadBinary;
      }())();
      function __range__(left, right, inclusive) {
        var range = [];
        var ascending = left < right;
        var end = !inclusive ? right : ascending ? right + 1 : right - 1;
        for (var i = left; ascending ? i < end : i > end; ascending ? i++ : i--) {
          range.push(i);
        }
        return range;
      }
    }
  });

  // node_modules/octokat/dist/node/plugins/camel-case.js
  var require_camel_case = __commonJS({
    "node_modules/octokat/dist/node/plugins/camel-case.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var _createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var plus = require_plus();
      module.exports = new (function() {
        function CamelCase() {
          _classCallCheck(this, CamelCase);
        }
        _createClass(CamelCase, [{
          key: "responseMiddlewareAsync",
          value: function responseMiddlewareAsync(input) {
            var data = input.data;
            data = this.replace(data);
            input.data = data;
            return Promise.resolve(input);
          }
        }, {
          key: "replace",
          value: function replace(data) {
            if (Array.isArray(data)) {
              return this._replaceArray(data);
            } else if (typeof data === "function") {
              return data;
            } else if (data instanceof Date) {
              return data;
            } else if (data === Object(data)) {
              return this._replaceObject(data);
            } else {
              return data;
            }
          }
        }, {
          key: "_replaceObject",
          value: function _replaceObject(orig) {
            var acc = {};
            var iterable = Object.keys(orig);
            for (var i = 0; i < iterable.length; i++) {
              var key = iterable[i];
              var value = orig[key];
              this._replaceKeyValue(acc, key, value);
            }
            return acc;
          }
        }, {
          key: "_replaceArray",
          value: function _replaceArray(orig) {
            var _this = this;
            var arr = orig.map(function(item) {
              return _this.replace(item);
            });
            var iterable = Object.keys(orig);
            for (var i = 0; i < iterable.length; i++) {
              var key = iterable[i];
              var value = orig[key];
              this._replaceKeyValue(arr, key, value);
            }
            return arr;
          }
        }, {
          key: "_replaceKeyValue",
          value: function _replaceKeyValue(acc, key, value) {
            return acc[plus.camelize(key)] = this.replace(value);
          }
        }]);
        return CamelCase;
      }())();
    }
  });

  // node_modules/octokat/dist/node/octokat.js
  var require_octokat = __commonJS({
    "node_modules/octokat/dist/node/octokat.js"(exports, module) {
      "use strict";
      init_esbuild_inject();
      var deprecate2 = require_deprecate();
      var OctokatBase = require_base2();
      var HypermediaPlugin = require_hypermedia2();
      var ALL_PLUGINS = [
        require_object_chainer(),
        require_path_validator(),
        require_authorization(),
        require_preview_apis(),
        require_use_post_instead_of_patch(),
        require_simple_verbs(),
        require_fetch_all(),
        require_pagination(),
        require_cache_handler(),
        require_read_binary(),
        HypermediaPlugin,
        require_camel_case()
      ];
      var Octokat2 = function Octokat3() {
        var clientOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (clientOptions.plugins == null) {
          clientOptions.plugins = ALL_PLUGINS;
        }
        if (clientOptions.disableHypermedia) {
          deprecate2("Please use the clientOptions.plugins array and just do not include the hypermedia plugin");
          clientOptions.plugins = clientOptions.plugins.filter(function(plugin) {
            return plugin !== HypermediaPlugin;
          });
        }
        if (Octokat3.Fetch) {
          OctokatBase.Fetch = Octokat3.Fetch;
        }
        var instance = new OctokatBase(clientOptions);
        return instance;
      };
      module.exports = Octokat2;
    }
  });

  // node_modules/octokat/index.js
  var require_octokat2 = __commonJS({
    "node_modules/octokat/index.js"(exports, module) {
      init_esbuild_inject();
      module.exports = require_octokat();
    }
  });

  // src/index.js
  init_esbuild_inject();
  var import_bugout = __toESM(require_bugout());
  var import_octokat = __toESM(require_octokat2());

  // node_modules/js-base64/base64.mjs
  init_esbuild_inject();
  var version2 = "3.7.2";
  var VERSION = version2;
  var _hasatob = typeof atob === "function";
  var _hasbtoa = typeof btoa === "function";
  var _hasBuffer = typeof Buffer3 === "function";
  var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
  var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
  var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var b64chs = Array.prototype.slice.call(b64ch);
  var b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
  })(b64chs);
  var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
  var _fromCC = String.fromCharCode.bind(String);
  var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
  var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
  var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
  var btoaPolyfill = (bin) => {
    let u32, c0, c1, c2, asc = "";
    const pad2 = bin.length % 3;
    for (let i = 0; i < bin.length; ) {
      if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
        throw new TypeError("invalid character found");
      u32 = c0 << 16 | c1 << 8 | c2;
      asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
    }
    return pad2 ? asc.slice(0, pad2 - 3) + "===".substring(pad2) : asc;
  };
  var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer3.from(bin, "binary").toString("base64") : btoaPolyfill;
  var _fromUint8Array = _hasBuffer ? (u8a) => Buffer3.from(u8a).toString("base64") : (u8a) => {
    const maxargs = 4096;
    let strs = [];
    for (let i = 0, l = u8a.length; i < l; i += maxargs) {
      strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
    }
    return _btoa(strs.join(""));
  };
  var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
  var cb_utob = (c) => {
    if (c.length < 2) {
      var cc = c.charCodeAt(0);
      return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
    } else {
      var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
      return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
    }
  };
  var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
  var utob = (u) => u.replace(re_utob, cb_utob);
  var _encode = _hasBuffer ? (s) => Buffer3.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
  var encode2 = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
  var encodeURI2 = (src) => encode2(src, true);
  var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
  var cb_btou = (cccc) => {
    switch (cccc.length) {
      case 4:
        var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
        return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
      case 3:
        return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
      default:
        return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
    }
  };
  var btou = (b) => b.replace(re_btou, cb_btou);
  var atobPolyfill = (asc) => {
    asc = asc.replace(/\s+/g, "");
    if (!b64re.test(asc))
      throw new TypeError("malformed base64.");
    asc += "==".slice(2 - (asc.length & 3));
    let u24, bin = "", r1, r2;
    for (let i = 0; i < asc.length; ) {
      u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
      bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
  };
  var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer3.from(asc, "base64").toString("binary") : atobPolyfill;
  var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer3.from(a, "base64")) : (a) => _U8Afrom(_atob(a), (c) => c.charCodeAt(0));
  var toUint8Array = (a) => _toUint8Array(_unURI(a));
  var _decode = _hasBuffer ? (a) => Buffer3.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
  var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
  var decode = (src) => _decode(_unURI(src));
  var isValid = (src) => {
    if (typeof src !== "string")
      return false;
    const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
  };
  var _noEnum = (v) => {
    return {
      value: v,
      enumerable: false,
      writable: true,
      configurable: true
    };
  };
  var extendString = function() {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add("fromBase64", function() {
      return decode(this);
    });
    _add("toBase64", function(urlsafe) {
      return encode2(this, urlsafe);
    });
    _add("toBase64URI", function() {
      return encode2(this, true);
    });
    _add("toBase64URL", function() {
      return encode2(this, true);
    });
    _add("toUint8Array", function() {
      return toUint8Array(this);
    });
  };
  var extendUint8Array = function() {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add("toBase64", function(urlsafe) {
      return fromUint8Array(this, urlsafe);
    });
    _add("toBase64URI", function() {
      return fromUint8Array(this, true);
    });
    _add("toBase64URL", function() {
      return fromUint8Array(this, true);
    });
  };
  var extendBuiltins = () => {
    extendString();
    extendUint8Array();
  };
  var gBase64 = {
    version: version2,
    VERSION,
    atob: _atob,
    atobPolyfill,
    btoa: _btoa,
    btoaPolyfill,
    fromBase64: decode,
    toBase64: encode2,
    encode: encode2,
    encodeURI: encodeURI2,
    encodeURL: encodeURI2,
    utob,
    btou,
    decode,
    isValid,
    fromUint8Array,
    toUint8Array,
    extendString,
    extendUint8Array,
    extendBuiltins
  };

  // src/index.js
  var prettifyXml = (sourceXml) => {
    var xmlDoc = new DOMParser().parseFromString(sourceXml, "application/xml");
    var xsltDoc = new DOMParser().parseFromString([
      '<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">',
      '  <xsl:strip-space elements="*"/>',
      '  <xsl:template match="para[content-style][not(text())]">',
      '    <xsl:value-of select="normalize-space(.)"/>',
      "  </xsl:template>",
      '  <xsl:template match="node()|@*">',
      '    <xsl:copy><xsl:apply-templates select="node()|@*"/></xsl:copy>',
      "  </xsl:template>",
      '  <xsl:output indent="yes"/>',
      "</xsl:stylesheet>"
    ].join("\n"), "application/xml");
    var xsltProcessor = new XSLTProcessor();
    xsltProcessor.importStylesheet(xsltDoc);
    var resultDoc = xsltProcessor.transformToDocument(xmlDoc);
    var resultXml = new XMLSerializer().serializeToString(resultDoc);
    return resultXml;
  };
  (function() {
    const waitForEvent = function(eventName, eventObj) {
      return new Promise((resolve2) => {
        eventObj.addEventListener(eventName, resolve2, { once: true });
      });
    };
    const waitForDOMContentLoaded = function() {
      if (document.readyState === "complete" || document.readyState === "interactive") {
        return Promise.resolve(null);
      } else {
        return waitForEvent("DOMContentLoaded", window);
      }
    };
    waitForDOMContentLoaded().then(() => {
      window.save = async () => {
        const html = prettifyXml(new XMLSerializer().serializeToString(document));
        const github = new import_octokat.default({ token: localStorage.get("token") });
        const repoUser = document.location.split(".")[0];
        const repoName = document.location.domain;
        console.log(repoUser, repoName);
        const repo = await github.repos(repoUser, repoName);
        console.log(repo);
        const blob = await repo.git.blobs.create({ content: gBase64.encode(html), encoding: "base64" });
        console.log(blob);
        const main = await repo.git.refs("heads/master").fetch();
        console.log(main);
        const tree = await repo.git.trees.create({
          tree: [{ path: "index.html", sha: blob.sha, mode: "100644", type: "blob" }],
          base_tree: main.object.sha
        });
        const commit = await repo.git.commits.create({ message: `Update`, tree: tree.sha, parents: [main.object.sha] });
        main.update({ sha: commit.sha });
        console.log("posted");
      };
    });
  })();
})();
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! bittorrent-protocol. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
/*! blob-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! cache-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! create-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
/*! https://mths.be/punycode v1.4.1 by @mathias */
/*! immediate-chunk-store. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! lt_donthave. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
/*! magnet-uri. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
/*! mediasource. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! multistream. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! parse-torrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! render-media. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! simple-get. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! stream-to-blob-url. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! stream-to-blob. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! stream-with-known-length-to-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! torrent-discovery. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
/*! torrent-piece. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
/*! ut_metadata. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
/*! webtorrent. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> */
