var b=class extends THREE.BufferGeometry{constructor(){super(),this.type="SvoxBufferGeometry"}update(e,a=!0){let{positions:p,normals:M,colors:E,bounds:t,uvs:g,data:s,indices:r}=e;this.freeMemory();let h=this.boundingBox,m=this.boundingSphere;if(h||(h=this.boundingBox=new THREE.Box3),m||(m=this.boundingSphere=new THREE.Sphere),h.min.set(t.minX,t.minY,t.minZ),h.max.set(t.maxX,t.maxY,t.maxZ),m.center.set(t.centerX,t.centerY,t.centerZ),m.radius=t.radius,this.setAttribute("position",new THREE.Float32BufferAttribute(p,3)),this.setAttribute("normal",new THREE.Float32BufferAttribute(M,3)),this.setAttribute("color",new THREE.Float32BufferAttribute(E,3)),g&&this.setAttribute("uv",new THREE.Float32BufferAttribute(g,2)),s)for(let u=0;u<s.length;u++)this.setAttribute(s[u].name,new THREE.Float32BufferAttribute(s[u].values,s[u].width));this.setIndex(new THREE.BufferAttribute(r,1)),this.clearGroups(),a?e.groups.forEach(function(u){this.addGroup(u.start,u.count,u.materialIndex)},this):this.setDrawRange(0,r.length),this.uvsNeedUpdate=!0}dispose(){this.freeMemory(),super.dispose()}freeMemory(){for(let e of Object.keys(this.attributes))this.deleteAttribute(e);this.clearGroups()}};var l=class{static generate(e){let a=[];e.materials.forEach(function(E){a.push(l._generateMaterial(E))},this);let p=new THREE.BufferGeometry;return l.updateGeometry(e,p,!0),new THREE.Mesh(p,a)}static updateGeometry(e,a,p=!0){for(let c of Object.keys(a.attributes))a.deleteAttribute(c);let M=a.boundingBox,E=a.boundingSphere,{positions:t,normals:g,colors:s,bounds:r,uvs:h,data:m,indices:u}=e;if(M||(M=a.boundingBox=new THREE.Box3),E||(E=a.boundingSphere=new THREE.Sphere),M.min.set(r.minX,r.minY,r.minZ),M.max.set(r.minX,r.minY,r.minZ),E.center.set(r.centerX,r.centerY,r.centerZ),E.radius=r.radius,a.setAttribute("position",new THREE.Float32BufferAttribute(t,3)),a.setAttribute("normal",new THREE.Float32BufferAttribute(g,3)),a.setAttribute("color",new THREE.Float32BufferAttribute(s,3)),h&&a.setAttribute("uv",new THREE.Float32BufferAttribute(h,2)),m)for(let c=0;c<m.length;c++)a.setAttribute(m[c].name,new THREE.Float32BufferAttribute(m[c].values,m[c].width));a.setIndex(new THREE.BufferAttribute(u,1)),a.clearGroups(),p?e.groups.forEach(function(c){a.addGroup(c.start,c.count,c.materialIndex)},this):a.setDrawRange(0,u.length),a.uvsNeedUpdate=!0}static _generateMaterial(e){switch(e.reflectivity=(1-e.roughness)*(e.metalness*.95+.05),e.shininess=Math.pow(10,5*Math.pow(1-e.roughness,1.1))*.1,e.side){case"back":e.side=THREE.BackSide;break;case"double":e.side=THREE.DoubleSide;break;default:e.side=THREE.FrontSide;break}e.map&&(e.map=l._generateTexture(e.map.image,THREE.sRGBEncoding,e.map.uscale,e.map.vscale,e.map.uoffset,e.map.voffset,e.map.rotation)),e.normalMap&&(e.normalMap=l._generateTexture(e.normalMap.image,THREE.LinearEncoding,e.normalMap.uscale,e.normalMap.vscale,e.normalMap.uoffset,e.normalMap.voffset,e.normalMap.rotation)),e.roughnessMap&&(e.roughnessMap=l._generateTexture(e.roughnessMap.image,THREE.LinearEncoding,e.roughnessMap.uscale,e.roughnessMap.vscale,e.roughnessMap.uoffset,e.roughnessMap.voffset,e.roughnessMap.rotation)),e.metalnessMap&&(e.metalnessMap=l._generateTexture(e.metalnessMap.image,THREE.LinearEncoding,e.metalnessMap.uscale,e.metalnessMap.vscale,e.metalnessMap.uoffset,e.metalnessMap.voffset,e.metalnessMap.rotation)),e.emissiveMap&&(e.emissiveMap=l._generateTexture(e.emissiveMap.image,THREE.sRGBEncoding,e.emissiveMap.uscale,e.emissiveMap.vscale,e.emissiveMap.uoffset,e.emissiveMap.voffset,e.emissiveMap.rotation)),e.matcap&&(e.matcap=l._generateTexture(e.matcap.image,THREE.sRGBEncoding)),e.reflectionMap&&(e.envMap=new THREE.TextureLoader().load(e.reflectionMap.image),e.envMap.encoding=THREE.sRGBEncoding,e.envMap.mapping=THREE.EquirectangularReflectionMapping,delete e.reflectionMap),e.refractionMap&&(e.envMap=new THREE.TextureLoader().load(e.refractionMap.image),e.envMap.encoding=THREE.sRGBEncoding,e.envMap.mapping=THREE.EquirectangularRefractionMapping,delete e.refractionMap);let a=null,p=e.type;switch(delete e.index,delete e.type,p){case"standard":delete e.reflectivity,delete e.shininess,a=new THREE.MeshStandardMaterial(e);break;case"basic":delete e.roughness,delete e.metalness,delete e.shininess,delete e.emissive,delete e.emissiveIntensity,delete e.roughnessMap,delete e.metalnessMap,delete e.emissiveMap,a=new THREE.MeshBasicMaterial(e);break;case"lambert":delete e.roughness,delete e.metalness,delete e.shininess,delete e.roughnessMap,delete e.metalnessMap,a=new THREE.MeshLambertMaterial(e);break;case"phong":delete e.roughness,delete e.metalness,delete e.roughnessMap,delete e.metalnessMap,a=new THREE.MeshPhongMaterial(e);break;case"matcap":delete e.roughness,delete e.metalness,delete e.wireframe,delete e.reflectivity,delete e.shininess,delete e.emissive,delete e.emissiveIntensity,delete e.envMap,delete e.roughnessMap,delete e.metalnessMap,delete e.emissiveMap,delete e.reflectionMap,delete e.refractionMap,delete e.refractionRatio,a=new THREE.MeshMatcapMaterial(e);break;case"toon":delete e.roughness,delete e.metalness,delete e.reflectivity,delete e.shininess,delete e.emissive,delete e.emissiveIntensity,delete e.envMap,delete e.roughnessMap,delete e.metalnessMap,delete e.reflectionMap,delete e.refractionMap,delete e.refractionRatio,a=new THREE.MeshToonMaterial(e);break;case"normal":delete e.roughness,delete e.metalness,delete e.reflectivity,delete e.shininess,delete e.emissive,delete e.emissiveIntensity,delete e.map,delete e.envMap,delete e.roughnessMap,delete e.metalnessMap,delete e.emissiveMap,delete e.reflectionMap,delete e.refractionMap,delete e.refractionRatio,a=new THREE.MeshNormalMaterial(e);break;default:throw new Error(`SyntaxError: Unknown material type ${p}`)}return a}static _generateTexture(e,a,p,M,E,t,g){let s=new THREE.TextureLoader().load(e);return s.encoding=a,s.repeat.set(1/p,1/M),s.wrapS=THREE.RepeatWrapping,s.wrapT=THREE.RepeatWrapping,s.offset=new THREE.Vector2(E,t),s.rotation=g*Math.PI/180,s}};export{b as SvoxBufferGeometry,l as SvoxToThreeMeshConverter};
